<schema xmlns="http://purl.oclc.org/dsdl/schematron" >
  <let name="standards" value="document('../web-platform/all.xml')"/>
     <pattern  id="definedTypes">
       <title>IDL is using defined types</title>
          <rule context="//Type[@name]">
               <assert role="warning" test="//Interface[@name=current()/@name] or $standards//Interface[@name=current()/@name] or //Dictionary[@name=current()/@name]  or $standards//Dictionary[@name=current()/@name] or //Typedef[@name=current()/@name] or $standards//Typedef[@name=current()/@name] or //Callback[@name=current()/@name] or $standards//Callback[@name=current()/@name] or //Enum[@name=current()/@name] or $standards//Enum[@name=current()/@name]"><value-of select="@name"/> type used in <value-of select="ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name" />.<value-of select="ancestor::*[Type and local-name()!='Type'][1]/@name" /> declaration undefined.</assert>
          </rule>
     </pattern>
     <pattern>
       <title>partial interface refer to existing interface</title>
       <rule context="//Interface[@partial]">
	 <assert role="warning" test="//Interface[@name=current()/@name and not(@partial)] or $standards//Interface[@name=current()/@name and not(@partial)]">Partial interface <value-of select="@name" /> does not have matching full interface</assert>
       </rule>
     </pattern>
     <pattern>
       <title>callback interface do not inherit from non callback interface</title>
       <rule context="//Interface[@callback]">
	 <assert role="warning" test="not(InterfaceInheritance) or (//Interface[@name=current()/InterfaceInheritance/Name/@name and @callback] or $standards//Interface[@name=current()/InterfaceInheritance/Name/@name and @callback])">Callback interface <value-of select="@name" /> inherits from non-callback interface <value-of select="InterfaceInheritance/Name/@name"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>regular interfaces do not inherit from callback interface</title>
       <rule context="//Interface[not(@callback)]">
	 <assert role="warning" test="not(InterfaceInheritance) or (//Interface[@name=current()/InterfaceInheritance/Name/@name and not(@callback)] or $standards//Interface[@name=current()/InterfaceInheritance/Name/@name and not(@callback)])">Non-callback interface <value-of select="@name" /> inherits from callback interface <value-of select="InterfaceInheritance/Name/@name"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>Names of interfaces / exceptions / dictionaries don't clash</title>
       <rule context="//Typedef[@id]|//Dictionary[@id]">
	 <assert test="not(preceding::*[local-name()='Interface' or local-name()='Typedef' or local-name()='Dictionary'][@id=current()/@id])"><value-of select="concat(local-name(.), ' ', @name)"/> clashes with previous definition of <value-of select="concat(local-name(preceding::*[local-name()='Interface'  or local-name()='Typedef' or local-name()='Dictionary'][@name=current()/@name][1]),' ', @name)"/></assert>
       </rule>
       <rule context="//Interface[@id]">
	 <assert test="(@partial or not(preceding::Interface[@id=current()/@id])) or not(preceding::*[local-name()='Typedef' or local-name()='Dictionary'][@id=current()/@id])"><value-of select="concat(local-name(.), ' ', @name)"/> clashes with previous definition of <value-of select="concat(local-name(preceding::*[local-name()='Interface' or local-name()='Typedef' or local-name()='Dictionary'][@name=current()/@name][1]),' ', @name)"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>Constant/Attribute names don't clash with other interface/exception members</title>
       <rule context="//Const|//Attribute">
	 <assert test="not(preceding-sibling::*[local-name()='Operation' or local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionary member names don't clash with other dictionary members</title>
       <rule context="//DictionaryMember">
	 <assert test="not(preceding-sibling::DictionaryMember[@name=current()/@name])">Dictionary member <value-of select="@name"/> in <value-of select="parent::Dictionary/@name"/> clashes with another dictionary member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Operations</title>
       <rule context="//Operation">
	 <assert test="@name or @stringifier or @getter or @setter or @creator or @deleter or @legacycaller"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> has an operation without identifier but which is not a special operation.</assert>
	 <assert test="not(preceding-sibling::*[local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
	 <assert test="not(ArgumentList/Argument[@ellipsis]) or not(ArgumentList/Argument[@ellipsis]/following-sibling::Argument)"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> defines a variadic operation (<value-of select="@name"/>) but the ... is not set on the last argument.</assert>
	 <assert test="not(ArgumentList/Argument[@ellipsis and @optional])"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> defines a variadic operation (<value-of select="@name"/>) whose final argument is declared optional.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Sequence are not to be used for attributes definition</title>
       <rule context="//Attribute">
	 <assert test="not(Type[@type='sequence']) and not(//Typedef[@name=current()/Type/@name]/Type[@type='sequence'])">Attribute <value-of select="@name"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a sequence.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionaries are not to be used for attributes or exception fields</title>
       <rule context="//Attribute">
	 <assert test="not(//Dictionary[@name=current()/Type/@name])"><value-of select="concat(local-name(),' ',@name)"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a dictionary.</assert>
       </rule>
     </pattern>
     <!--
     <pattern>
       <title>Constant values need to match their types</title>
       <rule context="//Const|//DictionaryMember[@value or @stringvalue]">
	  
       </rule>
     </pattern>
     -->
     <pattern>
       <title>Special Operations</title>
       <rule context="//Operation[@stringifier or @getter or @setter or @creator or @deleter or @legacycaller]">
	 <assert test="not(@stringifier) or not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index getter.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name getter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index deleter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name deleter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index setter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name setter.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index creator.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name creator.</assert>
	 <assert test="not(ArgumentList/Argument/@ellipsis)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation that is variadic.</assert>
	 <assert test="not(ArgumentList/Argument/@optional)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation with optional arguments.</assert>
	 <assert test="not(@stringifier) or not(ArgumentList/Argument)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with arguments.</assert>
	 <assert test="not(@stringifier) or Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with a return type that is not a DOMString.</assert>
	 <assert test="not(@getter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation that doesn't take a single argument.</assert>
	 <assert test="not(@deleter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation that doesn't take a single argument.</assert>
	 <assert test="not(@setter) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@creator) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@getter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@setter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@deleter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@creator) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation with first argument different from DOMString and unsigned long.</assert>
	 <assert role="warning" test="not(@legacycaller)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a caller operation, but caller should be reserved to specify legacy APIs</assert>
	 <assert test="not(@setter) or (ancestor::Interface/Operation[@getter and ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter but does not define a getter of the same variety.</assert>
	 <assert test="not(@creator) or (ancestor::Interface/Operation[@getter and ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator but does not define a getter of the same variety.</assert>
	 <assert test="not(@deleter) or (ancestor::Interface/Operation[@getter and ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter but does not define a getter of the same variety.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Attribute with inherits getter</title>
       <rule context="//Attribute[@inherit='inherit']">
	 <assert test="not(@readonly='readonly' or @static='static')">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but is marked as readonly or static.</assert>
	 <assert test="ancestor::Interface[InterfaceInheritance]">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but does not belong to an interface with inheritance.</assert>
	 <assert test="not(ancestor::Interface[InterfaceInheritance] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name])
		       or //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type[concat(@type,@name)=concat(current()/Type/@type,current()/Type/@name)]">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but does not have the same type (<value-of select="concat(Type/@name,Type/@type)"/>) as the attribute <value-of select="concat(//Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/@name, '.', //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute/@name)"/> (<value-of select="concat(//Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type/@type, //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type/@name)"/>) it inherits from.</assert>
	 <assert test="not(ancestor::Interface[InterfaceInheritance] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name])
		       or //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/@readonly='readonly'">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter, but that attribute is not marked as read-only on the inherited interface <value-of select="//Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/@name"/>.</assert>

       </rule>       
     </pattern>
     <pattern>
       <title>Stringifier attributes</title>
       <rule context="//Attribute[@stringifier]">
	 <assert test="Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier attribute that is not of type DOMString.</assert>
	 <assert test="not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Overloading</title>
     </pattern>
     <pattern>
       <title>Extended attributes are well-known</title>
       <rule context="//ExtendedAttribute[@name]">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#es-extended-attributes" test="@name='ArrayClass' or @name='Constructor' or @name='NamedConstructor' or @name='NoInterfaceObject' or @name='OverrideBuiltins' or @name='PutForwards' or @name='Replaceable' or @name='TreatNullAs' or @name='TreatUndefinedAs' or @name='TreatNonCallableAsNull' or @name='TreatNonCallableAsNull' or @name='Clamp' or @name='Unforgeable' or @name='EnforceRange' or @name='ImplicitThis' or @name='LenientThis' or @name='SameObject' or @name='NewObject' or @name='EnsureUTF16' or @name='Global' or @name='MapClass' or @name='Exposed'">Extended attribute of <value-of select="@name"/> is unknown in WebIDL.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute common abstract rules</title>
       <rule  id="extendedAttributeAppliesToInterface" abstract="true">
	 <assert test="parent::ExtendedAttributeList/parent::Interface">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on interfaces.</assert>	 
       </rule>
       <rule  name="Extended attribute takes no argument" id="extendedAttributeNoArg" abstract="true">
	 <assert test="not(@value)">Extended attribute <value-of select="@name"/> used with arguments on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*),' ',parent::ExtendedAttributeList/parent::*/@name)"/>.</assert>
       </rule>
       <rule name="Extended attribute cannot be used on an interface that inherits from another" id="extendedAttributeNotWithInheritance" abstract="true">
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has extended attribute <value-of select="@name"/> but inherits from another interface (<value-of select="parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance/Name/@name"/>).</assert>
       </rule>
       <rule name="Extended attribute can only be used on attribute" abstract="true" id="extendedAttributeAppliesToAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
       </rule>
       <rule name="Extended attribute can only be used on read-only attribute" abstract="true" id="extendedAttributeAppliesToReadonlyAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute) or parent::ExtendedAttributeList/parent::Attribute[@readonly='readonly']">Extended attribute <value-of select="@name"/> used on non-readonly attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> — <value-of select="@name"/> expected only on readonly attributes.</assert>
       </rule>

     </pattern>
     <pattern>
       <title>Extended attribute Constructor</title>
       <rule context="//ExtendedAttribute[@name='Constructor']">
	 <assert test="parent::ExtendedAttributeList/parent::Interface or parent::ExtendedAttributeList/parent::Dictionary">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on interfaces and dictionaries.</assert>	 
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NamedConstructor</title>
       <rule context="//ExtendedAttribute[@name='NamedConstructor']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <!-- @@@ The NamedConstructor clash checks should be done across all well-known IDLs -->
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on externally defined interface <value-of select="$standards//Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 

	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with  interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with externally defined interface <value-of select="$standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert>

       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NoInterfaceObject</title>
       <rule context="//ExtendedAttribute[@name='NoInterfaceObject']">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="parent::ExtendedAttributeList/parent::Interface">Extended attribute NoInterfaceObject used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — NoInterfaceObject expected only on interfaces.</assert>
	 <extends rule="extendedAttributeNoArg"/>
	 <!-- @@@ shouldn't this also apply to NamedConstructor? -->
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor'])">Extended attribute NoInterfaceObject used in combination with extended attribute Constructor on interface <value-of select="parent::ExtendedAttributeList/parent::*/@name"/>.</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="not(ancestor::Interface/Operation[@static='static'])">Extended attribute NoInterfaceObject used on interface <value-of select="parent::ExtendedAttributeList/parent::*/@name"/>, but that interface that has a static operation .</assert>
	 <!-- TODO: The [NoInterfaceObject] extended attribute SHOULD NOT be used on interfaces that are not solely used as supplemental or callback interfaces, unless there are clear Web compatibility reasons for doing so.  -->
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute OverrideBuiltins</title>
       <rule context="//ExtendedAttribute[@name='OverrideBuiltins']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#OverrideBuiltins" test="parent::ExtendedAttributeList/parent::Interface[Operation/@getter]">Extended attribute OverrideBuiltins used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that does not have a name getter.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute NewObject</title>
       <rule context="//ExtendedAttribute[@name='NewObject']" >
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="parent::ExtendedAttributeList/parent::Operation">Extended attribute NewObject used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — NewObject expected only on operations.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Operation) or parent::ExtendedAttributeList/parent::Operation/@name">Extended attribute NewObject used on an operation without identifier in <value-of select="ancestor::Interface/@name" /> — NewObject expected only on regular or static operations.</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NewObject" test="not(parent::ExtendedAttributeList/parent::Operation/Type) or parent::ExtendedAttributeList/parent::Operation/Type/@name or parent::ExtendedAttributeList/parent::Operation/Type/@type='Promise'">Extended attribute NewObject used on an operation whose return type (<value-of select='parent::ExtendedAttributeList/parent::Operation/Type/@type'/>) is not an interface type or a promise.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute Global</title>
       <rule context="//ExtendedAttribute[@name='Global']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <!-- The interface MUST NOT define a named property setter, creator or deleter. -->
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(parent::ExtendedAttributeList/parent::Interface[Operation[(@setter or @creator or @deleter) and ArgumentList/Argument[1]/Type/@type='DOMString']])">Extended attribute Global used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that defines a named property setter, creator or deleter.</assert>
	 <!-- The interface MUST NOT also be declared with the [OverrideBuiltins] extended attribute. -->
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(parent::ExtendedAttributeList/ExtendedAttribute[@name='OverrideBuiltins'])">Extended attribute Global used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that is also declared with OverrideBuilins.</assert>
	 <!-- The interface MUST NOT inherit from another interface with the [OverrideBuiltins] extended attribute. -->
	  <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface[InterfaceInheritance] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/ExtendedAttributeList/ExtendedAttribute[@name='OverrideBuiltins'])">Extended attribute Global used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that inherits from another interface with the OverrideBuiltins extended attribute.</assert>
	  <!-- Any other interface MUST NOT inherit from it. -->
	  <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(//Interface[InterfaceInheritance/Name/@name=current()/parent::ExtendedAttributeList/parent::Interface/@name])">Interface <value-of select="//Interface[InterfaceInheritance/Name/@name=current()/parent::ExtendedAttributeList/parent::Interface/@name]/@name"/> inherits from interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that is declared with the Global extended attribute.</assert>
	  <!-- TODO: If [Global] is specified on a partial interface definition, then that partial interface definition MUST be the part of the interface definition that defines the named property getter.  -->
	  <!-- TODO: (?) The [Global] extended attribute MUST NOT be used on an interface that can have more than one object implementing it in the same ECMAScript global environment. -->
	  <!-- TODO: If an interface is declared with the [Global] extended attribute, then there MUST NOT be more than one interface member across the interface and its consequential interfaces with the same identifier. -->
	  <!-- TODO: There also MUST NOT be more than stringifier, more than one serializer, or more than one iterator across those interfaces.  -->
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute MapClass</title>
       <rule context="//ExtendedAttribute[@name='MapClass']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <!-- The [MapClass] extended attribute MUST take a type pair. -->
	 <assert test="TypeList and count(TypeList/Type)=2">Extended attribute MapClass used on interface <value-of select="ancestor::Interface"/> requires a type pair declaration.</assert>
	 <!-- The [MapClass] extended attribute MUST NOT be used on an interface that has any inherited interfaces -->
	  <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(//Interface[InterfaceInheritance/Name/@name=current()/parent::ExtendedAttributeList/parent::Interface/@name])">Interface <value-of select="//Interface[InterfaceInheritance/Name/@name=current()/parent::ExtendedAttributeList/parent::Interface/@name]/@name"/> inherits from interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that is declared with the MapClass extended attribute.</assert>
	 <!-- or which is declared with the [ArrayClass] or [Global] extended attribute. -->
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Global'])">Extended attribute MapClass used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that is also declared with Global.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(parent::ExtendedAttributeList/ExtendedAttribute[@name='ArrayClass'])">Extended attribute MapClass used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that is also declared with ArrayClass.</assert>
	 <!-- If an interface member with the identifier “clear”, “delete”, “forEach”, “get”, “has” or “set” is declared on the interface or any of its consequential interfaces, then it MUST be defined as in the IDL fragment [in the spec] -->
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface/*[@name='clear']) or (local-name(ancestor::Interface/*[@name='clear'])='Operation' and not(ancestor::Interface/Operation[@name='clear']/ArgumentList/Argument) and ancestor::Interface/Operation[@name='clear']/Type/@type='void')">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "clear" that does not match the expected signature.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface/*[@name='delete']) or (local-name(ancestor::Interface/*[@name='delete'])='Operation' and count(ancestor::Interface/Operation[@name='delete']/ArgumentList/Argument)=1 and (ancestor::Interface/Operation[@name='delete']/ArgumentList/Argument/Type/@type=TypeList/Type[1]/@type or ancestor::Interface/Operation[@name='delete']/ArgumentList/Argument/Type/@name=TypeList/Type[1]/@name) and ancestor::Interface/Operation[@name='delete']/Type/@type='boolean')">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "delete" that does not match the expected signature.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface/*[@name='get']) or (local-name(ancestor::Interface/*[@name='get'])='Operation' and count(ancestor::Interface/Operation[@name='get']/ArgumentList/Argument)=1 and (ancestor::Interface/Operation[@name='get']/ArgumentList/Argument/Type/@type=TypeList/Type[1]/@type or ancestor::Interface/Operation[@name='get']/ArgumentList/Argument/Type/@name=TypeList/Type[1]/@name) and (ancestor::Interface/Operation[@name='get']/Type/@type=TypeList/Type[2]/@type or ancestor::Interface/Operation[@name='get']/Type/@name=TypeList/Type[2]/@name))">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "get" that does not match the expected signature.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface/*[@name='has']) or (local-name(ancestor::Interface/*[@name='has'])='Operation' and count(ancestor::Interface/Operation[@name='has']/ArgumentList/Argument)=1 and (ancestor::Interface/Operation[@name='has']/ArgumentList/Argument/Type/@type=TypeList/Type[1]/@type or ancestor::Interface/Operation[@name='has']/ArgumentList/Argument/Type/@name=TypeList/Type[1]/@name) and ancestor::Interface/Operation[@name='has']/Type/@type='boolean')">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "has" that does not match the expected signature.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface) or not(ancestor::Interface/*[@name='set']) or (local-name(ancestor::Interface/*[@name='set'])='Operation' and count(ancestor::Interface/Operation[@name='set']/ArgumentList/Argument)=2 and (ancestor::Interface/Operation[@name='set']/ArgumentList/Argument[1]/Type/@type=TypeList/Type[1]/@type or ancestor::Interface/Operation[@name='set']/ArgumentList/Argument[1]/Type/@name=TypeList/Type[1]/@name) and (ancestor::Interface/Operation[@name='set']/ArgumentList/Argument[2]/Type/@type=TypeList/Type[2]/@type or ancestor::Interface/Operation[@name='set']/ArgumentList/Argument[2]/Type/@name=TypeList/Type[2]/@name) and ancestor::Interface/Operation[@name='set']/Type/@name=ancestor::Interface/@name)">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "set" that does not match the expected signature.</assert>
	 <assert 
	     test="
		   not(parent::ExtendedAttributeList/parent::Interface) or
		   not(ancestor::Interface/*[@name='forEach'])
		   or (
		   local-name(ancestor::Interface/*[@name='forEach'])='Operation' 
		   and count(ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument)=2 
		   and ancestor::Interface/Operation[@name='forEach']/Type/@type='void' 
		   and ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[2]/Type/@type='any' and ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[2]/@optional='optional' 
		   and //Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name])">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "forEach" that does not match the expected signature.</assert>
	 <assert 
	     test="
		   not(parent::ExtendedAttributeList/parent::Interface)
		   or not(ancestor::Interface/*[@name='forEach'])
		   or not(//Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name])
		   or (
		   //Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/Type/@type='void' 
		   and count(//Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument)=3 
		   and (//Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument[1]/Type/@type=current()/TypeList/Type[2]/@type or //Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument[1]/Type/@name=current()/TypeList/Type[2]/@name)
		   and (//Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument[2]/Type/@type=current()/TypeList/Type[1]/@type or //Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument[2]/Type/@name=current()/TypeList/Type[1]/@name)
		   and //Callback[@name=current()/ancestor::Interface/Operation[@name='forEach']/ArgumentList/Argument[1]/Type/@name]/ArgumentList/Argument[3]/Type/@name=ancestor::Interface/@name
		   )">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "forEach" whose associated callback does not match the expected signature.</assert>
	 <!-- TODO: same tests for consequential interfaces (!) -->
	 <!-- An interface that is declared with the [MapClass] extended attribute MUST NOT have any interface member declared on it or any of its consequential interfaces with the identifier “size”, “entries”, “keys” or “values”.  -->
	 <assert 
	     test="not(parent::ExtendedAttributeList/parent::Interface)
		   or not(ancestor::Interface/*[@name='size'])">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "size" that is not allowed.</assert>
	 <assert 
	     test="not(parent::ExtendedAttributeList/parent::Interface)
		   or not(ancestor::Interface/*[@name='entries'])">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "entries" that is not allowed.</assert>
	 <assert 
	     test="not(parent::ExtendedAttributeList/parent::Interface)
		   or not(ancestor::Interface/*[@name='keys'])">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "keys" that is not allowed.</assert>
	 <assert 
	     test="not(parent::ExtendedAttributeList/parent::Interface)
		   or not(ancestor::Interface/*[@name='values'])">The interface <value-of select="ancestor::Interface/@name"/>, declared with a MapClass extended attribute, defines an interface member "values" that is not allowed.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute EnsureUTF16</title>
       <rule context="//ExtendedAttribute[@name='EnsureUTF16']">
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument">Extended attribute EnsureUTF16 used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> — EnsureUTF16 can only be used on attributes or operation arguments.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument) or parent::ExtendedAttributeList/parent::*/Type/@type = 'DOMString'">Extended attribute EnsureUTF16 used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> of type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type,parent::ExtendedAttributeList/parent::*/Type/@name)"/> — EnsureUTF16 can only be used on attributes or operation arguments of type DOMString.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute) or not(parent::ExtendedAttributeList/parent::Attribute/@readonly)">Extended attribute EnsureUTF16 used on readonly attribute <value-of select="parent::ExtendedAttributeList/parent::Attribute/@name"/> — EnsureUTF16 can only be used on attributes that are writable.</assert>
       </rule>
     </pattern>

     <pattern>
       <title>Extended Attribute SameObject</title>
       <rule context="//ExtendedAttribute[@name='SameObject']" >
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#SameObject" rule="extendedAttributeAppliesToReadonlyAttribute"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#SameObject" test="not(parent::ExtendedAttributeList/parent::Attribute/Type) or parent::ExtendedAttributeList/parent::Attribute/Type/@name or parent::ExtendedAttributeList/parent::Attribute/Type/@type='Promise'">Extended attribute SameObject used on an attribute whose type (<value-of select='parent::ExtendedAttributeList/parent::Attribute/Type/@type'/>) is not an interface type or a promise.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute PutForwards</title>
       <rule context="//ExtendedAttribute[@name='PutForwards']" >
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
	 <assert test="@value">Extended attribute <value-of select="@name"/> used without required argument on <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" />.</assert>
	 <let name="linkedInterface" value="parent::ExtendedAttributeList/parent::Attribute/Type/@name"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="not(@value and $validObject) or //Interface[@name=$linkedInterface]/Attribute[@name=current()/@value] or $standards//Interface[@name=$linkedInterface]/Attribute[@name=current()/@value]">Extended attribute PutForwards used on attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> with argument <value-of select="@value"/> does not match a known attribute in <value-of select="$linkedInterface"/> interface.</assert>
	 <!--<assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="false">PutForwards on attribute <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/>.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> is creating a cycle</assert>-->
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute Replaceable</title>
       <rule context="//ExtendedAttribute[@name='Replaceable']" >
	 <extends rule="extendedAttributeNoArg"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatNullAs</title>
       <rule context="//ExtendedAttribute[@name='TreatNullAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString' and not(@nullable)]">Extended attribute TreatNullAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatNullAs expected only on attributes, operations or operations arguments with non-nullable DOMString type.</assert>
	 <assert test="not($validObject) or @value='EmptyString'">Extended attribute TreatNullAs used on <value-of select="$objectName" /> without required “EmptyString” argument.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatUndefinedAs</title>
       <rule context="//ExtendedAttribute[@name='TreatUndefinedAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatUndefinedAs expected only on attributes, operations or operations arguments with DOMString or DOMString? type.</assert>
	 <assert test="not($validObject) or (@value='EmptyString' or @value='Null')">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> without required “EmptyString” or “Null” argument.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']) or not(@value='Null') or  (@value='Null' and parent::ExtendedAttributeList/parent::*/Type[@nullable='nullable'])">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> with required “Null” argument, but not applied to a DOMString? object.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute Clamp</title>
       <rule context="//ExtendedAttribute[@name='Clamp']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::DictionaryMember"/>
	 <let name="objectName" value="concat(ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name, parent::ExtendedAttributeList/parent::DictionaryMember/@name))"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or dictionary members.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::Attribute) or (parent::ExtendedAttributeList/parent::Attribute[not(@readonly)])">Extended attribute Clamp used on non-writable attribute <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or (parent::ExtendedAttributeList/parent::*/Type[@type='byte' or @type='octet' or @type='short' or @type='unsigned short' or @type='long' or @type='unsigned long' or @type='long long' or @type='unsigned long long'])">Extended attribute Clamp used on non-integer <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>

       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute Unforgeable</title>
       <rule context="//ExtendedAttribute[@name='Unforgeable']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute"/>
	 <extends rule="extendedAttributeAppliesToAttribute"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::Attribute/@readonly">Extended attribute Unforgeable used on non-readonly attribute <value-of select="concat(parent::ExtendedAttributeList/parent::Attribute/parent::Interface/@name, '.', parent::ExtendedAttributeList/parent::Attribute/@name)"/></assert>
	 <!-- @@@ TODO: It also MUST NOT appear on an attribute on interface A if there exists another interface B that defines any interface member with the same identifier, and which either has A as an inherited interface or which is a consequential interface of A. -->
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute TreatNonCallableAsNull</title>
       <rule context="//ExtendedAttribute[@name='TreatNonCallableAsNull']">
	 <assert role="warning" test="false">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> ; specifications SHOULD NOT use [TreatNonCallableAsNull] unless required to specify the behavior of legacy APIs.</assert>
	 <assert test="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> can only be used on attributes or operation arguments</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument) or (parent::ExtendedAttributeList/parent::*/Type/@nullable='nullable' and (parent::ExtendedAttributeList/parent::*/Type/@name = 'Function' or //Interface[@name = current()/parent::ExtendedAttributeList/parent::*/Type/@name]/@callback='callback'))">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/ancestor::Interface/@name, '.', parent::ExtendedAttributeList/ancestor::*[local-name()='Attribute' or local-name()='Operation']/@name)"/> can only be used on an attribute or operation argument whose type is a nullable callback interface.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute ArrayClass</title>
       <rule context="//ExtendedAttribute[@name='ArrayClass']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNotWithInheritance"/>
       </rule>
     </pattern>

     <pattern>
       <title>Extended attribute EnforceRange</title>
       <rule context="//ExtendedAttribute[@name='EnforceRange']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::DictionaryMember"/>
	 <let name="objectName" value="concat(ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name, parent::ExtendedAttributeList/parent::DictionaryMember/@name))"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or dictionary members.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::Attribute) or (parent::ExtendedAttributeList/parent::Attribute[not(@readonly)])">Extended attribute EnforceRange used on non-writable attribute <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or (parent::ExtendedAttributeList/parent::*/Type[@type='byte' or @type='octet' or @type='short' or @type='unsigned short' or @type='long' or @type='unsigned long' or @type='long long' or @type='unsigned long long'])">Extended attribute EnforceRange used on non-integer <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Clamp'])">Extended attribute EnforceRange used in conjunction with Clamp on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute ImplicitThis</title>
       <rule context="//ExtendedAttribute[@name='ImplicitThis']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToInterface"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute LenientThis</title>
       <rule context="//ExtendedAttribute[@name='LenientThis']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToAttribute"/>
	 <assert role="warning" test="false">Extended attribute LenientThis used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> ; specifications SHOULD NOT use [LenientThis] unless required for compatibility reasons.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Constants</title>
       <rule context="//Const">
	 <assert role="warning" test="Type[@type='unsigned short']">Numeric constant used <value-of select="@name"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/>; the Web platform is moving away from using named integer codes in the style of an enumeration, in favor of the use of strings.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Warn against use of float instead of double</title>
       <rule context="//Type[@type='float']">
	 <assert role="warning" test="true"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> uses type "float"; unless there are specific reasons to use a 32 bit floating point type, specifications SHOULD use double rather than float.</assert>
       </rule>
     </pattern>
</schema>
