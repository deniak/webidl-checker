<Module>
<Definitions>
  <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};
interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};

interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};
interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller <ref>HTMLOptionElement</ref>? (DOMString name);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};
[OverrideBuiltins]
interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};
[NoInterfaceObject]
interface Transferable { };
<ref>ArrayBuffer</ref> implements <ref>Transferable</ref>;
<ref>MessagePort</ref> implements <ref>Transferable</ref>;
callback FileCallback = void (<ref>File</ref> file);
enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };

[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};
<ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;
interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;


           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute boolean spellcheck;
};
<ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;

interface HTMLUnknownElement : <ref>HTMLElement</ref> { };
interface HTMLHtmlElement : <ref>HTMLElement</ref> {};
interface HTMLHeadElement : <ref>HTMLElement</ref> {};
interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};
interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};
interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
           attribute DOMString rev;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};
<ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};
interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
};
<ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLBodyElement : <ref>HTMLElement</ref> {
};
<ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLHeadingElement : <ref>HTMLElement</ref> {};
interface HTMLParagraphElement : <ref>HTMLElement</ref> {};
interface HTMLHRElement : <ref>HTMLElement</ref> {};
interface HTMLPreElement : <ref>HTMLElement</ref> {};
interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};
interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};
interface HTMLUListElement : <ref>HTMLElement</ref> {};
interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};
interface HTMLDListElement : <ref>HTMLElement</ref> {};
interface HTMLDivElement : <ref>HTMLElement</ref> {};
interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
           attribute DOMString rev;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};
<ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;
interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};
interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};
interface HTMLSpanElement : <ref>HTMLElement</ref> {};
interface HTMLBRElement : <ref>HTMLElement</ref> {};
interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};
[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};
interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};
interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};
interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};
interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};
interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};
[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};
interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};
interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute DOMString kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};
enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };
interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  readonly attribute unrestricted double duration;
  <ref>Date</ref> getStartDate();
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};
interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};
interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};

interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};
enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };
[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};
interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);
  <ref>TextTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};
enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };
enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };
interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;

  readonly attribute DOMString id;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};
interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};
interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};
interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};
[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;
};

dictionary TrackEventInit : <ref>EventInit</ref> {
  (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;
};
interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};
interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};
<ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;
interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
};
interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};
interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};
interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};
interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};
interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};
interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
};
interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};
[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter (<ref>RadioNodeList</ref> or <ref>Element</ref>) (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};
interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};
interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute long minLength;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean _required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute <ref>Date</ref>? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean _required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  <ref>HTMLOptionElement</ref>? namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(); 
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};
interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};
[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};
interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute long maxLength;
           attribute long minLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean _required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};
interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};
enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot; 
};
interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean tooShort;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};
interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};
interface HTMLTemplateElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>DocumentFragment</ref> content;
};
typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;

interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};
[Global]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  readonly attribute boolean closed;
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();


};
<ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;
<ref>Window</ref> implements <ref>WindowEventHandlers</ref>;
interface BarProp {
           attribute boolean visible;
};
interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};
[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};
<ref>Location</ref> implements <ref>URLUtils</ref>;
[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};

dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};
[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};

dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};
[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};
interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};
interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};
[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};
[Constructor(DOMString type, optional <ref>ErrorEventInit</ref> eventInitDict)]
interface ErrorEvent : <ref>Event</ref> {
  readonly attribute DOMString message;
  readonly attribute DOMString filename;
  readonly attribute unsigned long lineno;
  readonly attribute unsigned long colno;
  readonly attribute any error;
};

dictionary ErrorEventInit : <ref>EventInit</ref> {
  DOMString message;
  DOMString filename;
  unsigned long lineno;
  unsigned long colno;
  any error;
};
[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);
typedef <ref>EventHandlerNonNull</ref>? EventHandler;
[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column, optional any error);
typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;
[TreatNonCallableAsNull]
callback OnBeforeUnloadEventHandlerNonNull = DOMString? (<ref>Event</ref> event);
typedef <ref>OnBeforeUnloadEventHandlerNonNull</ref>? OnBeforeUnloadEventHandler;
[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> ontoggle;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};

[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>OnBeforeUnloadEventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};
[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};
<ref>Window</ref> implements <ref>WindowBase64</ref>;
[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};
<ref>Window</ref> implements <ref>WindowTimers</ref>;
interface Navigator {
};
<ref>Navigator</ref> implements <ref>NavigatorID</ref>;
<ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;
<ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;
<ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;
<ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;
<ref>Navigator</ref> implements <ref>NavigatorPlugins</ref>;
[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appCodeName; 
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString product; 
  boolean taintEnabled(); 
  readonly attribute DOMString userAgent;
};
[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};
[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};
[NoInterfaceObject]
interface NavigatorStorageUtils {
  readonly attribute boolean cookieEnabled;
  void yieldForStorageUpdates();
};
[NoInterfaceObject]
interface NavigatorPlugins {
  readonly attribute <ref>PluginArray</ref> plugins;
  readonly attribute <ref>MimeTypeArray</ref> mimeTypes;
  readonly attribute boolean javaEnabled;
};

interface PluginArray {
  void refresh(optional boolean reload = false);
  readonly attribute unsigned long length;
  getter <ref>Plugin</ref>? item(unsigned long index);
  getter <ref>Plugin</ref>? namedItem(DOMString name);
};

interface MimeTypeArray {
  readonly attribute unsigned long length;
  getter <ref>MimeType</ref>? item(unsigned long index);
  getter <ref>MimeType</ref>? namedItem(DOMString name);
};

interface Plugin {
  readonly attribute DOMString name;
  readonly attribute DOMString description;
  readonly attribute DOMString filename;
  readonly attribute unsigned long length;
  getter <ref>MimeType</ref>? item(unsigned long index);
  getter <ref>MimeType</ref>? namedItem(DOMString name);
};

interface MimeType {
  readonly attribute DOMString type;
  readonly attribute DOMString description;
  readonly attribute DOMString suffixes; 
  readonly attribute <ref>Plugin</ref> enabledPlugin;
};
interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};
interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};
interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};
interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};
<ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString shape;
};
partial interface HTMLAreaElement {
           attribute boolean noHref;
};
partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};
partial interface HTMLBRElement {
           attribute DOMString clear;
};
partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};
partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};
interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};
partial interface HTMLDivElement {
           attribute DOMString align;
};
partial interface HTMLDListElement {
           attribute boolean compact;
};
partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};
interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};
partial interface HTMLHeadingElement {
           attribute DOMString align;
};
partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};
partial interface HTMLHtmlElement {
           attribute DOMString version;
};
partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString lowsrc;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};
partial interface HTMLLegendElement {
           attribute DOMString align;
};
partial interface HTMLLIElement {
           attribute DOMString type;
};
partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString target;
};
partial interface HTMLMetaElement {
           attribute DOMString scheme;
};
partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLOListElement {
           attribute boolean compact;
};
partial interface HTMLParagraphElement {
           attribute DOMString align;
};
partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};
partial interface HTMLPreElement {
           attribute long width;
};
partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};
partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};
partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};
partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};
partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};
partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();
  void captureEvents(long dummy);
  void releaseEvents(long dummy);

  readonly attribute <ref>HTMLAllCollection</ref> all;
};
partial interface Window {
  void captureEvents(long dummy);
  void releaseEvents(long dummy);
};</webidl>
  <Interface name="HTMLAllCollection" id="::HTMLAllCollection">
    <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation name="item" id="::HTMLAllCollection::item">
      <webidl>  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLAllCollection::namedItem">
      <webidl>  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="tags" id="::HTMLAllCollection::tags">
      <webidl>  <ref>HTMLAllCollection</ref> tags(DOMString tagName);</webidl>
      <Type name="HTMLAllCollection"/>
      <ArgumentList>
        <Argument name="tagName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLFormControlsCollection" id="::HTMLFormControlsCollection">
    <webidl>interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLFormControlsCollection::namedItem">
      <webidl>  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="RadioNodeList"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="RadioNodeList" id="::RadioNodeList">
    <webidl>interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="NodeList"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::RadioNodeList::value">
      <webidl>          attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionsCollection" id="::HTMLOptionsCollection">
    <webidl>interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller <ref>HTMLOptionElement</ref>? (DOMString name);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Attribute name="length" id="::HTMLOptionsCollection::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller <ref>HTMLOptionElement</ref>? (DOMString name);</webidl>
      <Type name="HTMLOptionElement" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLOptionsCollection::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLOptionsCollection::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="selectedIndex" id="::HTMLOptionsCollection::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="DOMStringMap" id="::DOMStringMap">
    <webidl>[OverrideBuiltins]
interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation getter="getter">
      <webidl>  getter DOMString (DOMString name);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (DOMString name, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation deleter="deleter">
      <webidl>  deleter void (DOMString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Transferable" id="::Transferable">
    <webidl>[NoInterfaceObject]
interface Transferable { };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
  </Interface>
  <Implements name1="ArrayBuffer" name2="Transferable">
    <webidl><ref>ArrayBuffer</ref> implements <ref>Transferable</ref>;</webidl>
  </Implements>
  <Implements name1="MessagePort" name2="Transferable">
    <webidl><ref>MessagePort</ref> implements <ref>Transferable</ref>;</webidl>
  </Implements>
  <Callback name="FileCallback" id="::FileCallback">
    <webidl>callback FileCallback = void (<ref>File</ref> file);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="file">
        <Type name="File"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Enum name="DocumentReadyState" id="::DocumentReadyState">
    <webidl>enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };</webidl>
    <EnumValue stringvalue="loading">
      <webidl> &quot;loading</webidl>
    </EnumValue>
    <EnumValue stringvalue="interactive">
      <webidl> &quot;interactive</webidl>
    </EnumValue>
    <EnumValue stringvalue="complete">
      <webidl> &quot;complete</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="location" readonly="readonly" id="::Document::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location" nullable="nullable"/>
    </Attribute>
    <Attribute name="domain" id="::Document::domain">
      <webidl>           attribute DOMString domain;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="referrer" readonly="readonly" id="::Document::referrer">
      <webidl>  readonly attribute DOMString referrer;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cookie" id="::Document::cookie">
      <webidl>           attribute DOMString cookie;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lastModified" readonly="readonly" id="::Document::lastModified">
      <webidl>  readonly attribute DOMString lastModified;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readyState" readonly="readonly" id="::Document::readyState">
      <webidl>  readonly attribute <ref>DocumentReadyState</ref> readyState;</webidl>
      <Type name="DocumentReadyState"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="title" id="::Document::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dir" id="::Document::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="body" id="::Document::body">
      <webidl>           attribute <ref>HTMLElement</ref>? body;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="head" readonly="readonly" id="::Document::head">
      <webidl>  readonly attribute <ref>HTMLHeadElement</ref>? head;</webidl>
      <Type name="HTMLHeadElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="images" readonly="readonly" id="::Document::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="embeds" readonly="readonly" id="::Document::embeds">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> embeds;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="plugins" readonly="readonly" id="::Document::plugins">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> plugins;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="links" readonly="readonly" id="::Document::links">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> links;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="forms" readonly="readonly" id="::Document::forms">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> forms;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="scripts" readonly="readonly" id="::Document::scripts">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> scripts;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="getElementsByName" id="::Document::getElementsByName">
      <webidl>  <ref>NodeList</ref> getElementsByName(DOMString elementName);</webidl>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument name="elementName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</webidl>
      <Type name="Document"/>
      <ArgumentList>
        <Argument optional="optional" name="type" stringvalue="text/html">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="features">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::Document::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="write" id="::Document::write">
      <webidl>  void write(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="writeln" id="::Document::writeln">
      <webidl>  void writeln(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="defaultView" readonly="readonly" id="::Document::defaultView">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? defaultView;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="activeElement" readonly="readonly" id="::Document::activeElement">
      <webidl>  readonly attribute <ref>Element</ref>? activeElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="hasFocus" id="::Document::hasFocus">
      <webidl>  boolean hasFocus();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="designMode" id="::Document::designMode">
      <webidl>           attribute DOMString designMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="execCommand" id="::Document::execCommand">
      <webidl>  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="showUI" value="false">
          <Type type="boolean"/>
        </Argument>
        <Argument optional="optional" name="value" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandEnabled" id="::Document::queryCommandEnabled">
      <webidl>  boolean queryCommandEnabled(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandIndeterm" id="::Document::queryCommandIndeterm">
      <webidl>  boolean queryCommandIndeterm(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandState" id="::Document::queryCommandState">
      <webidl>  boolean queryCommandState(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandSupported" id="::Document::queryCommandSupported">
      <webidl>  boolean queryCommandSupported(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandValue" id="::Document::queryCommandValue">
      <webidl>  DOMString queryCommandValue(DOMString commandId);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onreadystatechange" id="::Document::onreadystatechange">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Implements name1="Document" name2="GlobalEventHandlers">
    <webidl><ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLElement" id="::HTMLElement">
    <webidl>interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;


           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute boolean spellcheck;
};</webidl>
    <InterfaceInheritance>
      <Name name="Element"/>
    </InterfaceInheritance>
    <Attribute name="title" id="::HTMLElement::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lang" id="::HTMLElement::lang">
      <webidl>           attribute DOMString lang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="translate" id="::HTMLElement::translate">
      <webidl>           attribute boolean translate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dir" id="::HTMLElement::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dataset" readonly="readonly" id="::HTMLElement::dataset">
      <webidl>  readonly attribute <ref>DOMStringMap</ref> dataset;</webidl>
      <Type name="DOMStringMap"/>
    </Attribute>
    <Attribute name="hidden" id="::HTMLElement::hidden">
      <webidl>           attribute boolean hidden;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="click" id="::HTMLElement::click">
      <webidl>  void click();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tabIndex" id="::HTMLElement::tabIndex">
      <webidl>           attribute long tabIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation name="focus" id="::HTMLElement::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::HTMLElement::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="accessKey" id="::HTMLElement::accessKey">
      <webidl>           attribute DOMString accessKey;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="accessKeyLabel" readonly="readonly" id="::HTMLElement::accessKeyLabel">
      <webidl>  readonly attribute DOMString accessKeyLabel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="contentEditable" id="::HTMLElement::contentEditable">
      <webidl>           attribute DOMString contentEditable;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="isContentEditable" readonly="readonly" id="::HTMLElement::isContentEditable">
      <webidl>  readonly attribute boolean isContentEditable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="spellcheck" id="::HTMLElement::spellcheck">
      <webidl>           attribute boolean spellcheck;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLElement" name2="GlobalEventHandlers">
    <webidl><ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLUnknownElement" id="::HTMLUnknownElement">
    <webidl>interface HTMLUnknownElement : <ref>HTMLElement</ref> { };</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHtmlElement" id="::HTMLHtmlElement">
    <webidl>interface HTMLHtmlElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHeadElement" id="::HTMLHeadElement">
    <webidl>interface HTMLHeadElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTitleElement" id="::HTMLTitleElement">
    <webidl>interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="text" id="::HTMLTitleElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBaseElement" id="::HTMLBaseElement">
    <webidl>interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="href" id="::HTMLBaseElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLBaseElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" id="::HTMLLinkElement">
    <webidl>interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
           attribute DOMString rev;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLLinkElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="href" id="::HTMLLinkElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLLinkElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLLinkElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLLinkElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="relList" readonly="readonly" id="::HTMLLinkElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="media" id="::HTMLLinkElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLLinkElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLLinkElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sizes" readonly="readonly" id="::HTMLLinkElement::sizes">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLLinkElement" name2="LinkStyle">
    <webidl><ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLMetaElement" id="::HTMLMetaElement">
    <webidl>interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMetaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="httpEquiv" id="::HTMLMetaElement::httpEquiv">
      <webidl>           attribute DOMString httpEquiv;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="content" id="::HTMLMetaElement::content">
      <webidl>           attribute DOMString content;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLStyleElement" id="::HTMLStyleElement">
    <webidl>interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLStyleElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="media" id="::HTMLStyleElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLStyleElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLStyleElement" name2="LinkStyle">
    <webidl><ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLBodyElement" id="::HTMLBodyElement">
    <webidl>interface HTMLBodyElement : <ref>HTMLElement</ref> {
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Implements name1="HTMLBodyElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLHeadingElement" id="::HTMLHeadingElement">
    <webidl>interface HTMLHeadingElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLParagraphElement" id="::HTMLParagraphElement">
    <webidl>interface HTMLParagraphElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHRElement" id="::HTMLHRElement">
    <webidl>interface HTMLHRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLPreElement" id="::HTMLPreElement">
    <webidl>interface HTMLPreElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLQuoteElement" id="::HTMLQuoteElement">
    <webidl>interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLQuoteElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" id="::HTMLOListElement">
    <webidl>interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="reversed" id="::HTMLOListElement::reversed">
      <webidl>           attribute boolean reversed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="start" id="::HTMLOListElement::start">
      <webidl>           attribute long start;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="type" id="::HTMLOListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" id="::HTMLUListElement">
    <webidl>interface HTMLUListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLLIElement" id="::HTMLLIElement">
    <webidl>interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLLIElement::value">
      <webidl>           attribute long value;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" id="::HTMLDListElement">
    <webidl>interface HTMLDListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLDivElement" id="::HTMLDivElement">
    <webidl>interface HTMLDivElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLAnchorElement" id="::HTMLAnchorElement">
    <webidl>interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
           attribute DOMString rev;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="target" id="::HTMLAnchorElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAnchorElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAnchorElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLAnchorElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="relList" readonly="readonly" id="::HTMLAnchorElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAnchorElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAnchorElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLAnchorElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAnchorElement" name2="URLUtils">
    <webidl><ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLDataElement" id="::HTMLDataElement">
    <webidl>interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLDataElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTimeElement" id="::HTMLTimeElement">
    <webidl>interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="dateTime" id="::HTMLTimeElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSpanElement" id="::HTMLSpanElement">
    <webidl>interface HTMLSpanElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLBRElement" id="::HTMLBRElement">
    <webidl>interface HTMLBRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLModElement" id="::HTMLModElement">
    <webidl>interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLModElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dateTime" id="::HTMLModElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" id="::HTMLImageElement">
    <webidl>[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Image">
        <webidl>NamedConstructor=Image(optional unsigned long width, optional unsigned long height)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="width">
            <Type type="unsigned long"/>
          </Argument>
          <Argument optional="optional" name="height">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLImageElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLImageElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLImageElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLImageElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="isMap" id="::HTMLImageElement::isMap">
      <webidl>           attribute boolean isMap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="width" id="::HTMLImageElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLImageElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="naturalWidth" readonly="readonly" id="::HTMLImageElement::naturalWidth">
      <webidl>  readonly attribute unsigned long naturalWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="naturalHeight" readonly="readonly" id="::HTMLImageElement::naturalHeight">
      <webidl>  readonly attribute unsigned long naturalHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="complete" readonly="readonly" id="::HTMLImageElement::complete">
      <webidl>  readonly attribute boolean complete;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" id="::HTMLIFrameElement">
    <webidl>interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLIFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srcdoc" id="::HTMLIFrameElement::srcdoc">
      <webidl>           attribute DOMString srcdoc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLIFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sandbox" readonly="readonly" id="::HTMLIFrameElement::sandbox">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="width" id="::HTMLIFrameElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLIFrameElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="contentDocument" readonly="readonly" id="::HTMLIFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute name="contentWindow" readonly="readonly" id="::HTMLIFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" id="::HTMLEmbedElement">
    <webidl>interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLEmbedElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLEmbedElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLEmbedElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLEmbedElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLObjectElement" id="::HTMLObjectElement">
    <webidl>interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="data" id="::HTMLObjectElement::data">
      <webidl>           attribute DOMString data;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLObjectElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="typeMustMatch" id="::HTMLObjectElement::typeMustMatch">
      <webidl>           attribute boolean typeMustMatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLObjectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLObjectElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLObjectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="width" id="::HTMLObjectElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLObjectElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="contentDocument" readonly="readonly" id="::HTMLObjectElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute name="contentWindow" readonly="readonly" id="::HTMLObjectElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLObjectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLObjectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLObjectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLObjectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLObjectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLParamElement" id="::HTMLParamElement">
    <webidl>interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLParamElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLParamElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLVideoElement" id="::HTMLVideoElement">
    <webidl>interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLVideoElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLVideoElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="videoWidth" readonly="readonly" id="::HTMLVideoElement::videoWidth">
      <webidl>  readonly attribute unsigned long videoWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="videoHeight" readonly="readonly" id="::HTMLVideoElement::videoHeight">
      <webidl>  readonly attribute unsigned long videoHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="poster" id="::HTMLVideoElement::poster">
      <webidl>           attribute DOMString poster;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAudioElement" id="::HTMLAudioElement">
    <webidl>[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Audio">
        <webidl>NamedConstructor=Audio(optional DOMString src)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="src">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLSourceElement" id="::HTMLSourceElement">
    <webidl>interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLSourceElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLSourceElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="media" id="::HTMLSourceElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTrackElement" id="::HTMLTrackElement">
    <webidl>interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute DOMString kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="kind" id="::HTMLTrackElement::kind">
      <webidl>           attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLTrackElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srclang" id="::HTMLTrackElement::srclang">
      <webidl>           attribute DOMString srclang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLTrackElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="default" id="::HTMLTrackElement::default">
      <webidl>           attribute boolean default;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Const name="NONE" value="0" id="::HTMLTrackElement::NONE">
      <webidl>  const unsigned short NONE = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADING" value="1" id="::HTMLTrackElement::LOADING">
      <webidl>  const unsigned short LOADING = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADED" value="2" id="::HTMLTrackElement::LOADED">
      <webidl>  const unsigned short LOADED = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ERROR" value="3" id="::HTMLTrackElement::ERROR">
      <webidl>  const unsigned short ERROR = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="readyState" readonly="readonly" id="::HTMLTrackElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="track" readonly="readonly" id="::HTMLTrackElement::track">
      <webidl>  readonly attribute <ref>TextTrack</ref> track;</webidl>
      <Type name="TextTrack"/>
    </Attribute>
  </Interface>
  <Enum name="CanPlayTypeEnum" id="::CanPlayTypeEnum">
    <webidl>enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };</webidl>
    <EnumValue stringvalue="">
      <webidl> &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="maybe">
      <webidl> &quot;maybe</webidl>
    </EnumValue>
    <EnumValue stringvalue="probably">
      <webidl> &quot;probably</webidl>
    </EnumValue>
  </Enum>
  <Interface name="HTMLMediaElement" id="::HTMLMediaElement">
    <webidl>interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  readonly attribute unrestricted double duration;
  <ref>Date</ref> getStartDate();
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="error" readonly="readonly" id="::HTMLMediaElement::error">
      <webidl>  readonly attribute <ref>MediaError</ref>? error;</webidl>
      <Type name="MediaError" nullable="nullable"/>
    </Attribute>
    <Attribute name="src" id="::HTMLMediaElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="currentSrc" readonly="readonly" id="::HTMLMediaElement::currentSrc">
      <webidl>  readonly attribute DOMString currentSrc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLMediaElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Const name="NETWORK_EMPTY" value="0" id="::HTMLMediaElement::NETWORK_EMPTY">
      <webidl>  const unsigned short NETWORK_EMPTY = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_IDLE" value="1" id="::HTMLMediaElement::NETWORK_IDLE">
      <webidl>  const unsigned short NETWORK_IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_LOADING" value="2" id="::HTMLMediaElement::NETWORK_LOADING">
      <webidl>  const unsigned short NETWORK_LOADING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_NO_SOURCE" value="3" id="::HTMLMediaElement::NETWORK_NO_SOURCE">
      <webidl>  const unsigned short NETWORK_NO_SOURCE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="networkState" readonly="readonly" id="::HTMLMediaElement::networkState">
      <webidl>  readonly attribute unsigned short networkState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="preload" id="::HTMLMediaElement::preload">
      <webidl>           attribute DOMString preload;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="buffered" readonly="readonly" id="::HTMLMediaElement::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="load" id="::HTMLMediaElement::load">
      <webidl>  void load();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="canPlayType" id="::HTMLMediaElement::canPlayType">
      <webidl>  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);</webidl>
      <Type name="CanPlayTypeEnum"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="HAVE_NOTHING" value="0" id="::HTMLMediaElement::HAVE_NOTHING">
      <webidl>  const unsigned short HAVE_NOTHING = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_METADATA" value="1" id="::HTMLMediaElement::HAVE_METADATA">
      <webidl>  const unsigned short HAVE_METADATA = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_CURRENT_DATA" value="2" id="::HTMLMediaElement::HAVE_CURRENT_DATA">
      <webidl>  const unsigned short HAVE_CURRENT_DATA = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_FUTURE_DATA" value="3" id="::HTMLMediaElement::HAVE_FUTURE_DATA">
      <webidl>  const unsigned short HAVE_FUTURE_DATA = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_ENOUGH_DATA" value="4" id="::HTMLMediaElement::HAVE_ENOUGH_DATA">
      <webidl>  const unsigned short HAVE_ENOUGH_DATA = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="readyState" readonly="readonly" id="::HTMLMediaElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="seeking" readonly="readonly" id="::HTMLMediaElement::seeking">
      <webidl>  readonly attribute boolean seeking;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="currentTime" id="::HTMLMediaElement::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="duration" readonly="readonly" id="::HTMLMediaElement::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Operation name="getStartDate" id="::HTMLMediaElement::getStartDate">
      <webidl>  <ref>Date</ref> getStartDate();</webidl>
      <Type name="Date"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="paused" readonly="readonly" id="::HTMLMediaElement::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultPlaybackRate" id="::HTMLMediaElement::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::HTMLMediaElement::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="played" readonly="readonly" id="::HTMLMediaElement::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute name="seekable" readonly="readonly" id="::HTMLMediaElement::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute name="ended" readonly="readonly" id="::HTMLMediaElement::ended">
      <webidl>  readonly attribute boolean ended;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="autoplay" id="::HTMLMediaElement::autoplay">
      <webidl>           attribute boolean autoplay;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMediaElement::loop">
      <webidl>           attribute boolean loop;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="play" id="::HTMLMediaElement::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pause" id="::HTMLMediaElement::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="mediaGroup" id="::HTMLMediaElement::mediaGroup">
      <webidl>           attribute DOMString mediaGroup;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="controller" id="::HTMLMediaElement::controller">
      <webidl>           attribute <ref>MediaController</ref>? controller;</webidl>
      <Type name="MediaController" nullable="nullable"/>
    </Attribute>
    <Attribute name="controls" id="::HTMLMediaElement::controls">
      <webidl>           attribute boolean controls;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="volume" id="::HTMLMediaElement::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::HTMLMediaElement::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultMuted" id="::HTMLMediaElement::defaultMuted">
      <webidl>           attribute boolean defaultMuted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="audioTracks" readonly="readonly" id="::HTMLMediaElement::audioTracks">
      <webidl>  readonly attribute <ref>AudioTrackList</ref> audioTracks;</webidl>
      <Type name="AudioTrackList"/>
    </Attribute>
    <Attribute name="videoTracks" readonly="readonly" id="::HTMLMediaElement::videoTracks">
      <webidl>  readonly attribute <ref>VideoTrackList</ref> videoTracks;</webidl>
      <Type name="VideoTrackList"/>
    </Attribute>
    <Attribute name="textTracks" readonly="readonly" id="::HTMLMediaElement::textTracks">
      <webidl>  readonly attribute <ref>TextTrackList</ref> textTracks;</webidl>
      <Type name="TextTrackList"/>
    </Attribute>
    <Operation name="addTextTrack" id="::HTMLMediaElement::addTextTrack">
      <webidl>  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="kind">
          <Type name="TextTrackKind"/>
        </Argument>
        <Argument optional="optional" name="label" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="language" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MediaError" id="::MediaError">
    <webidl>interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};</webidl>
    <Const name="MEDIA_ERR_ABORTED" value="1" id="::MediaError::MEDIA_ERR_ABORTED">
      <webidl>  const unsigned short MEDIA_ERR_ABORTED = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_NETWORK" value="2" id="::MediaError::MEDIA_ERR_NETWORK">
      <webidl>  const unsigned short MEDIA_ERR_NETWORK = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_DECODE" value="3" id="::MediaError::MEDIA_ERR_DECODE">
      <webidl>  const unsigned short MEDIA_ERR_DECODE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_SRC_NOT_SUPPORTED" value="4" id="::MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED">
      <webidl>  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="code" readonly="readonly" id="::MediaError::code">
      <webidl>  readonly attribute unsigned short code;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrackList" id="::AudioTrackList">
    <webidl>interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="length" readonly="readonly" id="::AudioTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>AudioTrack</ref> (unsigned long index);</webidl>
      <Type name="AudioTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::AudioTrackList::getTrackById">
      <webidl>  <ref>AudioTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="AudioTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onchange" id="::AudioTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::AudioTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::AudioTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrack" id="::AudioTrack">
    <webidl>interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};</webidl>
    <Attribute name="id" readonly="readonly" id="::AudioTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="kind" readonly="readonly" id="::AudioTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" readonly="readonly" id="::AudioTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="language" readonly="readonly" id="::AudioTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enabled" id="::AudioTrack::enabled">
      <webidl>           attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrackList" id="::VideoTrackList">
    <webidl>interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="length" readonly="readonly" id="::VideoTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>VideoTrack</ref> (unsigned long index);</webidl>
      <Type name="VideoTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::VideoTrackList::getTrackById">
      <webidl>  <ref>VideoTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="VideoTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="selectedIndex" readonly="readonly" id="::VideoTrackList::selectedIndex">
      <webidl>  readonly attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="onchange" id="::VideoTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::VideoTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::VideoTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrack" id="::VideoTrack">
    <webidl>interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};</webidl>
    <Attribute name="id" readonly="readonly" id="::VideoTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="kind" readonly="readonly" id="::VideoTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" readonly="readonly" id="::VideoTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="language" readonly="readonly" id="::VideoTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="selected" id="::VideoTrack::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Enum name="MediaControllerPlaybackState" id="::MediaControllerPlaybackState">
    <webidl>enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };</webidl>
    <EnumValue stringvalue="waiting">
      <webidl> &quot;waiting</webidl>
    </EnumValue>
    <EnumValue stringvalue="playing">
      <webidl> &quot;playing</webidl>
    </EnumValue>
    <EnumValue stringvalue="ended">
      <webidl> &quot;ended</webidl>
    </EnumValue>
  </Enum>
  <Interface name="MediaController" id="::MediaController">
    <webidl>[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="readyState" readonly="readonly" id="::MediaController::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="buffered" readonly="readonly" id="::MediaController::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute name="seekable" readonly="readonly" id="::MediaController::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute name="duration" readonly="readonly" id="::MediaController::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="currentTime" id="::MediaController::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="paused" readonly="readonly" id="::MediaController::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="playbackState" readonly="readonly" id="::MediaController::playbackState">
      <webidl>  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;</webidl>
      <Type name="MediaControllerPlaybackState"/>
    </Attribute>
    <Attribute name="played" readonly="readonly" id="::MediaController::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="pause" id="::MediaController::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="unpause" id="::MediaController::unpause">
      <webidl>  void unpause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="play" id="::MediaController::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="defaultPlaybackRate" id="::MediaController::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::MediaController::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="volume" id="::MediaController::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::MediaController::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onemptied" id="::MediaController::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::MediaController::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::MediaController::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::MediaController::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::MediaController::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::MediaController::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::MediaController::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::MediaController::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::MediaController::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::MediaController::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::MediaController::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::MediaController::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::MediaController::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::MediaController::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackList" id="::TextTrackList">
    <webidl>interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);
  <ref>TextTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="length" readonly="readonly" id="::TextTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrack</ref> (unsigned long index);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::TextTrackList::getTrackById">
      <webidl>  <ref>TextTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="TextTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onchange" id="::TextTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::TextTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::TextTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Enum name="TextTrackMode" id="::TextTrackMode">
    <webidl>enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };</webidl>
    <EnumValue stringvalue="disabled">
      <webidl> &quot;disabled</webidl>
    </EnumValue>
    <EnumValue stringvalue="hidden">
      <webidl>  &quot;hidden</webidl>
    </EnumValue>
    <EnumValue stringvalue="showing">
      <webidl>  &quot;showing</webidl>
    </EnumValue>
  </Enum>
  <Enum name="TextTrackKind" id="::TextTrackKind">
    <webidl>enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };</webidl>
    <EnumValue stringvalue="subtitles">
      <webidl> &quot;subtitles</webidl>
    </EnumValue>
    <EnumValue stringvalue="captions">
      <webidl>  &quot;captions</webidl>
    </EnumValue>
    <EnumValue stringvalue="descriptions">
      <webidl>  &quot;descriptions</webidl>
    </EnumValue>
    <EnumValue stringvalue="chapters">
      <webidl>  &quot;chapters</webidl>
    </EnumValue>
    <EnumValue stringvalue="metadata">
      <webidl>  &quot;metadata</webidl>
    </EnumValue>
  </Enum>
  <Interface name="TextTrack" id="::TextTrack">
    <webidl>interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;

  readonly attribute DOMString id;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="kind" readonly="readonly" id="::TextTrack::kind">
      <webidl>  readonly attribute <ref>TextTrackKind</ref> kind;</webidl>
      <Type name="TextTrackKind"/>
    </Attribute>
    <Attribute name="label" readonly="readonly" id="::TextTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="language" readonly="readonly" id="::TextTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="id" readonly="readonly" id="::TextTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="inBandMetadataTrackDispatchType" readonly="readonly" id="::TextTrack::inBandMetadataTrackDispatchType">
      <webidl>  readonly attribute DOMString inBandMetadataTrackDispatchType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="mode" id="::TextTrack::mode">
      <webidl>           attribute <ref>TextTrackMode</ref> mode;</webidl>
      <Type name="TextTrackMode"/>
    </Attribute>
    <Attribute name="cues" readonly="readonly" id="::TextTrack::cues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? cues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Attribute name="activeCues" readonly="readonly" id="::TextTrack::activeCues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? activeCues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Operation name="addCue" id="::TextTrack::addCue">
      <webidl>  void addCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeCue" id="::TextTrack::removeCue">
      <webidl>  void removeCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="oncuechange" id="::TextTrack::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackCueList" id="::TextTrackCueList">
    <webidl>interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};</webidl>
    <Attribute name="length" readonly="readonly" id="::TextTrackCueList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrackCue</ref> (unsigned long index);</webidl>
      <Type name="TextTrackCue"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getCueById" id="::TextTrackCueList::getCueById">
      <webidl>  <ref>TextTrackCue</ref>? getCueById(DOMString id);</webidl>
      <Type name="TextTrackCue" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TextTrackCue" id="::TextTrackCue">
    <webidl>interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="track" readonly="readonly" id="::TextTrackCue::track">
      <webidl>  readonly attribute <ref>TextTrack</ref>? track;</webidl>
      <Type name="TextTrack" nullable="nullable"/>
    </Attribute>
    <Attribute name="id" id="::TextTrackCue::id">
      <webidl>           attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="startTime" id="::TextTrackCue::startTime">
      <webidl>           attribute double startTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="endTime" id="::TextTrackCue::endTime">
      <webidl>           attribute double endTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="pauseOnExit" id="::TextTrackCue::pauseOnExit">
      <webidl>           attribute boolean pauseOnExit;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onenter" id="::TextTrackCue::onenter">
      <webidl>           attribute <ref>EventHandler</ref> onenter;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onexit" id="::TextTrackCue::onexit">
      <webidl>           attribute <ref>EventHandler</ref> onexit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TimeRanges" id="::TimeRanges">
    <webidl>interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};</webidl>
    <Attribute name="length" readonly="readonly" id="::TimeRanges::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="start" id="::TimeRanges::start">
      <webidl>  double start(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="end" id="::TimeRanges::end">
      <webidl>  double end(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TrackEvent" id="::TrackEvent">
    <webidl>[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="TrackEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="track" readonly="readonly" id="::TrackEvent::track">
      <webidl>  readonly attribute (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;</webidl>
      <Type type="union">
        <Type name="VideoTrack"/>
        <Type name="AudioTrack"/>
        <Type name="TextTrack"/>
      </Type>
    </Attribute>
  </Interface>
  <Dictionary name="TrackEventInit" id="::TrackEventInit">
    <webidl>dictionary TrackEventInit : <ref>EventInit</ref> {
  (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="track" id="::TrackEventInit::track">
      <webidl>  (<ref>VideoTrack</ref> or <ref>AudioTrack</ref> or <ref>TextTrack</ref>) track;</webidl>
      <Type type="union">
        <Type name="VideoTrack"/>
        <Type name="AudioTrack"/>
        <Type name="TextTrack"/>
      </Type>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HTMLMapElement" id="::HTMLMapElement">
    <webidl>interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMapElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="areas" readonly="readonly" id="::HTMLMapElement::areas">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> areas;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="images" readonly="readonly" id="::HTMLMapElement::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" id="::HTMLAreaElement">
    <webidl>interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLAreaElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="coords" id="::HTMLAreaElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAreaElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLAreaElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAreaElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAreaElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="relList" readonly="readonly" id="::HTMLAreaElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAreaElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAreaElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAreaElement" name2="URLUtils">
    <webidl><ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLTableElement" id="::HTMLTableElement">
    <webidl>interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="caption" id="::HTMLTableElement::caption">
      <webidl>           attribute <ref>HTMLTableCaptionElement</ref>? caption;</webidl>
      <Type name="HTMLTableCaptionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createCaption" id="::HTMLTableElement::createCaption">
      <webidl>  <ref>HTMLElement</ref> createCaption();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteCaption" id="::HTMLTableElement::deleteCaption">
      <webidl>  void deleteCaption();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tHead" id="::HTMLTableElement::tHead">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tHead;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTHead" id="::HTMLTableElement::createTHead">
      <webidl>  <ref>HTMLElement</ref> createTHead();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTHead" id="::HTMLTableElement::deleteTHead">
      <webidl>  void deleteTHead();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tFoot" id="::HTMLTableElement::tFoot">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tFoot;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTFoot" id="::HTMLTableElement::createTFoot">
      <webidl>  <ref>HTMLElement</ref> createTFoot();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTFoot" id="::HTMLTableElement::deleteTFoot">
      <webidl>  void deleteTFoot();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tBodies" readonly="readonly" id="::HTMLTableElement::tBodies">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> tBodies;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="createTBody" id="::HTMLTableElement::createTBody">
      <webidl>  <ref>HTMLElement</ref> createTBody();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="rows" readonly="readonly" id="::HTMLTableElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="border" id="::HTMLTableElement::border">
      <webidl>           attribute DOMString border;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCaptionElement" id="::HTMLTableCaptionElement">
    <webidl>interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableColElement" id="::HTMLTableColElement">
    <webidl>interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="span" id="::HTMLTableColElement::span">
      <webidl>           attribute unsigned long span;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" id="::HTMLTableSectionElement">
    <webidl>interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="rows" readonly="readonly" id="::HTMLTableSectionElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableSectionElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableSectionElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableRowElement" id="::HTMLTableRowElement">
    <webidl>interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="rowIndex" readonly="readonly" id="::HTMLTableRowElement::rowIndex">
      <webidl>  readonly attribute long rowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="sectionRowIndex" readonly="readonly" id="::HTMLTableRowElement::sectionRowIndex">
      <webidl>  readonly attribute long sectionRowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="cells" readonly="readonly" id="::HTMLTableRowElement::cells">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> cells;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertCell" id="::HTMLTableRowElement::insertCell">
      <webidl>  <ref>HTMLElement</ref> insertCell(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteCell" id="::HTMLTableRowElement::deleteCell">
      <webidl>  void deleteCell(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableDataCellElement" id="::HTMLTableDataCellElement">
    <webidl>interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableHeaderCellElement" id="::HTMLTableHeaderCellElement">
    <webidl>interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
    <Attribute name="scope" id="::HTMLTableHeaderCellElement::scope">
      <webidl>           attribute DOMString scope;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="abbr" id="::HTMLTableHeaderCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCellElement" id="::HTMLTableCellElement">
    <webidl>interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="colSpan" id="::HTMLTableCellElement::colSpan">
      <webidl>           attribute unsigned long colSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="rowSpan" id="::HTMLTableCellElement::rowSpan">
      <webidl>           attribute unsigned long rowSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="headers" readonly="readonly" id="::HTMLTableCellElement::headers">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="cellIndex" readonly="readonly" id="::HTMLTableCellElement::cellIndex">
      <webidl>  readonly attribute long cellIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFormElement" id="::HTMLFormElement">
    <webidl>[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter (<ref>RadioNodeList</ref> or <ref>Element</ref>) (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="acceptCharset" id="::HTMLFormElement::acceptCharset">
      <webidl>           attribute DOMString acceptCharset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="action" id="::HTMLFormElement::action">
      <webidl>           attribute DOMString action;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLFormElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enctype" id="::HTMLFormElement::enctype">
      <webidl>           attribute DOMString enctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="encoding" id="::HTMLFormElement::encoding">
      <webidl>           attribute DOMString encoding;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="method" id="::HTMLFormElement::method">
      <webidl>           attribute DOMString method;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFormElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noValidate" id="::HTMLFormElement::noValidate">
      <webidl>           attribute boolean noValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="target" id="::HTMLFormElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="elements" readonly="readonly" id="::HTMLFormElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute name="length" readonly="readonly" id="::HTMLFormElement::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>Element</ref> (unsigned long index);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter (<ref>RadioNodeList</ref> or <ref>Element</ref>) (DOMString name);</webidl>
      <Type type="union">
        <Type name="RadioNodeList"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="submit" id="::HTMLFormElement::submit">
      <webidl>  void submit();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="reset" id="::HTMLFormElement::reset">
      <webidl>  void reset();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="checkValidity" id="::HTMLFormElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLLabelElement" id="::HTMLLabelElement">
    <webidl>interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="form" readonly="readonly" id="::HTMLLabelElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLLabelElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="control" readonly="readonly" id="::HTMLLabelElement::control">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? control;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" id="::HTMLInputElement">
    <webidl>interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute long minLength;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean _required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute <ref>Date</ref>? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="accept" id="::HTMLInputElement::accept">
      <webidl>           attribute DOMString accept;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLInputElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLInputElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLInputElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultChecked" id="::HTMLInputElement::defaultChecked">
      <webidl>           attribute boolean defaultChecked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="checked" id="::HTMLInputElement::checked">
      <webidl>           attribute boolean checked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLInputElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLInputElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLInputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="files" readonly="readonly" id="::HTMLInputElement::files">
      <webidl>  readonly attribute <ref>FileList</ref>? files;</webidl>
      <Type name="FileList" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLInputElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLInputElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLInputElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLInputElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLInputElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLInputElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="indeterminate" id="::HTMLInputElement::indeterminate">
      <webidl>           attribute boolean indeterminate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="list" readonly="readonly" id="::HTMLInputElement::list">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? list;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="max" id="::HTMLInputElement::max">
      <webidl>           attribute DOMString max;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLInputElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="min" id="::HTMLInputElement::min">
      <webidl>           attribute DOMString min;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="minLength" id="::HTMLInputElement::minLength">
      <webidl>           attribute long minLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLInputElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLInputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="pattern" id="::HTMLInputElement::pattern">
      <webidl>           attribute DOMString pattern;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLInputElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLInputElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLInputElement::required">
      <webidl>           attribute boolean _required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLInputElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="src" id="::HTMLInputElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="step" id="::HTMLInputElement::step">
      <webidl>           attribute DOMString step;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLInputElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLInputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLInputElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueAsDate" id="::HTMLInputElement::valueAsDate">
      <webidl>           attribute <ref>Date</ref>? valueAsDate;</webidl>
      <Type name="Date" nullable="nullable"/>
    </Attribute>
    <Attribute name="valueAsNumber" id="::HTMLInputElement::valueAsNumber">
      <webidl>           attribute unrestricted double valueAsNumber;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="width" id="::HTMLInputElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="stepUp" id="::HTMLInputElement::stepUp">
      <webidl>  void stepUp(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="stepDown" id="::HTMLInputElement::stepDown">
      <webidl>  void stepDown(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLInputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLInputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLInputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLInputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLInputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLInputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLInputElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLInputElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLInputElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLInputElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode" stringvalue="preserve">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLInputElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLButtonElement" id="::HTMLButtonElement">
    <webidl>interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLButtonElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLButtonElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLButtonElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLButtonElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLButtonElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLButtonElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLButtonElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLButtonElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLButtonElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLButtonElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLButtonElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLButtonElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLButtonElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLButtonElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLButtonElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLButtonElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLButtonElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSelectElement" id="::HTMLSelectElement">
    <webidl>interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean _required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  <ref>HTMLOptionElement</ref>? namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(); 
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLSelectElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLSelectElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLSelectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLSelectElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLSelectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="required" id="::HTMLSelectElement::required">
      <webidl>           attribute boolean _required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLSelectElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::HTMLSelectElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="options" readonly="readonly" id="::HTMLSelectElement::options">
      <webidl>  readonly attribute <ref>HTMLOptionsCollection</ref> options;</webidl>
      <Type name="HTMLOptionsCollection"/>
    </Attribute>
    <Attribute name="length" id="::HTMLSelectElement::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::HTMLSelectElement::item">
      <webidl>  getter <ref>Element</ref>? item(unsigned long index);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="namedItem" id="::HTMLSelectElement::namedItem">
      <webidl>  <ref>HTMLOptionElement</ref>? namedItem(DOMString name);</webidl>
      <Type name="HTMLOptionElement" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLSelectElement::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLSelectElement::remove">
      <webidl>  void remove();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="remove" id="::HTMLSelectElement::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="selectedOptions" readonly="readonly" id="::HTMLSelectElement::selectedOptions">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> selectedOptions;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="selectedIndex" id="::HTMLSelectElement::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="value" id="::HTMLSelectElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLSelectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLSelectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLSelectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLSelectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLSelectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLSelectElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDataListElement" id="::HTMLDataListElement">
    <webidl>interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="options" readonly="readonly" id="::HTMLDataListElement::options">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> options;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptGroupElement" id="::HTMLOptGroupElement">
    <webidl>interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptGroupElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptGroupElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionElement" id="::HTMLOptionElement">
    <webidl>[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Option">
        <webidl>NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="text" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="value">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="defaultSelected" value="false">
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="selected" value="false">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptionElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLOptionElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptionElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultSelected" id="::HTMLOptionElement::defaultSelected">
      <webidl>           attribute boolean defaultSelected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="selected" id="::HTMLOptionElement::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOptionElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLOptionElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="index" readonly="readonly" id="::HTMLOptionElement::index">
      <webidl>  readonly attribute long index;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTextAreaElement" id="::HTMLTextAreaElement">
    <webidl>interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute long maxLength;
           attribute long minLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean _required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autocomplete" id="::HTMLTextAreaElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLTextAreaElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="cols" id="::HTMLTextAreaElement::cols">
      <webidl>           attribute unsigned long cols;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLTextAreaElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLTextAreaElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLTextAreaElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLTextAreaElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="minLength" id="::HTMLTextAreaElement::minLength">
      <webidl>           attribute long minLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLTextAreaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLTextAreaElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLTextAreaElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLTextAreaElement::required">
      <webidl>           attribute boolean _required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLTextAreaElement::rows">
      <webidl>           attribute unsigned long rows;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="wrap" id="::HTMLTextAreaElement::wrap">
      <webidl>           attribute DOMString wrap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::HTMLTextAreaElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLTextAreaElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLTextAreaElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="textLength" readonly="readonly" id="::HTMLTextAreaElement::textLength">
      <webidl>  readonly attribute unsigned long textLength;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLTextAreaElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLTextAreaElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLTextAreaElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLTextAreaElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLTextAreaElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLTextAreaElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLTextAreaElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLTextAreaElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLTextAreaElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLTextAreaElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode = &quot;preserve&quot;);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode" stringvalue="preserve">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLTextAreaElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLKeygenElement" id="::HTMLKeygenElement">
    <webidl>interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLKeygenElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="challenge" id="::HTMLKeygenElement::challenge">
      <webidl>           attribute DOMString challenge;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLKeygenElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLKeygenElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="keytype" id="::HTMLKeygenElement::keytype">
      <webidl>           attribute DOMString keytype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLKeygenElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::HTMLKeygenElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLKeygenElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLKeygenElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLKeygenElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLKeygenElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLKeygenElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLKeygenElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOutputElement" id="::HTMLOutputElement">
    <webidl>interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="htmlFor" readonly="readonly" id="::HTMLOutputElement::htmlFor">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLOutputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLOutputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::HTMLOutputElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLOutputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOutputElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLOutputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLOutputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLOutputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLOutputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLOutputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="labels" readonly="readonly" id="::HTMLOutputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLProgressElement" id="::HTMLProgressElement">
    <webidl>interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLProgressElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLProgressElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="position" readonly="readonly" id="::HTMLProgressElement::position">
      <webidl>  readonly attribute double position;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="labels" readonly="readonly" id="::HTMLProgressElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMeterElement" id="::HTMLMeterElement">
    <webidl>interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLMeterElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="min" id="::HTMLMeterElement::min">
      <webidl>           attribute double min;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLMeterElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="low" id="::HTMLMeterElement::low">
      <webidl>           attribute double low;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="high" id="::HTMLMeterElement::high">
      <webidl>           attribute double high;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="optimum" id="::HTMLMeterElement::optimum">
      <webidl>           attribute double optimum;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="labels" readonly="readonly" id="::HTMLMeterElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFieldSetElement" id="::HTMLFieldSetElement">
    <webidl>interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLFieldSetElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="form" readonly="readonly" id="::HTMLFieldSetElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFieldSetElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::HTMLFieldSetElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="elements" readonly="readonly" id="::HTMLFieldSetElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute name="willValidate" readonly="readonly" id="::HTMLFieldSetElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="validity" readonly="readonly" id="::HTMLFieldSetElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute name="validationMessage" readonly="readonly" id="::HTMLFieldSetElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLFieldSetElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLFieldSetElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLLegendElement" id="::HTMLLegendElement">
    <webidl>interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="form" readonly="readonly" id="::HTMLLegendElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="SelectionMode" id="::SelectionMode">
    <webidl>enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot; 
};</webidl>
    <EnumValue stringvalue="select">
      <webidl>  &quot;select</webidl>
    </EnumValue>
    <EnumValue stringvalue="start">
      <webidl>  &quot;start</webidl>
    </EnumValue>
    <EnumValue stringvalue="end">
      <webidl>  &quot;end</webidl>
    </EnumValue>
    <EnumValue stringvalue="preserve">
      <webidl>  &quot;preserve</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ValidityState" id="::ValidityState">
    <webidl>interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean tooShort;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};</webidl>
    <Attribute name="valueMissing" readonly="readonly" id="::ValidityState::valueMissing">
      <webidl>  readonly attribute boolean valueMissing;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="typeMismatch" readonly="readonly" id="::ValidityState::typeMismatch">
      <webidl>  readonly attribute boolean typeMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="patternMismatch" readonly="readonly" id="::ValidityState::patternMismatch">
      <webidl>  readonly attribute boolean patternMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="tooLong" readonly="readonly" id="::ValidityState::tooLong">
      <webidl>  readonly attribute boolean tooLong;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="tooShort" readonly="readonly" id="::ValidityState::tooShort">
      <webidl>  readonly attribute boolean tooShort;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rangeUnderflow" readonly="readonly" id="::ValidityState::rangeUnderflow">
      <webidl>  readonly attribute boolean rangeUnderflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rangeOverflow" readonly="readonly" id="::ValidityState::rangeOverflow">
      <webidl>  readonly attribute boolean rangeOverflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="stepMismatch" readonly="readonly" id="::ValidityState::stepMismatch">
      <webidl>  readonly attribute boolean stepMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="badInput" readonly="readonly" id="::ValidityState::badInput">
      <webidl>  readonly attribute boolean badInput;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="customError" readonly="readonly" id="::ValidityState::customError">
      <webidl>  readonly attribute boolean customError;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="valid" readonly="readonly" id="::ValidityState::valid">
      <webidl>  readonly attribute boolean valid;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLScriptElement" id="::HTMLScriptElement">
    <webidl>interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLScriptElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLScriptElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLScriptElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="async" id="::HTMLScriptElement::async">
      <webidl>           attribute boolean async;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defer" id="::HTMLScriptElement::defer">
      <webidl>           attribute boolean defer;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLScriptElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLScriptElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTemplateElement" id="::HTMLTemplateElement">
    <webidl>interface HTMLTemplateElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>DocumentFragment</ref> content;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="content" readonly="readonly" id="::HTMLTemplateElement::content">
      <webidl>  readonly attribute <ref>DocumentFragment</ref> content;</webidl>
      <Type name="DocumentFragment"/>
    </Attribute>
  </Interface>
  <Typedef name="RenderingContext" id="::RenderingContext">
    <webidl>typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;</webidl>
    <Type type="union">
      <Type name="CanvasRenderingContext2D"/>
      <Type name="WebGLRenderingContext"/>
    </Type>
  </Typedef>
  <Interface name="HTMLCanvasElement" id="::HTMLCanvasElement">
    <webidl>interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLCanvasElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLCanvasElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="getContext" id="::HTMLCanvasElement::getContext">
      <webidl>  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);</webidl>
      <Type name="RenderingContext" nullable="nullable"/>
      <ArgumentList>
        <Argument name="contextId">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toDataURL" id="::HTMLCanvasElement::toDataURL">
      <webidl>  DOMString toDataURL(optional DOMString type, any... arguments);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toBlob" id="::HTMLCanvasElement::toBlob">
      <webidl>  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="_callback">
          <Type name="FileCallback" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Window" id="::Window">
    <webidl>[Global]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  readonly attribute boolean closed;
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();


};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Global">
        <webidl>Global</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="window" readonly="readonly" id="::Window::window">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="self" readonly="readonly" id="::Window::self">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="document" readonly="readonly" id="::Window::document">
      <webidl>  [Unforgeable] readonly attribute <ref>Document</ref> document;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Document"/>
    </Attribute>
    <Attribute name="name" id="::Window::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="location" readonly="readonly" id="::Window::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location"/>
    </Attribute>
    <Attribute name="history" readonly="readonly" id="::Window::history">
      <webidl>  readonly attribute <ref>History</ref> history;</webidl>
      <Type name="History"/>
    </Attribute>
    <Attribute name="locationbar" readonly="readonly" id="::Window::locationbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="menubar" readonly="readonly" id="::Window::menubar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="personalbar" readonly="readonly" id="::Window::personalbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="scrollbars" readonly="readonly" id="::Window::scrollbars">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="statusbar" readonly="readonly" id="::Window::statusbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="toolbar" readonly="readonly" id="::Window::toolbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="status" id="::Window::status">
      <webidl>           attribute DOMString status;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="close" id="::Window::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="closed" readonly="readonly" id="::Window::closed">
      <webidl>  readonly attribute boolean closed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="stop" id="::Window::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="focus" id="::Window::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::Window::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="frames" readonly="readonly" id="::Window::frames">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="length" readonly="readonly" id="::Window::length">
      <webidl>  [Replaceable] readonly attribute unsigned long length;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="top" readonly="readonly" id="::Window::top">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="opener" id="::Window::opener">
      <webidl>           attribute <ref>WindowProxy</ref>? opener;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="parent" readonly="readonly" id="::Window::parent">
      <webidl>  readonly attribute <ref>WindowProxy</ref> parent;</webidl>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="frameElement" readonly="readonly" id="::Window::frameElement">
      <webidl>  readonly attribute <ref>Element</ref>? frameElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="open" id="::Window::open">
      <webidl>  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument optional="optional" name="url" stringvalue="about:blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="target" stringvalue="_blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="features" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter <ref>WindowProxy</ref> (unsigned long index);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="navigator" readonly="readonly" id="::Window::navigator">
      <webidl>  readonly attribute <ref>Navigator</ref> navigator;</webidl>
      <Type name="Navigator"/>
    </Attribute>
    <Attribute name="external" readonly="readonly" id="::Window::external">
      <webidl>  readonly attribute <ref>External</ref> external;</webidl>
      <Type name="External"/>
    </Attribute>
    <Attribute name="applicationCache" readonly="readonly" id="::Window::applicationCache">
      <webidl>  readonly attribute <ref>ApplicationCache</ref> applicationCache;</webidl>
      <Type name="ApplicationCache"/>
    </Attribute>
    <Operation name="alert" id="::Window::alert">
      <webidl>  void alert(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="confirm" id="::Window::confirm">
      <webidl>  boolean confirm(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="prompt" id="::Window::prompt">
      <webidl>  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="default" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="print" id="::Window::print">
      <webidl>  void print();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="GlobalEventHandlers">
    <webidl><ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Implements name1="Window" name2="WindowEventHandlers">
    <webidl><ref>Window</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="BarProp" id="::BarProp">
    <webidl>interface BarProp {
           attribute boolean visible;
};</webidl>
    <Attribute name="visible" id="::BarProp::visible">
      <webidl>           attribute boolean visible;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="History" id="::History">
    <webidl>interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};</webidl>
    <Attribute name="length" readonly="readonly" id="::History::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="state" readonly="readonly" id="::History::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
    <Operation name="go" id="::History::go">
      <webidl>  void go(optional long delta);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="delta">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="back" id="::History::back">
      <webidl>  void back();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="forward" id="::History::forward">
      <webidl>  void forward();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pushState" id="::History::pushState">
      <webidl>  void pushState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceState" id="::History::replaceState">
      <webidl>  void replaceState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Location" id="::Location">
    <webidl>[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Unforgeable">
        <webidl>Unforgeable</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="assign" id="::Location::assign">
      <webidl>  void assign(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replace" id="::Location::replace">
      <webidl>  void replace(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="reload" id="::Location::reload">
      <webidl>  void reload();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Location" name2="URLUtils">
    <webidl><ref>Location</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="PopStateEvent" id="::PopStateEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PopStateEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="state" readonly="readonly" id="::PopStateEvent::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
  </Interface>
  <Dictionary name="PopStateEventInit" id="::PopStateEventInit">
    <webidl>dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="state" id="::PopStateEventInit::state">
      <webidl>  any state;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HashChangeEvent" id="::HashChangeEvent">
    <webidl>[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="HashChangeEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="oldURL" readonly="readonly" id="::HashChangeEvent::oldURL">
      <webidl>  readonly attribute DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="newURL" readonly="readonly" id="::HashChangeEvent::newURL">
      <webidl>  readonly attribute DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Dictionary name="HashChangeEventInit" id="::HashChangeEventInit">
    <webidl>dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="oldURL" id="::HashChangeEventInit::oldURL">
      <webidl>  DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="newURL" id="::HashChangeEventInit::newURL">
      <webidl>  DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="PageTransitionEvent" id="::PageTransitionEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PageTransitionEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="persisted" readonly="readonly" id="::PageTransitionEvent::persisted">
      <webidl>  readonly attribute boolean persisted;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Dictionary name="PageTransitionEventInit" id="::PageTransitionEventInit">
    <webidl>dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="persisted" id="::PageTransitionEventInit::persisted">
      <webidl>  boolean persisted;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="BeforeUnloadEvent" id="::BeforeUnloadEvent">
    <webidl>interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="returnValue" id="::BeforeUnloadEvent::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="ApplicationCache" id="::ApplicationCache">
    <webidl>interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Const name="UNCACHED" value="0" id="::ApplicationCache::UNCACHED">
      <webidl>  const unsigned short UNCACHED = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="IDLE" value="1" id="::ApplicationCache::IDLE">
      <webidl>  const unsigned short IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CHECKING" value="2" id="::ApplicationCache::CHECKING">
      <webidl>  const unsigned short CHECKING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOWNLOADING" value="3" id="::ApplicationCache::DOWNLOADING">
      <webidl>  const unsigned short DOWNLOADING = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="UPDATEREADY" value="4" id="::ApplicationCache::UPDATEREADY">
      <webidl>  const unsigned short UPDATEREADY = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="OBSOLETE" value="5" id="::ApplicationCache::OBSOLETE">
      <webidl>  const unsigned short OBSOLETE = 5;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="status" readonly="readonly" id="::ApplicationCache::status">
      <webidl>  readonly attribute unsigned short status;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Operation name="update" id="::ApplicationCache::update">
      <webidl>  void update();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="abort" id="::ApplicationCache::abort">
      <webidl>  void abort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="swapCache" id="::ApplicationCache::swapCache">
      <webidl>  void swapCache();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onchecking" id="::ApplicationCache::onchecking">
      <webidl>           attribute <ref>EventHandler</ref> onchecking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::ApplicationCache::onerror">
      <webidl>           attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onnoupdate" id="::ApplicationCache::onnoupdate">
      <webidl>           attribute <ref>EventHandler</ref> onnoupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondownloading" id="::ApplicationCache::ondownloading">
      <webidl>           attribute <ref>EventHandler</ref> ondownloading;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::ApplicationCache::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onupdateready" id="::ApplicationCache::onupdateready">
      <webidl>           attribute <ref>EventHandler</ref> onupdateready;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncached" id="::ApplicationCache::oncached">
      <webidl>           attribute <ref>EventHandler</ref> oncached;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onobsolete" id="::ApplicationCache::onobsolete">
      <webidl>           attribute <ref>EventHandler</ref> onobsolete;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorOnLine" id="::NavigatorOnLine">
    <webidl>[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onLine" readonly="readonly" id="::NavigatorOnLine::onLine">
      <webidl>  readonly attribute boolean onLine;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="ErrorEvent" id="::ErrorEvent">
    <webidl>[Constructor(DOMString type, optional <ref>ErrorEventInit</ref> eventInitDict)]
interface ErrorEvent : <ref>Event</ref> {
  readonly attribute DOMString message;
  readonly attribute DOMString filename;
  readonly attribute unsigned long lineno;
  readonly attribute unsigned long colno;
  readonly attribute any error;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>ErrorEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="ErrorEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="message" readonly="readonly" id="::ErrorEvent::message">
      <webidl>  readonly attribute DOMString message;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="filename" readonly="readonly" id="::ErrorEvent::filename">
      <webidl>  readonly attribute DOMString filename;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lineno" readonly="readonly" id="::ErrorEvent::lineno">
      <webidl>  readonly attribute unsigned long lineno;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="colno" readonly="readonly" id="::ErrorEvent::colno">
      <webidl>  readonly attribute unsigned long colno;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="error" readonly="readonly" id="::ErrorEvent::error">
      <webidl>  readonly attribute any error;</webidl>
      <Type type="any"/>
    </Attribute>
  </Interface>
  <Dictionary name="ErrorEventInit" id="::ErrorEventInit">
    <webidl>dictionary ErrorEventInit : <ref>EventInit</ref> {
  DOMString message;
  DOMString filename;
  unsigned long lineno;
  unsigned long colno;
  any error;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="message" id="::ErrorEventInit::message">
      <webidl>  DOMString message;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="filename" id="::ErrorEventInit::filename">
      <webidl>  DOMString filename;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="lineno" id="::ErrorEventInit::lineno">
      <webidl>  unsigned long lineno;</webidl>
      <Type type="unsigned long"/>
    </DictionaryMember>
    <DictionaryMember name="colno" id="::ErrorEventInit::colno">
      <webidl>  unsigned long colno;</webidl>
      <Type type="unsigned long"/>
    </DictionaryMember>
    <DictionaryMember name="error" id="::ErrorEventInit::error">
      <webidl>  any error;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Callback name="EventHandlerNonNull" id="::EventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type name="Event"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="EventHandler" id="::EventHandler">
    <webidl>typedef <ref>EventHandlerNonNull</ref>? EventHandler;</webidl>
    <Type name="EventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Callback name="OnErrorEventHandlerNonNull" id="::OnErrorEventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column, optional any error);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type type="union">
          <Type name="Event"/>
          <Type type="DOMString"/>
        </Type>
      </Argument>
      <Argument optional="optional" name="source">
        <Type type="DOMString"/>
      </Argument>
      <Argument optional="optional" name="lineno">
        <Type type="unsigned long"/>
      </Argument>
      <Argument optional="optional" name="column">
        <Type type="unsigned long"/>
      </Argument>
      <Argument optional="optional" name="error">
        <Type type="any"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="OnErrorEventHandler" id="::OnErrorEventHandler">
    <webidl>typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;</webidl>
    <Type name="OnErrorEventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Callback name="OnBeforeUnloadEventHandlerNonNull" id="::OnBeforeUnloadEventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback OnBeforeUnloadEventHandlerNonNull = DOMString? (<ref>Event</ref> event);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="DOMString" nullable="nullable"/>
    <ArgumentList>
      <Argument name="event">
        <Type name="Event"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="OnBeforeUnloadEventHandler" id="::OnBeforeUnloadEventHandler">
    <webidl>typedef <ref>OnBeforeUnloadEventHandlerNonNull</ref>? OnBeforeUnloadEventHandler;</webidl>
    <Type name="OnBeforeUnloadEventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Interface name="GlobalEventHandlers" id="::GlobalEventHandlers">
    <webidl>[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> ontoggle;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onabort" id="::GlobalEventHandlers::onabort">
      <webidl>           attribute <ref>EventHandler</ref> onabort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onblur" id="::GlobalEventHandlers::onblur">
      <webidl>           attribute <ref>EventHandler</ref> onblur;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncancel" id="::GlobalEventHandlers::oncancel">
      <webidl>           attribute <ref>EventHandler</ref> oncancel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::GlobalEventHandlers::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::GlobalEventHandlers::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onchange" id="::GlobalEventHandlers::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onclick" id="::GlobalEventHandlers::onclick">
      <webidl>           attribute <ref>EventHandler</ref> onclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncuechange" id="::GlobalEventHandlers::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondblclick" id="::GlobalEventHandlers::ondblclick">
      <webidl>           attribute <ref>EventHandler</ref> ondblclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::GlobalEventHandlers::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onemptied" id="::GlobalEventHandlers::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::GlobalEventHandlers::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::GlobalEventHandlers::onerror">
      <webidl>           attribute <ref>OnErrorEventHandler</ref> onerror;</webidl>
      <Type name="OnErrorEventHandler"/>
    </Attribute>
    <Attribute name="onfocus" id="::GlobalEventHandlers::onfocus">
      <webidl>           attribute <ref>EventHandler</ref> onfocus;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninput" id="::GlobalEventHandlers::oninput">
      <webidl>           attribute <ref>EventHandler</ref> oninput;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninvalid" id="::GlobalEventHandlers::oninvalid">
      <webidl>           attribute <ref>EventHandler</ref> oninvalid;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeydown" id="::GlobalEventHandlers::onkeydown">
      <webidl>           attribute <ref>EventHandler</ref> onkeydown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeypress" id="::GlobalEventHandlers::onkeypress">
      <webidl>           attribute <ref>EventHandler</ref> onkeypress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeyup" id="::GlobalEventHandlers::onkeyup">
      <webidl>           attribute <ref>EventHandler</ref> onkeyup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onload" id="::GlobalEventHandlers::onload">
      <webidl>           attribute <ref>EventHandler</ref> onload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::GlobalEventHandlers::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::GlobalEventHandlers::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadstart" id="::GlobalEventHandlers::onloadstart">
      <webidl>           attribute <ref>EventHandler</ref> onloadstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousedown" id="::GlobalEventHandlers::onmousedown">
      <webidl>           attribute <ref>EventHandler</ref> onmousedown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseenter" id="::GlobalEventHandlers::onmouseenter">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseleave" id="::GlobalEventHandlers::onmouseleave">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousemove" id="::GlobalEventHandlers::onmousemove">
      <webidl>           attribute <ref>EventHandler</ref> onmousemove;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseout" id="::GlobalEventHandlers::onmouseout">
      <webidl>           attribute <ref>EventHandler</ref> onmouseout;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseover" id="::GlobalEventHandlers::onmouseover">
      <webidl>           attribute <ref>EventHandler</ref> onmouseover;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseup" id="::GlobalEventHandlers::onmouseup">
      <webidl>           attribute <ref>EventHandler</ref> onmouseup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousewheel" id="::GlobalEventHandlers::onmousewheel">
      <webidl>           attribute <ref>EventHandler</ref> onmousewheel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::GlobalEventHandlers::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::GlobalEventHandlers::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::GlobalEventHandlers::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::GlobalEventHandlers::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::GlobalEventHandlers::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onreset" id="::GlobalEventHandlers::onreset">
      <webidl>           attribute <ref>EventHandler</ref> onreset;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onresize" id="::GlobalEventHandlers::onresize">
      <webidl>           attribute <ref>EventHandler</ref> onresize;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onscroll" id="::GlobalEventHandlers::onscroll">
      <webidl>           attribute <ref>EventHandler</ref> onscroll;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeked" id="::GlobalEventHandlers::onseeked">
      <webidl>           attribute <ref>EventHandler</ref> onseeked;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeking" id="::GlobalEventHandlers::onseeking">
      <webidl>           attribute <ref>EventHandler</ref> onseeking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onselect" id="::GlobalEventHandlers::onselect">
      <webidl>           attribute <ref>EventHandler</ref> onselect;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onshow" id="::GlobalEventHandlers::onshow">
      <webidl>           attribute <ref>EventHandler</ref> onshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstalled" id="::GlobalEventHandlers::onstalled">
      <webidl>           attribute <ref>EventHandler</ref> onstalled;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsubmit" id="::GlobalEventHandlers::onsubmit">
      <webidl>           attribute <ref>EventHandler</ref> onsubmit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsuspend" id="::GlobalEventHandlers::onsuspend">
      <webidl>           attribute <ref>EventHandler</ref> onsuspend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::GlobalEventHandlers::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontoggle" id="::GlobalEventHandlers::ontoggle">
      <webidl>           attribute <ref>EventHandler</ref> ontoggle;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::GlobalEventHandlers::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::GlobalEventHandlers::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowEventHandlers" id="::WindowEventHandlers">
    <webidl>[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>OnBeforeUnloadEventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onafterprint" id="::WindowEventHandlers::onafterprint">
      <webidl>           attribute <ref>EventHandler</ref> onafterprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeprint" id="::WindowEventHandlers::onbeforeprint">
      <webidl>           attribute <ref>EventHandler</ref> onbeforeprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeunload" id="::WindowEventHandlers::onbeforeunload">
      <webidl>           attribute <ref>OnBeforeUnloadEventHandler</ref> onbeforeunload;</webidl>
      <Type name="OnBeforeUnloadEventHandler"/>
    </Attribute>
    <Attribute name="onhashchange" id="::WindowEventHandlers::onhashchange">
      <webidl>           attribute <ref>EventHandler</ref> onhashchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmessage" id="::WindowEventHandlers::onmessage">
      <webidl>           attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onoffline" id="::WindowEventHandlers::onoffline">
      <webidl>           attribute <ref>EventHandler</ref> onoffline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ononline" id="::WindowEventHandlers::ononline">
      <webidl>           attribute <ref>EventHandler</ref> ononline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpagehide" id="::WindowEventHandlers::onpagehide">
      <webidl>           attribute <ref>EventHandler</ref> onpagehide;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpageshow" id="::WindowEventHandlers::onpageshow">
      <webidl>           attribute <ref>EventHandler</ref> onpageshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpopstate" id="::WindowEventHandlers::onpopstate">
      <webidl>           attribute <ref>EventHandler</ref> onpopstate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstorage" id="::WindowEventHandlers::onstorage">
      <webidl>           attribute <ref>EventHandler</ref> onstorage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onunload" id="::WindowEventHandlers::onunload">
      <webidl>           attribute <ref>EventHandler</ref> onunload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowBase64" id="::WindowBase64">
    <webidl>[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="btoa" id="::WindowBase64::btoa">
      <webidl>  DOMString btoa(DOMString btoa);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="btoa">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="atob" id="::WindowBase64::atob">
      <webidl>  DOMString atob(DOMString atob);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="atob">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowBase64">
    <webidl><ref>Window</ref> implements <ref>WindowBase64</ref>;</webidl>
  </Implements>
  <Interface name="WindowTimers" id="::WindowTimers">
    <webidl>[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearTimeout" id="::WindowTimers::clearTimeout">
      <webidl>  void clearTimeout(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearInterval" id="::WindowTimers::clearInterval">
      <webidl>  void clearInterval(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowTimers">
    <webidl><ref>Window</ref> implements <ref>WindowTimers</ref>;</webidl>
  </Implements>
  <Interface name="Navigator" id="::Navigator">
    <webidl>interface Navigator {
};</webidl>
  </Interface>
  <Implements name1="Navigator" name2="NavigatorID">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorID</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorLanguage">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorOnLine">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorContentUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorStorageUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorPlugins">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorPlugins</ref>;</webidl>
  </Implements>
  <Interface name="NavigatorID" id="::NavigatorID">
    <webidl>[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appCodeName; 
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString product; 
  boolean taintEnabled(); 
  readonly attribute DOMString userAgent;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="appCodeName" readonly="readonly" id="::NavigatorID::appCodeName">
      <webidl>  readonly attribute DOMString appCodeName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="appName" readonly="readonly" id="::NavigatorID::appName">
      <webidl>  readonly attribute DOMString appName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="appVersion" readonly="readonly" id="::NavigatorID::appVersion">
      <webidl>  readonly attribute DOMString appVersion;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="platform" readonly="readonly" id="::NavigatorID::platform">
      <webidl>  readonly attribute DOMString platform;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="product" readonly="readonly" id="::NavigatorID::product">
      <webidl>  readonly attribute DOMString product;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="taintEnabled" id="::NavigatorID::taintEnabled">
      <webidl>  boolean taintEnabled();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="userAgent" readonly="readonly" id="::NavigatorID::userAgent">
      <webidl>  readonly attribute DOMString userAgent;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorLanguage" id="::NavigatorLanguage">
    <webidl>[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="language" readonly="readonly" id="::NavigatorLanguage::language">
      <webidl>  readonly attribute DOMString? language;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorContentUtils" id="::NavigatorContentUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="registerProtocolHandler" id="::NavigatorContentUtils::registerProtocolHandler">
      <webidl>  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="registerContentHandler" id="::NavigatorContentUtils::registerContentHandler">
      <webidl>  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterProtocolHandler" id="::NavigatorContentUtils::unregisterProtocolHandler">
      <webidl>  void unregisterProtocolHandler(DOMString scheme, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterContentHandler" id="::NavigatorContentUtils::unregisterContentHandler">
      <webidl>  void unregisterContentHandler(DOMString mimeType, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NavigatorStorageUtils" id="::NavigatorStorageUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorStorageUtils {
  readonly attribute boolean cookieEnabled;
  void yieldForStorageUpdates();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="cookieEnabled" readonly="readonly" id="::NavigatorStorageUtils::cookieEnabled">
      <webidl>  readonly attribute boolean cookieEnabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="yieldForStorageUpdates" id="::NavigatorStorageUtils::yieldForStorageUpdates">
      <webidl>  void yieldForStorageUpdates();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="NavigatorPlugins" id="::NavigatorPlugins">
    <webidl>[NoInterfaceObject]
interface NavigatorPlugins {
  readonly attribute <ref>PluginArray</ref> plugins;
  readonly attribute <ref>MimeTypeArray</ref> mimeTypes;
  readonly attribute boolean javaEnabled;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="plugins" readonly="readonly" id="::NavigatorPlugins::plugins">
      <webidl>  readonly attribute <ref>PluginArray</ref> plugins;</webidl>
      <Type name="PluginArray"/>
    </Attribute>
    <Attribute name="mimeTypes" readonly="readonly" id="::NavigatorPlugins::mimeTypes">
      <webidl>  readonly attribute <ref>MimeTypeArray</ref> mimeTypes;</webidl>
      <Type name="MimeTypeArray"/>
    </Attribute>
    <Attribute name="javaEnabled" readonly="readonly" id="::NavigatorPlugins::javaEnabled">
      <webidl>  readonly attribute boolean javaEnabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="PluginArray" id="::PluginArray">
    <webidl>interface PluginArray {
  void refresh(optional boolean reload = false);
  readonly attribute unsigned long length;
  getter <ref>Plugin</ref>? item(unsigned long index);
  getter <ref>Plugin</ref>? namedItem(DOMString name);
};</webidl>
    <Operation name="refresh" id="::PluginArray::refresh">
      <webidl>  void refresh(optional boolean reload = false);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="reload" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="length" readonly="readonly" id="::PluginArray::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::PluginArray::item">
      <webidl>  getter <ref>Plugin</ref>? item(unsigned long index);</webidl>
      <Type name="Plugin" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="namedItem" id="::PluginArray::namedItem">
      <webidl>  getter <ref>Plugin</ref>? namedItem(DOMString name);</webidl>
      <Type name="Plugin" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MimeTypeArray" id="::MimeTypeArray">
    <webidl>interface MimeTypeArray {
  readonly attribute unsigned long length;
  getter <ref>MimeType</ref>? item(unsigned long index);
  getter <ref>MimeType</ref>? namedItem(DOMString name);
};</webidl>
    <Attribute name="length" readonly="readonly" id="::MimeTypeArray::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::MimeTypeArray::item">
      <webidl>  getter <ref>MimeType</ref>? item(unsigned long index);</webidl>
      <Type name="MimeType" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="namedItem" id="::MimeTypeArray::namedItem">
      <webidl>  getter <ref>MimeType</ref>? namedItem(DOMString name);</webidl>
      <Type name="MimeType" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Plugin" id="::Plugin">
    <webidl>interface Plugin {
  readonly attribute DOMString name;
  readonly attribute DOMString description;
  readonly attribute DOMString filename;
  readonly attribute unsigned long length;
  getter <ref>MimeType</ref>? item(unsigned long index);
  getter <ref>MimeType</ref>? namedItem(DOMString name);
};</webidl>
    <Attribute name="name" readonly="readonly" id="::Plugin::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="description" readonly="readonly" id="::Plugin::description">
      <webidl>  readonly attribute DOMString description;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="filename" readonly="readonly" id="::Plugin::filename">
      <webidl>  readonly attribute DOMString filename;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="length" readonly="readonly" id="::Plugin::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::Plugin::item">
      <webidl>  getter <ref>MimeType</ref>? item(unsigned long index);</webidl>
      <Type name="MimeType" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="namedItem" id="::Plugin::namedItem">
      <webidl>  getter <ref>MimeType</ref>? namedItem(DOMString name);</webidl>
      <Type name="MimeType" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MimeType" id="::MimeType">
    <webidl>interface MimeType {
  readonly attribute DOMString type;
  readonly attribute DOMString description;
  readonly attribute DOMString suffixes; 
  readonly attribute <ref>Plugin</ref> enabledPlugin;
};</webidl>
    <Attribute name="type" readonly="readonly" id="::MimeType::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="description" readonly="readonly" id="::MimeType::description">
      <webidl>  readonly attribute DOMString description;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="suffixes" readonly="readonly" id="::MimeType::suffixes">
      <webidl>  readonly attribute DOMString suffixes;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enabledPlugin" readonly="readonly" id="::MimeType::enabledPlugin">
      <webidl>  readonly attribute <ref>Plugin</ref> enabledPlugin;</webidl>
      <Type name="Plugin"/>
    </Attribute>
  </Interface>
  <Interface name="External" id="::External">
    <webidl>interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};</webidl>
    <Operation name="AddSearchProvider" id="::External::AddSearchProvider">
      <webidl>  void AddSearchProvider(DOMString engineURL);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="IsSearchProviderInstalled" id="::External::IsSearchProviderInstalled">
      <webidl>  unsigned long IsSearchProviderInstalled(DOMString engineURL);</webidl>
      <Type type="unsigned long"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLAppletElement" id="::HTMLAppletElement">
    <webidl>interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="align" id="::HTMLAppletElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLAppletElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLAppletElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLAppletElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLAppletElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLAppletElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLAppletElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAppletElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="object" id="::HTMLAppletElement::object">
      <webidl>           attribute DOMString _object;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLAppletElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLAppletElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMarqueeElement" id="::HTMLMarqueeElement">
    <webidl>interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="behavior" id="::HTMLMarqueeElement::behavior">
      <webidl>           attribute DOMString behavior;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLMarqueeElement::bgColor">
      <webidl>           attribute DOMString bgColor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="direction" id="::HTMLMarqueeElement::direction">
      <webidl>           attribute DOMString direction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLMarqueeElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLMarqueeElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMarqueeElement::loop">
      <webidl>           attribute long loop;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="scrollAmount" id="::HTMLMarqueeElement::scrollAmount">
      <webidl>           attribute unsigned long scrollAmount;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="scrollDelay" id="::HTMLMarqueeElement::scrollDelay">
      <webidl>           attribute unsigned long scrollDelay;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="trueSpeed" id="::HTMLMarqueeElement::trueSpeed">
      <webidl>           attribute boolean trueSpeed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLMarqueeElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLMarqueeElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="onbounce" id="::HTMLMarqueeElement::onbounce">
      <webidl>           attribute <ref>EventHandler</ref> onbounce;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfinish" id="::HTMLMarqueeElement::onfinish">
      <webidl>           attribute <ref>EventHandler</ref> onfinish;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstart" id="::HTMLMarqueeElement::onstart">
      <webidl>           attribute <ref>EventHandler</ref> onstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Operation name="start" id="::HTMLMarqueeElement::start">
      <webidl>  void start();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stop" id="::HTMLMarqueeElement::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLFrameSetElement" id="::HTMLFrameSetElement">
    <webidl>interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cols" id="::HTMLFrameSetElement::cols">
      <webidl>           attribute DOMString cols;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLFrameSetElement::rows">
      <webidl>           attribute DOMString rows;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLFrameSetElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLFrameElement" id="::HTMLFrameElement">
    <webidl>interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noResize" id="::HTMLFrameElement::noResize">
      <webidl>           attribute boolean noResize;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="contentDocument" readonly="readonly" id="::HTMLFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute name="contentWindow" readonly="readonly" id="::HTMLFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAnchorElement" partial="partial" id="::HTMLAnchorElement">
    <webidl>partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString shape;
};</webidl>
    <Attribute name="coords" id="::HTMLAnchorElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLAnchorElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAnchorElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAnchorElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" partial="partial" id="::HTMLAreaElement">
    <webidl>partial interface HTMLAreaElement {
           attribute boolean noHref;
};</webidl>
    <Attribute name="noHref" id="::HTMLAreaElement::noHref">
      <webidl>           attribute boolean noHref;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBodyElement" partial="partial" id="::HTMLBodyElement">
    <webidl>partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};</webidl>
    <Attribute name="text" id="::HTMLBodyElement::text">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString text;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="link" id="::HTMLBodyElement::link">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString link;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vLink" id="::HTMLBodyElement::vLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="aLink" id="::HTMLBodyElement::aLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString aLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLBodyElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="background" id="::HTMLBodyElement::background">
      <webidl>                            attribute DOMString background;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBRElement" partial="partial" id="::HTMLBRElement">
    <webidl>partial interface HTMLBRElement {
           attribute DOMString clear;
};</webidl>
    <Attribute name="clear" id="::HTMLBRElement::clear">
      <webidl>           attribute DOMString clear;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCaptionElement" partial="partial" id="::HTMLTableCaptionElement">
    <webidl>partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLTableCaptionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableColElement" partial="partial" id="::HTMLTableColElement">
    <webidl>partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLTableColElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableColElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableColElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableColElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableColElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDirectoryElement" id="::HTMLDirectoryElement">
    <webidl>interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="compact" id="::HTMLDirectoryElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDivElement" partial="partial" id="::HTMLDivElement">
    <webidl>partial interface HTMLDivElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLDivElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" partial="partial" id="::HTMLDListElement">
    <webidl>partial interface HTMLDListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLDListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" partial="partial" id="::HTMLEmbedElement">
    <webidl>partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};</webidl>
    <Attribute name="align" id="::HTMLEmbedElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLEmbedElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFontElement" id="::HTMLFontElement">
    <webidl>interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="color" id="::HTMLFontElement::color">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString color;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="face" id="::HTMLFontElement::face">
      <webidl>                            attribute DOMString face;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="size" id="::HTMLFontElement::size">
      <webidl>                            attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHeadingElement" partial="partial" id="::HTMLHeadingElement">
    <webidl>partial interface HTMLHeadingElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLHeadingElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHRElement" partial="partial" id="::HTMLHRElement">
    <webidl>partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLHRElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="color" id="::HTMLHRElement::color">
      <webidl>           attribute DOMString color;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noShade" id="::HTMLHRElement::noShade">
      <webidl>           attribute boolean noShade;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLHRElement::size">
      <webidl>           attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLHRElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHtmlElement" partial="partial" id="::HTMLHtmlElement">
    <webidl>partial interface HTMLHtmlElement {
           attribute DOMString version;
};</webidl>
    <Attribute name="version" id="::HTMLHtmlElement::version">
      <webidl>           attribute DOMString version;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" partial="partial" id="::HTMLIFrameElement">
    <webidl>partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <Attribute name="align" id="::HTMLIFrameElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLIFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLIFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLIFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLIFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLIFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" partial="partial" id="::HTMLImageElement">
    <webidl>partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString lowsrc;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="name" id="::HTMLImageElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lowsrc" id="::HTMLImageElement::lowsrc">
      <webidl>           attribute DOMString lowsrc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="align" id="::HTMLImageElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLImageElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLImageElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLImageElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLImageElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" partial="partial" id="::HTMLInputElement">
    <webidl>partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};</webidl>
    <Attribute name="align" id="::HTMLInputElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLInputElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLegendElement" partial="partial" id="::HTMLLegendElement">
    <webidl>partial interface HTMLLegendElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLLegendElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLIElement" partial="partial" id="::HTMLLIElement">
    <webidl>partial interface HTMLLIElement {
           attribute DOMString type;
};</webidl>
    <Attribute name="type" id="::HTMLLIElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" partial="partial" id="::HTMLLinkElement">
    <webidl>partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString target;
};</webidl>
    <Attribute name="charset" id="::HTMLLinkElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLLinkElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMetaElement" partial="partial" id="::HTMLMetaElement">
    <webidl>partial interface HTMLMetaElement {
           attribute DOMString scheme;
};</webidl>
    <Attribute name="scheme" id="::HTMLMetaElement::scheme">
      <webidl>           attribute DOMString scheme;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLObjectElement" partial="partial" id="::HTMLObjectElement">
    <webidl>partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="align" id="::HTMLObjectElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLObjectElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLObjectElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="declare" id="::HTMLObjectElement::declare">
      <webidl>           attribute boolean declare;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLObjectElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="standby" id="::HTMLObjectElement::standby">
      <webidl>           attribute DOMString standby;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLObjectElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLObjectElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeType" id="::HTMLObjectElement::codeType">
      <webidl>           attribute DOMString codeType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLObjectElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" partial="partial" id="::HTMLOListElement">
    <webidl>partial interface HTMLOListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLOListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParagraphElement" partial="partial" id="::HTMLParagraphElement">
    <webidl>partial interface HTMLParagraphElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLParagraphElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParamElement" partial="partial" id="::HTMLParamElement">
    <webidl>partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};</webidl>
    <Attribute name="type" id="::HTMLParamElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueType" id="::HTMLParamElement::valueType">
      <webidl>           attribute DOMString valueType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLPreElement" partial="partial" id="::HTMLPreElement">
    <webidl>partial interface HTMLPreElement {
           attribute long width;
};</webidl>
    <Attribute name="width" id="::HTMLPreElement::width">
      <webidl>           attribute long width;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLScriptElement" partial="partial" id="::HTMLScriptElement">
    <webidl>partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};</webidl>
    <Attribute name="event" id="::HTMLScriptElement::event">
      <webidl>           attribute DOMString event;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLScriptElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableElement" partial="partial" id="::HTMLTableElement">
    <webidl>partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};</webidl>
    <Attribute name="align" id="::HTMLTableElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frame" id="::HTMLTableElement::frame">
      <webidl>           attribute DOMString frame;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rules" id="::HTMLTableElement::rules">
      <webidl>           attribute DOMString rules;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="summary" id="::HTMLTableElement::summary">
      <webidl>           attribute DOMString summary;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellPadding" id="::HTMLTableElement::cellPadding">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellPadding;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellSpacing" id="::HTMLTableElement::cellSpacing">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" partial="partial" id="::HTMLTableSectionElement">
    <webidl>partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};</webidl>
    <Attribute name="align" id="::HTMLTableSectionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableSectionElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableSectionElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableSectionElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCellElement" partial="partial" id="::HTMLTableCellElement">
    <webidl>partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableCellElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="axis" id="::HTMLTableCellElement::axis">
      <webidl>           attribute DOMString axis;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLTableCellElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableCellElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableCellElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableCellElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noWrap" id="::HTMLTableCellElement::noWrap">
      <webidl>           attribute boolean noWrap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableCellElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableCellElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableDataCellElement" partial="partial" id="::HTMLTableDataCellElement">
    <webidl>partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};</webidl>
    <Attribute name="abbr" id="::HTMLTableDataCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableRowElement" partial="partial" id="::HTMLTableRowElement">
    <webidl>partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableRowElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableRowElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableRowElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableRowElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableRowElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" partial="partial" id="::HTMLUListElement">
    <webidl>partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};</webidl>
    <Attribute name="compact" id="::HTMLUListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="type" id="::HTMLUListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();
  void captureEvents(long dummy);
  void releaseEvents(long dummy);

  readonly attribute <ref>HTMLAllCollection</ref> all;
};</webidl>
    <Attribute name="fgColor" id="::Document::fgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString fgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="linkColor" id="::Document::linkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString linkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vlinkColor" id="::Document::vlinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alinkColor" id="::Document::alinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString alinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::Document::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="anchors" readonly="readonly" id="::Document::anchors">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> anchors;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="applets" readonly="readonly" id="::Document::applets">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> applets;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="clear" id="::Document::clear">
      <webidl>  void clear();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="captureEvents" id="::Document::captureEvents">
      <webidl>  void captureEvents(long dummy);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="dummy">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="releaseEvents" id="::Document::releaseEvents">
      <webidl>  void releaseEvents(long dummy);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="dummy">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="all" readonly="readonly" id="::Document::all">
      <webidl>  readonly attribute <ref>HTMLAllCollection</ref> all;</webidl>
      <Type name="HTMLAllCollection"/>
    </Attribute>
  </Interface>
  <Interface name="Window" partial="partial" id="::Window">
    <webidl>partial interface Window {
  void captureEvents(long dummy);
  void releaseEvents(long dummy);
};</webidl>
    <Operation name="captureEvents" id="::Window::captureEvents">
      <webidl>  void captureEvents(long dummy);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="dummy">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="releaseEvents" id="::Window::releaseEvents">
      <webidl>  void releaseEvents(long dummy);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="dummy">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
</Definitions>
<Definitions>
  <webidl>enum VisibilityState { &quot;hidden&quot;, &quot;visible&quot;, &quot;prerender&quot;, &quot;unloaded&quot; };

partial interface Document {
  readonly attribute boolean hidden;
  readonly attribute <ref>VisibilityState</ref> visibilityState; 
};</webidl>
  <Enum name="VisibilityState" id="::VisibilityState">
    <webidl>enum VisibilityState { &quot;hidden&quot;, &quot;visible&quot;, &quot;prerender&quot;, &quot;unloaded&quot; };</webidl>
    <EnumValue stringvalue="hidden">
      <webidl> &quot;hidden</webidl>
    </EnumValue>
    <EnumValue stringvalue="visible">
      <webidl> &quot;visible</webidl>
    </EnumValue>
    <EnumValue stringvalue="prerender">
      <webidl> &quot;prerender</webidl>
    </EnumValue>
    <EnumValue stringvalue="unloaded">
      <webidl> &quot;unloaded</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>partial interface Document {
  readonly attribute boolean hidden;
  readonly attribute <ref>VisibilityState</ref> visibilityState; 
};</webidl>
    <Attribute name="hidden" readonly="readonly" id="::Document::hidden">
      <webidl>  readonly attribute boolean hidden;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="visibilityState" readonly="readonly" id="::Document::visibilityState">
      <webidl>  readonly attribute <ref>VisibilityState</ref> visibilityState;</webidl>
      <Type name="VisibilityState"/>
    </Attribute>
  </Interface>
</Definitions>
<Definitions>
  <webidl>[Constructor(DOMString type, optional <ref>MessageEventInit</ref> eventInitDict), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessageEvent : <ref>Event</ref> {
  readonly attribute any data;
  readonly attribute DOMString origin;
  readonly attribute DOMString lastEventId;
  readonly attribute (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;
  readonly attribute <ref>MessagePort</ref>[]? ports;

  void initMessageEvent(DOMString typeArg, boolean canBubbleArg, boolean cancelableArg, any dataArg, DOMString originArg, DOMString lastEventIdArg, (<ref>WindowProxy</ref> or <ref>MessagePort</ref>) sourceArg, sequence&lt;<ref>MessagePort</ref>>? portsArg);
};

dictionary MessageEventInit : <ref>EventInit</ref> {
  any data;
  DOMString origin;
  DOMString lastEventId;
  (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;
  sequence&lt;<ref>MessagePort</ref>> ports;
};
[Constructor, Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessageChannel {
  readonly attribute <ref>MessagePort</ref> port1;
  readonly attribute <ref>MessagePort</ref> port2;
};
[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessagePort : <ref>EventTarget</ref> {
  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  void start();
  void close();

  attribute <ref>EventHandler</ref> onmessage;
};</webidl>
  <Interface name="MessageEvent" id="::MessageEvent">
    <webidl>[Constructor(DOMString type, optional <ref>MessageEventInit</ref> eventInitDict), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessageEvent : <ref>Event</ref> {
  readonly attribute any data;
  readonly attribute DOMString origin;
  readonly attribute DOMString lastEventId;
  readonly attribute (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;
  readonly attribute <ref>MessagePort</ref>[]? ports;

  void initMessageEvent(DOMString typeArg, boolean canBubbleArg, boolean cancelableArg, any dataArg, DOMString originArg, DOMString lastEventIdArg, (<ref>WindowProxy</ref> or <ref>MessagePort</ref>) sourceArg, sequence&lt;<ref>MessagePort</ref>>? portsArg);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>MessageEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="MessageEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="data" readonly="readonly" id="::MessageEvent::data">
      <webidl>  readonly attribute any data;</webidl>
      <Type type="any"/>
    </Attribute>
    <Attribute name="origin" readonly="readonly" id="::MessageEvent::origin">
      <webidl>  readonly attribute DOMString origin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lastEventId" readonly="readonly" id="::MessageEvent::lastEventId">
      <webidl>  readonly attribute DOMString lastEventId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="source" readonly="readonly" id="::MessageEvent::source">
      <webidl>  readonly attribute (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;</webidl>
      <Type type="union" nullable="nullable">
        <Type name="WindowProxy"/>
        <Type name="MessagePort"/>
      </Type>
    </Attribute>
    <Attribute name="ports" readonly="readonly" id="::MessageEvent::ports">
      <webidl>  readonly attribute <ref>MessagePort</ref>[]? ports;</webidl>
      <Type type="array" nullable="nullable">
        <Type name="MessagePort"/>
      </Type>
    </Attribute>
    <Operation name="initMessageEvent" id="::MessageEvent::initMessageEvent">
      <webidl>  void initMessageEvent(DOMString typeArg, boolean canBubbleArg, boolean cancelableArg, any dataArg, DOMString originArg, DOMString lastEventIdArg, (<ref>WindowProxy</ref> or <ref>MessagePort</ref>) sourceArg, sequence&lt;<ref>MessagePort</ref>>? portsArg);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="typeArg">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="canBubbleArg">
          <Type type="boolean"/>
        </Argument>
        <Argument name="cancelableArg">
          <Type type="boolean"/>
        </Argument>
        <Argument name="dataArg">
          <Type type="any"/>
        </Argument>
        <Argument name="originArg">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="lastEventIdArg">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="sourceArg">
          <Type type="union">
            <Type name="WindowProxy"/>
            <Type name="MessagePort"/>
          </Type>
        </Argument>
        <Argument name="portsArg">
          <Type type="sequence" nullable="nullable">
            <Type name="MessagePort"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="MessageEventInit" id="::MessageEventInit">
    <webidl>dictionary MessageEventInit : <ref>EventInit</ref> {
  any data;
  DOMString origin;
  DOMString lastEventId;
  (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;
  sequence&lt;<ref>MessagePort</ref>> ports;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="data" id="::MessageEventInit::data">
      <webidl>  any data;</webidl>
      <Type type="any"/>
    </DictionaryMember>
    <DictionaryMember name="origin" id="::MessageEventInit::origin">
      <webidl>  DOMString origin;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="lastEventId" id="::MessageEventInit::lastEventId">
      <webidl>  DOMString lastEventId;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="source" id="::MessageEventInit::source">
      <webidl>  (<ref>WindowProxy</ref> or <ref>MessagePort</ref>)? source;</webidl>
      <Type type="union" nullable="nullable">
        <Type name="WindowProxy"/>
        <Type name="MessagePort"/>
      </Type>
    </DictionaryMember>
    <DictionaryMember name="ports" id="::MessageEventInit::ports">
      <webidl>  sequence&lt;<ref>MessagePort</ref>> ports;</webidl>
      <Type type="sequence">
        <Type name="MessagePort"/>
      </Type>
    </DictionaryMember>
  </Dictionary>
  <Interface name="MessageChannel" id="::MessageChannel">
    <webidl>[Constructor, Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessageChannel {
  readonly attribute <ref>MessagePort</ref> port1;
  readonly attribute <ref>MessagePort</ref> port2;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="port1" readonly="readonly" id="::MessageChannel::port1">
      <webidl>  readonly attribute <ref>MessagePort</ref> port1;</webidl>
      <Type name="MessagePort"/>
    </Attribute>
    <Attribute name="port2" readonly="readonly" id="::MessageChannel::port2">
      <webidl>  readonly attribute <ref>MessagePort</ref> port2;</webidl>
      <Type name="MessagePort"/>
    </Attribute>
  </Interface>
  <Interface name="MessagePort" id="::MessagePort">
    <webidl>[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface MessagePort : <ref>EventTarget</ref> {
  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  void start();
  void close();

  attribute <ref>EventHandler</ref> onmessage;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Operation name="postMessage" id="::MessagePort::postMessage">
      <webidl>  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="message">
          <Type type="any"/>
        </Argument>
        <Argument optional="optional" name="transfer">
          <Type type="sequence">
            <Type name="Transferable"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="start" id="::MessagePort::start">
      <webidl>  void start();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="close" id="::MessagePort::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onmessage" id="::MessagePort::onmessage">
      <webidl>  attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
</Definitions>
<Definitions>
  <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};
interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};

interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};
interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name); 
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};
interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};
interface DOMElementMap {
  getter <ref>Element</ref> (DOMString name);
  setter creator void (DOMString name, <ref>Element</ref> value);
  deleter void (DOMString name);
};
[NoInterfaceObject]
interface Transferable { };
callback FileCallback = void (<ref>File</ref> file);
enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };

[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);
  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;); 
  readonly attribute <ref>DOMElementMap</ref> cssElementMap;
  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);
  readonly attribute <ref>HTMLCollection</ref> commands;

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};
<ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;
partial interface XMLDocument {
  boolean load(DOMString url);
};
interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;

           attribute boolean itemScope;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;
           attribute DOMString itemId;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;
  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;
           attribute any itemValue; 

           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute boolean draggable;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute <ref>HTMLMenuElement</ref>? contextMenu;
           attribute boolean spellcheck;
  void forceSpellCheck();

  readonly attribute DOMString? commandType;
  readonly attribute DOMString? commandLabel;
  readonly attribute DOMString? commandIcon;
  readonly attribute boolean? commandHidden;
  readonly attribute boolean? commandDisabled;
  readonly attribute boolean? commandChecked;

  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;
};
<ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;

interface HTMLUnknownElement : <ref>HTMLElement</ref> { };
interface HTMLHtmlElement : <ref>HTMLElement</ref> {};
interface HTMLHeadElement : <ref>HTMLElement</ref> {};
interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};
interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};
interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};
<ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};
interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
           attribute boolean scoped;
};
<ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};
interface HTMLBodyElement : <ref>HTMLElement</ref> {
};
<ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLHeadingElement : <ref>HTMLElement</ref> {};
interface HTMLParagraphElement : <ref>HTMLElement</ref> {};
interface HTMLHRElement : <ref>HTMLElement</ref> {};
interface HTMLPreElement : <ref>HTMLElement</ref> {};
interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};
interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};
interface HTMLUListElement : <ref>HTMLElement</ref> {};
interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};
interface HTMLDListElement : <ref>HTMLElement</ref> {};
interface HTMLDivElement : <ref>HTMLElement</ref> {};
interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};
<ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;
interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};
interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};
interface HTMLSpanElement : <ref>HTMLElement</ref> {};
interface HTMLBRElement : <ref>HTMLElement</ref> {};
interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};
[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};
interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute boolean seamless;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};
interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};
interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};
interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};
interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};
[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};
interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};
interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute <ref>TextTrackKind</ref> kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};
enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };
interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  readonly attribute Date startDate;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};
interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};
interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};

interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};
enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };
[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};
interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);

           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};
enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };
enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };
interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};
interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};
interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};
interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};
[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute object? track;
};

dictionary TrackEventInit : <ref>EventInit</ref> {
  object? track;
};
typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;

interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);
  boolean supportsContext(DOMString contextId, any... arguments);

  void setContext(<ref>RenderingContext</ref> context);
  <ref>CanvasProxy</ref> transferControlToProxy();

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};
interface CanvasProxy {
  void setContext(<ref>RenderingContext</ref> context);
};
<ref>CanvasProxy</ref> implements <ref>Transferable</ref>;
interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};
interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};
<ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;
interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
           attribute boolean sortable;
  void stopSorting();
};
interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};
interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};
interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};
interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};
interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};
interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
           attribute DOMString sorted;
  void sort();
};
interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};
[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter object (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};
interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};
interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};
interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};
interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute <ref>HTMLMenuElement</ref>? menu;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref> item(unsigned long index);
  object namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};
interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};
[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};
interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};
enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot;,
};
interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};
interface HTMLDetailsElement : <ref>HTMLElement</ref> {
           attribute boolean open;
};
interface HTMLMenuElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
};
interface HTMLMenuItemElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute <ref>HTMLElement</ref>? command;
};
[Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)]
interface RelatedEvent : <ref>Event</ref> {
  readonly attribute <ref>EventTarget</ref>? relatedTarget;
};

dictionary RelatedEventInit : <ref>EventInit</ref> {
  <ref>EventTarget</ref>? relatedTarget;
};
interface HTMLDialogElement : <ref>HTMLElement</ref> {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void close(optional DOMString returnValue);
};
[NamedPropertiesObject]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();
  any showModalDialog(DOMString url, optional any argument);


};
<ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;
<ref>Window</ref> implements <ref>WindowEventHandlers</ref>;
interface BarProp {
           attribute boolean visible;
};
interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};
[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};
<ref>Location</ref> implements <ref>URLUtils</ref>;
[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};

dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};
[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};

dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};
[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};
interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};
interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};
[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};
[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);
typedef <ref>EventHandlerNonNull</ref>? EventHandler;
[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column);
typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;
[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> onclose;
           attribute <ref>EventHandler</ref> oncontextmenu;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondrag;
           attribute <ref>EventHandler</ref> ondragend;
           attribute <ref>EventHandler</ref> ondragenter;
           attribute <ref>EventHandler</ref> ondragexit;
           attribute <ref>EventHandler</ref> ondragleave;
           attribute <ref>EventHandler</ref> ondragover;
           attribute <ref>EventHandler</ref> ondragstart;
           attribute <ref>EventHandler</ref> ondrop;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onsort;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};

[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>EventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onfullscreenchange;
           attribute <ref>EventHandler</ref> onfullscreenerror;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};
[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};
<ref>Window</ref> implements <ref>WindowBase64</ref>;
[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};
<ref>Window</ref> implements <ref>WindowTimers</ref>;
[NoInterfaceObject] interface WindowModal {
  readonly attribute any dialogArguments;
           attribute DOMString returnValue;
};
interface Navigator {
};
<ref>Navigator</ref> implements <ref>NavigatorID</ref>;
<ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;
<ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;
<ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;
<ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;
[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString userAgent;

  readonly attribute DOMString product; 
};
[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};
[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};
[NoInterfaceObject]
interface NavigatorStorageUtils {
  void yieldForStorageUpdates();
};
interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};
interface ImageBitmap {
};

callback ImageBitmapCallback = void (<ref>ImageBitmap</ref> image);

typedef (<ref>HTMLImageElement</ref> or
         <ref>HTMLVideoElement</ref> or
         <ref>HTMLCanvasElement</ref> or
         <ref>Blob</ref> or
         <ref>ImageData</ref> or
         <ref>CanvasRenderingContext2D</ref> or
         <ref>ImageBitmap</ref>) ImageBitmapSource;

[NoInterfaceObject]
interface ImageBitmapFactories {
  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);
};
<ref>Window</ref> implements <ref>ImageBitmapFactories</ref>;
<ref>WorkerGlobalScope</ref> implements <ref>ImageBitmapFactories</ref>;
interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute <ref>DataTransferItemList</ref> items;

  void setDragImage(<ref>Element</ref> image, long x, long y);

  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute <ref>FileList</ref> files;
};
interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter <ref>DataTransferItem</ref> (unsigned long index);
  void remove(unsigned long index);
  void clear();

  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);
  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);
};
interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(<ref>FunctionStringCallback</ref>? _callback);
  <ref>File</ref>? getAsFile();
};

[Callback, NoInterfaceObject]
interface FunctionStringCallback {
  void handleEvent(DOMString data);
};
[Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)]
interface DragEvent : <ref>MouseEvent</ref> {
  readonly attribute <ref>DataTransfer</ref>? dataTransfer;
};

dictionary DragEventInit : <ref>EventInit</ref> {
  <ref>Window</ref>? view = null;
  long detail = 0;
  long screenX = 0;
  long screenY = 0;
  long clientX = 0;
  long clientY = 0;
  boolean ctrlKey = false;
  boolean shiftKey = false;
  boolean altKey = false;
  boolean metaKey = false;
  unsigned short button = 0;
  unsigned short buttons = 0;
  <ref>EventTarget</ref>? relatedTarget = null;
  <ref>DataTransfer</ref>? dataTransfer;
};
interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};
interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};
interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};
<ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};
partial interface HTMLAreaElement {
           attribute boolean noHref;
};
partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};
partial interface HTMLBRElement {
           attribute DOMString clear;
};
partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};
partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};
interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};
partial interface HTMLDivElement {
           attribute DOMString align;
};
partial interface HTMLDListElement {
           attribute boolean compact;
};
partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};
interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};
partial interface HTMLHeadingElement {
           attribute DOMString align;
};
partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};
partial interface HTMLHtmlElement {
           attribute DOMString version;
};
partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};
partial interface HTMLLegendElement {
           attribute DOMString align;
};
partial interface HTMLLIElement {
           attribute DOMString type;
};
partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};
partial interface HTMLMenuElement {
           attribute boolean compact;
};
partial interface HTMLMetaElement {
           attribute DOMString scheme;
};
partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLOListElement {
           attribute boolean compact;
};
partial interface HTMLParagraphElement {
           attribute DOMString align;
};
partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};
partial interface HTMLPreElement {
           attribute long width;
};
partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};
partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};
partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};
partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};
partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};
partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();

  readonly attribute <ref>HTMLAllCollection</ref> all;
};</webidl>
  <Interface name="HTMLAllCollection" id="::HTMLAllCollection">
    <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation name="item" id="::HTMLAllCollection::item">
      <webidl>  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLAllCollection::namedItem">
      <webidl>  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="tags" id="::HTMLAllCollection::tags">
      <webidl>  <ref>HTMLAllCollection</ref> tags(DOMString tagName);</webidl>
      <Type name="HTMLAllCollection"/>
      <ArgumentList>
        <Argument name="tagName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLFormControlsCollection" id="::HTMLFormControlsCollection">
    <webidl>interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLFormControlsCollection::namedItem">
      <webidl>  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="RadioNodeList"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="RadioNodeList" id="::RadioNodeList">
    <webidl>interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="NodeList"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::RadioNodeList::value">
      <webidl>          attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionsCollection" id="::HTMLOptionsCollection">
    <webidl>interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name); 
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Attribute name="length" id="::HTMLOptionsCollection::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLOptionsCollection::namedItem">
      <webidl>  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLOptionElement"/>
        <Type name="HTMLOptGroupElement"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLOptionsCollection::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLOptionsCollection::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="selectedIndex" id="::HTMLOptionsCollection::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="DOMStringMap" id="::DOMStringMap">
    <webidl>interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};</webidl>
    <Operation getter="getter">
      <webidl>  getter DOMString (DOMString name);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (DOMString name, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation deleter="deleter">
      <webidl>  deleter void (DOMString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DOMElementMap" id="::DOMElementMap">
    <webidl>interface DOMElementMap {
  getter <ref>Element</ref> (DOMString name);
  setter creator void (DOMString name, <ref>Element</ref> value);
  deleter void (DOMString name);
};</webidl>
    <Operation getter="getter">
      <webidl>  getter <ref>Element</ref> (DOMString name);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (DOMString name, <ref>Element</ref> value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type name="Element"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation deleter="deleter">
      <webidl>  deleter void (DOMString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Transferable" id="::Transferable">
    <webidl>[NoInterfaceObject]
interface Transferable { };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
  </Interface>
  <Callback name="FileCallback" id="::FileCallback">
    <webidl>callback FileCallback = void (<ref>File</ref> file);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="file">
        <Type name="File"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Enum name="DocumentReadyState" id="::DocumentReadyState">
    <webidl>enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };</webidl>
    <EnumValue stringvalue="loading">
      <webidl> &quot;loading</webidl>
    </EnumValue>
    <EnumValue stringvalue="interactive">
      <webidl> &quot;interactive</webidl>
    </EnumValue>
    <EnumValue stringvalue="complete">
      <webidl> &quot;complete</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);
  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;); 
  readonly attribute <ref>DOMElementMap</ref> cssElementMap;
  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);
  readonly attribute <ref>HTMLCollection</ref> commands;

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="location" id="::Document::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location" nullable="nullable"/>
    </Attribute>
    <Attribute name="domain" id="::Document::domain">
      <webidl>           attribute DOMString domain;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="referrer" id="::Document::referrer">
      <webidl>  readonly attribute DOMString referrer;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cookie" id="::Document::cookie">
      <webidl>           attribute DOMString cookie;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="lastModified" id="::Document::lastModified">
      <webidl>  readonly attribute DOMString lastModified;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="readyState" id="::Document::readyState">
      <webidl>  readonly attribute <ref>DocumentReadyState</ref> readyState;</webidl>
      <Type name="DocumentReadyState"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="title" id="::Document::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dir" id="::Document::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="body" id="::Document::body">
      <webidl>           attribute <ref>HTMLElement</ref>? body;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="head" id="::Document::head">
      <webidl>  readonly attribute <ref>HTMLHeadElement</ref>? head;</webidl>
      <Type name="HTMLHeadElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="images" id="::Document::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="embeds" id="::Document::embeds">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> embeds;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="plugins" id="::Document::plugins">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> plugins;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="links" id="::Document::links">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> links;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="forms" id="::Document::forms">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> forms;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="scripts" id="::Document::scripts">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> scripts;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="getElementsByName" id="::Document::getElementsByName">
      <webidl>  <ref>NodeList</ref> getElementsByName(DOMString elementName);</webidl>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument name="elementName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getItems" id="::Document::getItems">
      <webidl>  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;);</webidl>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument optional="optional" name="typeNames" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="cssElementMap" id="::Document::cssElementMap">
      <webidl>  readonly attribute <ref>DOMElementMap</ref> cssElementMap;</webidl>
      <Type name="DOMElementMap"/>
    </Attribute>
    <Attribute readonly="readonly" name="currentScript" id="::Document::currentScript">
      <webidl>  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;</webidl>
      <Type name="HTMLScriptElement" nullable="nullable"/>
    </Attribute>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</webidl>
      <Type name="Document"/>
      <ArgumentList>
        <Argument optional="optional" name="type" stringvalue="text/html">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="features">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::Document::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="write" id="::Document::write">
      <webidl>  void write(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="writeln" id="::Document::writeln">
      <webidl>  void writeln(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="defaultView" id="::Document::defaultView">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? defaultView;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="activeElement" id="::Document::activeElement">
      <webidl>  readonly attribute <ref>Element</ref>? activeElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="hasFocus" id="::Document::hasFocus">
      <webidl>  boolean hasFocus();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="designMode" id="::Document::designMode">
      <webidl>           attribute DOMString designMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="execCommand" id="::Document::execCommand">
      <webidl>  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="showUI" value="false">
          <Type type="boolean"/>
        </Argument>
        <Argument optional="optional" name="value" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandEnabled" id="::Document::queryCommandEnabled">
      <webidl>  boolean queryCommandEnabled(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandIndeterm" id="::Document::queryCommandIndeterm">
      <webidl>  boolean queryCommandIndeterm(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandState" id="::Document::queryCommandState">
      <webidl>  boolean queryCommandState(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandSupported" id="::Document::queryCommandSupported">
      <webidl>  boolean queryCommandSupported(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandValue" id="::Document::queryCommandValue">
      <webidl>  DOMString queryCommandValue(DOMString commandId);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="commands" id="::Document::commands">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> commands;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="onreadystatechange" id="::Document::onreadystatechange">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Implements name1="Document" name2="GlobalEventHandlers">
    <webidl><ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="XMLDocument" partial="partial" id="::XMLDocument">
    <webidl>partial interface XMLDocument {
  boolean load(DOMString url);
};</webidl>
    <Operation name="load" id="::XMLDocument::load">
      <webidl>  boolean load(DOMString url);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLElement" id="::HTMLElement">
    <webidl>interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;

           attribute boolean itemScope;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;
           attribute DOMString itemId;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;
  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;
           attribute any itemValue; 

           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute boolean draggable;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute <ref>HTMLMenuElement</ref>? contextMenu;
           attribute boolean spellcheck;
  void forceSpellCheck();

  readonly attribute DOMString? commandType;
  readonly attribute DOMString? commandLabel;
  readonly attribute DOMString? commandIcon;
  readonly attribute boolean? commandHidden;
  readonly attribute boolean? commandDisabled;
  readonly attribute boolean? commandChecked;

  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;
};</webidl>
    <InterfaceInheritance>
      <Name name="Element"/>
    </InterfaceInheritance>
    <Attribute name="title" id="::HTMLElement::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lang" id="::HTMLElement::lang">
      <webidl>           attribute DOMString lang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="translate" id="::HTMLElement::translate">
      <webidl>           attribute boolean translate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dir" id="::HTMLElement::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="dataset" id="::HTMLElement::dataset">
      <webidl>  readonly attribute <ref>DOMStringMap</ref> dataset;</webidl>
      <Type name="DOMStringMap"/>
    </Attribute>
    <Attribute name="itemScope" id="::HTMLElement::itemScope">
      <webidl>           attribute boolean itemScope;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemType" id="::HTMLElement::itemType">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="itemId" id="::HTMLElement::itemId">
      <webidl>           attribute DOMString itemId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemRef" id="::HTMLElement::itemRef">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemProp" id="::HTMLElement::itemProp">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="properties" id="::HTMLElement::properties">
      <webidl>  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;</webidl>
      <Type name="HTMLPropertiesCollection"/>
    </Attribute>
    <Attribute name="itemValue" id="::HTMLElement::itemValue">
      <webidl>           attribute any itemValue;</webidl>
      <Type type="any"/>
    </Attribute>
    <Attribute name="hidden" id="::HTMLElement::hidden">
      <webidl>           attribute boolean hidden;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="click" id="::HTMLElement::click">
      <webidl>  void click();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tabIndex" id="::HTMLElement::tabIndex">
      <webidl>           attribute long tabIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation name="focus" id="::HTMLElement::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::HTMLElement::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="accessKey" id="::HTMLElement::accessKey">
      <webidl>           attribute DOMString accessKey;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="accessKeyLabel" id="::HTMLElement::accessKeyLabel">
      <webidl>  readonly attribute DOMString accessKeyLabel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="draggable" id="::HTMLElement::draggable">
      <webidl>           attribute boolean draggable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="dropzone" id="::HTMLElement::dropzone">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="contentEditable" id="::HTMLElement::contentEditable">
      <webidl>           attribute DOMString contentEditable;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="isContentEditable" id="::HTMLElement::isContentEditable">
      <webidl>  readonly attribute boolean isContentEditable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="contextMenu" id="::HTMLElement::contextMenu">
      <webidl>           attribute <ref>HTMLMenuElement</ref>? contextMenu;</webidl>
      <Type name="HTMLMenuElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="spellcheck" id="::HTMLElement::spellcheck">
      <webidl>           attribute boolean spellcheck;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="forceSpellCheck" id="::HTMLElement::forceSpellCheck">
      <webidl>  void forceSpellCheck();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="commandType" id="::HTMLElement::commandType">
      <webidl>  readonly attribute DOMString? commandType;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandLabel" id="::HTMLElement::commandLabel">
      <webidl>  readonly attribute DOMString? commandLabel;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandIcon" id="::HTMLElement::commandIcon">
      <webidl>  readonly attribute DOMString? commandIcon;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandHidden" id="::HTMLElement::commandHidden">
      <webidl>  readonly attribute boolean? commandHidden;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandDisabled" id="::HTMLElement::commandDisabled">
      <webidl>  readonly attribute boolean? commandDisabled;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandChecked" id="::HTMLElement::commandChecked">
      <webidl>  readonly attribute boolean? commandChecked;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="style" id="::HTMLElement::style">
      <webidl>  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="cssText">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="CSSStyleDeclaration"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLElement" name2="GlobalEventHandlers">
    <webidl><ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLUnknownElement" id="::HTMLUnknownElement">
    <webidl>interface HTMLUnknownElement : <ref>HTMLElement</ref> { };</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHtmlElement" id="::HTMLHtmlElement">
    <webidl>interface HTMLHtmlElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHeadElement" id="::HTMLHeadElement">
    <webidl>interface HTMLHeadElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTitleElement" id="::HTMLTitleElement">
    <webidl>interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="text" id="::HTMLTitleElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBaseElement" id="::HTMLBaseElement">
    <webidl>interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="href" id="::HTMLBaseElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLBaseElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" id="::HTMLLinkElement">
    <webidl>interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLLinkElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="href" id="::HTMLLinkElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLLinkElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLLinkElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLLinkElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="media" id="::HTMLLinkElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLLinkElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLLinkElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="sizes" id="::HTMLLinkElement::sizes">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLLinkElement" name2="LinkStyle">
    <webidl><ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLMetaElement" id="::HTMLMetaElement">
    <webidl>interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMetaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="httpEquiv" id="::HTMLMetaElement::httpEquiv">
      <webidl>           attribute DOMString httpEquiv;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="content" id="::HTMLMetaElement::content">
      <webidl>           attribute DOMString content;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLStyleElement" id="::HTMLStyleElement">
    <webidl>interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
           attribute boolean scoped;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLStyleElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="media" id="::HTMLStyleElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLStyleElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scoped" id="::HTMLStyleElement::scoped">
      <webidl>           attribute boolean scoped;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLStyleElement" name2="LinkStyle">
    <webidl><ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLScriptElement" id="::HTMLScriptElement">
    <webidl>interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLScriptElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLScriptElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLScriptElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="async" id="::HTMLScriptElement::async">
      <webidl>           attribute boolean async;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defer" id="::HTMLScriptElement::defer">
      <webidl>           attribute boolean defer;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLScriptElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLScriptElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBodyElement" id="::HTMLBodyElement">
    <webidl>interface HTMLBodyElement : <ref>HTMLElement</ref> {
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Implements name1="HTMLBodyElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLHeadingElement" id="::HTMLHeadingElement">
    <webidl>interface HTMLHeadingElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLParagraphElement" id="::HTMLParagraphElement">
    <webidl>interface HTMLParagraphElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHRElement" id="::HTMLHRElement">
    <webidl>interface HTMLHRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLPreElement" id="::HTMLPreElement">
    <webidl>interface HTMLPreElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLQuoteElement" id="::HTMLQuoteElement">
    <webidl>interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLQuoteElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" id="::HTMLOListElement">
    <webidl>interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="reversed" id="::HTMLOListElement::reversed">
      <webidl>           attribute boolean reversed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="start" id="::HTMLOListElement::start">
      <webidl>           attribute long start;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="type" id="::HTMLOListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" id="::HTMLUListElement">
    <webidl>interface HTMLUListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLLIElement" id="::HTMLLIElement">
    <webidl>interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLLIElement::value">
      <webidl>           attribute long value;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" id="::HTMLDListElement">
    <webidl>interface HTMLDListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLDivElement" id="::HTMLDivElement">
    <webidl>interface HTMLDivElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLAnchorElement" id="::HTMLAnchorElement">
    <webidl>interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="target" id="::HTMLAnchorElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAnchorElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAnchorElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLAnchorElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAnchorElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAnchorElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLAnchorElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAnchorElement" name2="URLUtils">
    <webidl><ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLDataElement" id="::HTMLDataElement">
    <webidl>interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLDataElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTimeElement" id="::HTMLTimeElement">
    <webidl>interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="dateTime" id="::HTMLTimeElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSpanElement" id="::HTMLSpanElement">
    <webidl>interface HTMLSpanElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLBRElement" id="::HTMLBRElement">
    <webidl>interface HTMLBRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLModElement" id="::HTMLModElement">
    <webidl>interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLModElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dateTime" id="::HTMLModElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" id="::HTMLImageElement">
    <webidl>[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Image">
        <webidl>NamedConstructor=Image(optional unsigned long width, optional unsigned long height)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="width">
            <Type type="unsigned long"/>
          </Argument>
          <Argument optional="optional" name="height">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLImageElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLImageElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLImageElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLImageElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="isMap" id="::HTMLImageElement::isMap">
      <webidl>           attribute boolean isMap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="width" id="::HTMLImageElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLImageElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="naturalWidth" id="::HTMLImageElement::naturalWidth">
      <webidl>  readonly attribute unsigned long naturalWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="naturalHeight" id="::HTMLImageElement::naturalHeight">
      <webidl>  readonly attribute unsigned long naturalHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="complete" id="::HTMLImageElement::complete">
      <webidl>  readonly attribute boolean complete;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" id="::HTMLIFrameElement">
    <webidl>interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute boolean seamless;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLIFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srcdoc" id="::HTMLIFrameElement::srcdoc">
      <webidl>           attribute DOMString srcdoc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLIFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="sandbox" id="::HTMLIFrameElement::sandbox">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="seamless" id="::HTMLIFrameElement::seamless">
      <webidl>           attribute boolean seamless;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="allowFullscreen" id="::HTMLIFrameElement::allowFullscreen">
      <webidl>           attribute boolean allowFullscreen;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="width" id="::HTMLIFrameElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLIFrameElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLIFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLIFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" id="::HTMLEmbedElement">
    <webidl>interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLEmbedElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLEmbedElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLEmbedElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLEmbedElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLObjectElement" id="::HTMLObjectElement">
    <webidl>interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="data" id="::HTMLObjectElement::data">
      <webidl>           attribute DOMString data;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLObjectElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="typeMustMatch" id="::HTMLObjectElement::typeMustMatch">
      <webidl>           attribute boolean typeMustMatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLObjectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLObjectElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLObjectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="width" id="::HTMLObjectElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLObjectElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLObjectElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLObjectElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLObjectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLObjectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLObjectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLObjectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLObjectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLParamElement" id="::HTMLParamElement">
    <webidl>interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLParamElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLParamElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLVideoElement" id="::HTMLVideoElement">
    <webidl>interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLVideoElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLVideoElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoWidth" id="::HTMLVideoElement::videoWidth">
      <webidl>  readonly attribute unsigned long videoWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoHeight" id="::HTMLVideoElement::videoHeight">
      <webidl>  readonly attribute unsigned long videoHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="poster" id="::HTMLVideoElement::poster">
      <webidl>           attribute DOMString poster;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAudioElement" id="::HTMLAudioElement">
    <webidl>[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Audio">
        <webidl>NamedConstructor=Audio(optional DOMString src)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="src">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLSourceElement" id="::HTMLSourceElement">
    <webidl>interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLSourceElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLSourceElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="media" id="::HTMLSourceElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTrackElement" id="::HTMLTrackElement">
    <webidl>interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute <ref>TextTrackKind</ref> kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="kind" id="::HTMLTrackElement::kind">
      <webidl>           attribute <ref>TextTrackKind</ref> kind;</webidl>
      <Type name="TextTrackKind"/>
    </Attribute>
    <Attribute name="src" id="::HTMLTrackElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srclang" id="::HTMLTrackElement::srclang">
      <webidl>           attribute DOMString srclang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLTrackElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="default" id="::HTMLTrackElement::default">
      <webidl>           attribute boolean default;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Const name="NONE" value="0" id="::HTMLTrackElement::NONE">
      <webidl>  const unsigned short NONE = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADING" value="1" id="::HTMLTrackElement::LOADING">
      <webidl>  const unsigned short LOADING = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADED" value="2" id="::HTMLTrackElement::LOADED">
      <webidl>  const unsigned short LOADED = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ERROR" value="3" id="::HTMLTrackElement::ERROR">
      <webidl>  const unsigned short ERROR = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::HTMLTrackElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="track" id="::HTMLTrackElement::track">
      <webidl>  readonly attribute <ref>TextTrack</ref> track;</webidl>
      <Type name="TextTrack"/>
    </Attribute>
  </Interface>
  <Enum name="CanPlayTypeEnum" id="::CanPlayTypeEnum">
    <webidl>enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };</webidl>
    <EnumValue stringvalue="">
      <webidl> &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="maybe">
      <webidl> &quot;maybe</webidl>
    </EnumValue>
    <EnumValue stringvalue="probably">
      <webidl> &quot;probably</webidl>
    </EnumValue>
  </Enum>
  <Interface name="HTMLMediaElement" id="::HTMLMediaElement">
    <webidl>interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  readonly attribute Date startDate;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="error" id="::HTMLMediaElement::error">
      <webidl>  readonly attribute <ref>MediaError</ref>? error;</webidl>
      <Type name="MediaError" nullable="nullable"/>
    </Attribute>
    <Attribute name="src" id="::HTMLMediaElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="currentSrc" id="::HTMLMediaElement::currentSrc">
      <webidl>  readonly attribute DOMString currentSrc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLMediaElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Const name="NETWORK_EMPTY" value="0" id="::HTMLMediaElement::NETWORK_EMPTY">
      <webidl>  const unsigned short NETWORK_EMPTY = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_IDLE" value="1" id="::HTMLMediaElement::NETWORK_IDLE">
      <webidl>  const unsigned short NETWORK_IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_LOADING" value="2" id="::HTMLMediaElement::NETWORK_LOADING">
      <webidl>  const unsigned short NETWORK_LOADING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_NO_SOURCE" value="3" id="::HTMLMediaElement::NETWORK_NO_SOURCE">
      <webidl>  const unsigned short NETWORK_NO_SOURCE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="networkState" id="::HTMLMediaElement::networkState">
      <webidl>  readonly attribute unsigned short networkState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="preload" id="::HTMLMediaElement::preload">
      <webidl>           attribute DOMString preload;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="buffered" id="::HTMLMediaElement::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="load" id="::HTMLMediaElement::load">
      <webidl>  void load();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="canPlayType" id="::HTMLMediaElement::canPlayType">
      <webidl>  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);</webidl>
      <Type name="CanPlayTypeEnum"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="HAVE_NOTHING" value="0" id="::HTMLMediaElement::HAVE_NOTHING">
      <webidl>  const unsigned short HAVE_NOTHING = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_METADATA" value="1" id="::HTMLMediaElement::HAVE_METADATA">
      <webidl>  const unsigned short HAVE_METADATA = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_CURRENT_DATA" value="2" id="::HTMLMediaElement::HAVE_CURRENT_DATA">
      <webidl>  const unsigned short HAVE_CURRENT_DATA = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_FUTURE_DATA" value="3" id="::HTMLMediaElement::HAVE_FUTURE_DATA">
      <webidl>  const unsigned short HAVE_FUTURE_DATA = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_ENOUGH_DATA" value="4" id="::HTMLMediaElement::HAVE_ENOUGH_DATA">
      <webidl>  const unsigned short HAVE_ENOUGH_DATA = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::HTMLMediaElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="seeking" id="::HTMLMediaElement::seeking">
      <webidl>  readonly attribute boolean seeking;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="currentTime" id="::HTMLMediaElement::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Operation name="fastSeek" id="::HTMLMediaElement::fastSeek">
      <webidl>  void fastSeek(double time);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="time">
          <Type type="double"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="duration" id="::HTMLMediaElement::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute readonly="readonly" name="startDate" id="::HTMLMediaElement::startDate">
      <webidl>  readonly attribute Date startDate;</webidl>
      <Type type="Date"/>
    </Attribute>
    <Attribute readonly="readonly" name="paused" id="::HTMLMediaElement::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultPlaybackRate" id="::HTMLMediaElement::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::HTMLMediaElement::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="played" id="::HTMLMediaElement::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="seekable" id="::HTMLMediaElement::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="ended" id="::HTMLMediaElement::ended">
      <webidl>  readonly attribute boolean ended;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="autoplay" id="::HTMLMediaElement::autoplay">
      <webidl>           attribute boolean autoplay;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMediaElement::loop">
      <webidl>           attribute boolean loop;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="play" id="::HTMLMediaElement::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pause" id="::HTMLMediaElement::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="mediaGroup" id="::HTMLMediaElement::mediaGroup">
      <webidl>           attribute DOMString mediaGroup;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="controller" id="::HTMLMediaElement::controller">
      <webidl>           attribute <ref>MediaController</ref>? controller;</webidl>
      <Type name="MediaController" nullable="nullable"/>
    </Attribute>
    <Attribute name="controls" id="::HTMLMediaElement::controls">
      <webidl>           attribute boolean controls;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="volume" id="::HTMLMediaElement::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::HTMLMediaElement::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultMuted" id="::HTMLMediaElement::defaultMuted">
      <webidl>           attribute boolean defaultMuted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="audioTracks" id="::HTMLMediaElement::audioTracks">
      <webidl>  readonly attribute <ref>AudioTrackList</ref> audioTracks;</webidl>
      <Type name="AudioTrackList"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoTracks" id="::HTMLMediaElement::videoTracks">
      <webidl>  readonly attribute <ref>VideoTrackList</ref> videoTracks;</webidl>
      <Type name="VideoTrackList"/>
    </Attribute>
    <Attribute readonly="readonly" name="textTracks" id="::HTMLMediaElement::textTracks">
      <webidl>  readonly attribute <ref>TextTrackList</ref> textTracks;</webidl>
      <Type name="TextTrackList"/>
    </Attribute>
    <Operation name="addTextTrack" id="::HTMLMediaElement::addTextTrack">
      <webidl>  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="kind">
          <Type name="TextTrackKind"/>
        </Argument>
        <Argument optional="optional" name="label" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="language" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MediaError" id="::MediaError">
    <webidl>interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};</webidl>
    <Const name="MEDIA_ERR_ABORTED" value="1" id="::MediaError::MEDIA_ERR_ABORTED">
      <webidl>  const unsigned short MEDIA_ERR_ABORTED = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_NETWORK" value="2" id="::MediaError::MEDIA_ERR_NETWORK">
      <webidl>  const unsigned short MEDIA_ERR_NETWORK = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_DECODE" value="3" id="::MediaError::MEDIA_ERR_DECODE">
      <webidl>  const unsigned short MEDIA_ERR_DECODE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_SRC_NOT_SUPPORTED" value="4" id="::MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED">
      <webidl>  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="code" id="::MediaError::code">
      <webidl>  readonly attribute unsigned short code;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrackList" id="::AudioTrackList">
    <webidl>interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::AudioTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>AudioTrack</ref> (unsigned long index);</webidl>
      <Type name="AudioTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::AudioTrackList::getTrackById">
      <webidl>  <ref>AudioTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="AudioTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onchange" id="::AudioTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::AudioTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::AudioTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrack" id="::AudioTrack">
    <webidl>interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};</webidl>
    <Attribute readonly="readonly" name="id" id="::AudioTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="kind" id="::AudioTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::AudioTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::AudioTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enabled" id="::AudioTrack::enabled">
      <webidl>           attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrackList" id="::VideoTrackList">
    <webidl>interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::VideoTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>VideoTrack</ref> (unsigned long index);</webidl>
      <Type name="VideoTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::VideoTrackList::getTrackById">
      <webidl>  <ref>VideoTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="VideoTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="selectedIndex" id="::VideoTrackList::selectedIndex">
      <webidl>  readonly attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="onchange" id="::VideoTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::VideoTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::VideoTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrack" id="::VideoTrack">
    <webidl>interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};</webidl>
    <Attribute readonly="readonly" name="id" id="::VideoTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="kind" id="::VideoTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::VideoTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::VideoTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="selected" id="::VideoTrack::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Enum name="MediaControllerPlaybackState" id="::MediaControllerPlaybackState">
    <webidl>enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };</webidl>
    <EnumValue stringvalue="waiting">
      <webidl> &quot;waiting</webidl>
    </EnumValue>
    <EnumValue stringvalue="playing">
      <webidl> &quot;playing</webidl>
    </EnumValue>
    <EnumValue stringvalue="ended">
      <webidl> &quot;ended</webidl>
    </EnumValue>
  </Enum>
  <Interface name="MediaController" id="::MediaController">
    <webidl>[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="readyState" id="::MediaController::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="buffered" id="::MediaController::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="seekable" id="::MediaController::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="duration" id="::MediaController::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="currentTime" id="::MediaController::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="paused" id="::MediaController::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="playbackState" id="::MediaController::playbackState">
      <webidl>  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;</webidl>
      <Type name="MediaControllerPlaybackState"/>
    </Attribute>
    <Attribute readonly="readonly" name="played" id="::MediaController::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="pause" id="::MediaController::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="unpause" id="::MediaController::unpause">
      <webidl>  void unpause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="play" id="::MediaController::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="defaultPlaybackRate" id="::MediaController::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::MediaController::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="volume" id="::MediaController::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::MediaController::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onemptied" id="::MediaController::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::MediaController::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::MediaController::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::MediaController::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::MediaController::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::MediaController::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::MediaController::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::MediaController::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::MediaController::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::MediaController::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::MediaController::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::MediaController::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::MediaController::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::MediaController::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackList" id="::TextTrackList">
    <webidl>interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);

           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::TextTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrack</ref> (unsigned long index);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onaddtrack" id="::TextTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::TextTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Enum name="TextTrackMode" id="::TextTrackMode">
    <webidl>enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };</webidl>
    <EnumValue stringvalue="disabled">
      <webidl> &quot;disabled</webidl>
    </EnumValue>
    <EnumValue stringvalue="hidden">
      <webidl>  &quot;hidden</webidl>
    </EnumValue>
    <EnumValue stringvalue="showing">
      <webidl>  &quot;showing</webidl>
    </EnumValue>
  </Enum>
  <Enum name="TextTrackKind" id="::TextTrackKind">
    <webidl>enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };</webidl>
    <EnumValue stringvalue="subtitles">
      <webidl> &quot;subtitles</webidl>
    </EnumValue>
    <EnumValue stringvalue="captions">
      <webidl>  &quot;captions</webidl>
    </EnumValue>
    <EnumValue stringvalue="descriptions">
      <webidl>  &quot;descriptions</webidl>
    </EnumValue>
    <EnumValue stringvalue="chapters">
      <webidl>  &quot;chapters</webidl>
    </EnumValue>
    <EnumValue stringvalue="metadata">
      <webidl>  &quot;metadata</webidl>
    </EnumValue>
  </Enum>
  <Interface name="TextTrack" id="::TextTrack">
    <webidl>interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="kind" id="::TextTrack::kind">
      <webidl>  readonly attribute <ref>TextTrackKind</ref> kind;</webidl>
      <Type name="TextTrackKind"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::TextTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::TextTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="inBandMetadataTrackDispatchType" id="::TextTrack::inBandMetadataTrackDispatchType">
      <webidl>  readonly attribute DOMString inBandMetadataTrackDispatchType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="mode" id="::TextTrack::mode">
      <webidl>           attribute <ref>TextTrackMode</ref> mode;</webidl>
      <Type name="TextTrackMode"/>
    </Attribute>
    <Attribute readonly="readonly" name="cues" id="::TextTrack::cues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? cues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="activeCues" id="::TextTrack::activeCues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? activeCues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Operation name="addCue" id="::TextTrack::addCue">
      <webidl>  void addCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeCue" id="::TextTrack::removeCue">
      <webidl>  void removeCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="oncuechange" id="::TextTrack::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackCueList" id="::TextTrackCueList">
    <webidl>interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::TextTrackCueList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrackCue</ref> (unsigned long index);</webidl>
      <Type name="TextTrackCue"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getCueById" id="::TextTrackCueList::getCueById">
      <webidl>  <ref>TextTrackCue</ref>? getCueById(DOMString id);</webidl>
      <Type name="TextTrackCue" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TextTrackCue" id="::TextTrackCue">
    <webidl>interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="track" id="::TextTrackCue::track">
      <webidl>  readonly attribute <ref>TextTrack</ref>? track;</webidl>
      <Type name="TextTrack" nullable="nullable"/>
    </Attribute>
    <Attribute name="id" id="::TextTrackCue::id">
      <webidl>           attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="startTime" id="::TextTrackCue::startTime">
      <webidl>           attribute double startTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="endTime" id="::TextTrackCue::endTime">
      <webidl>           attribute double endTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="pauseOnExit" id="::TextTrackCue::pauseOnExit">
      <webidl>           attribute boolean pauseOnExit;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onenter" id="::TextTrackCue::onenter">
      <webidl>           attribute <ref>EventHandler</ref> onenter;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onexit" id="::TextTrackCue::onexit">
      <webidl>           attribute <ref>EventHandler</ref> onexit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TimeRanges" id="::TimeRanges">
    <webidl>interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::TimeRanges::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="start" id="::TimeRanges::start">
      <webidl>  double start(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="end" id="::TimeRanges::end">
      <webidl>  double end(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TrackEvent" id="::TrackEvent">
    <webidl>[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute object? track;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="TrackEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="track" id="::TrackEvent::track">
      <webidl>  readonly attribute object? track;</webidl>
      <Type type="object" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="TrackEventInit" id="::TrackEventInit">
    <webidl>dictionary TrackEventInit : <ref>EventInit</ref> {
  object? track;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="track" id="::TrackEventInit::track">
      <webidl>  object? track;</webidl>
      <Type type="object" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Typedef name="RenderingContext" id="::RenderingContext">
    <webidl>typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;</webidl>
    <Type type="union">
      <Type name="CanvasRenderingContext2D"/>
      <Type name="WebGLRenderingContext"/>
    </Type>
  </Typedef>
  <Interface name="HTMLCanvasElement" id="::HTMLCanvasElement">
    <webidl>interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);
  boolean supportsContext(DOMString contextId, any... arguments);

  void setContext(<ref>RenderingContext</ref> context);
  <ref>CanvasProxy</ref> transferControlToProxy();

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLCanvasElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLCanvasElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="getContext" id="::HTMLCanvasElement::getContext">
      <webidl>  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);</webidl>
      <Type name="RenderingContext" nullable="nullable"/>
      <ArgumentList>
        <Argument name="contextId">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="supportsContext" id="::HTMLCanvasElement::supportsContext">
      <webidl>  boolean supportsContext(DOMString contextId, any... arguments);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="contextId">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setContext" id="::HTMLCanvasElement::setContext">
      <webidl>  void setContext(<ref>RenderingContext</ref> context);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="context">
          <Type name="RenderingContext"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="transferControlToProxy" id="::HTMLCanvasElement::transferControlToProxy">
      <webidl>  <ref>CanvasProxy</ref> transferControlToProxy();</webidl>
      <Type name="CanvasProxy"/>
      <ArgumentList/>
    </Operation>
    <Operation name="toDataURL" id="::HTMLCanvasElement::toDataURL">
      <webidl>  DOMString toDataURL(optional DOMString type, any... arguments);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toBlob" id="::HTMLCanvasElement::toBlob">
      <webidl>  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="_callback">
          <Type name="FileCallback" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="CanvasProxy" id="::CanvasProxy">
    <webidl>interface CanvasProxy {
  void setContext(<ref>RenderingContext</ref> context);
};</webidl>
    <Operation name="setContext" id="::CanvasProxy::setContext">
      <webidl>  void setContext(<ref>RenderingContext</ref> context);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="context">
          <Type name="RenderingContext"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="CanvasProxy" name2="Transferable">
    <webidl><ref>CanvasProxy</ref> implements <ref>Transferable</ref>;</webidl>
  </Implements>
  <Interface name="HTMLMapElement" id="::HTMLMapElement">
    <webidl>interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMapElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="areas" id="::HTMLMapElement::areas">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> areas;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="images" id="::HTMLMapElement::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" id="::HTMLAreaElement">
    <webidl>interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLAreaElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="coords" id="::HTMLAreaElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAreaElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLAreaElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAreaElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAreaElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLAreaElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAreaElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAreaElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAreaElement" name2="URLUtils">
    <webidl><ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLTableElement" id="::HTMLTableElement">
    <webidl>interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
           attribute boolean sortable;
  void stopSorting();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="caption" id="::HTMLTableElement::caption">
      <webidl>           attribute <ref>HTMLTableCaptionElement</ref>? caption;</webidl>
      <Type name="HTMLTableCaptionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createCaption" id="::HTMLTableElement::createCaption">
      <webidl>  <ref>HTMLElement</ref> createCaption();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteCaption" id="::HTMLTableElement::deleteCaption">
      <webidl>  void deleteCaption();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tHead" id="::HTMLTableElement::tHead">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tHead;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTHead" id="::HTMLTableElement::createTHead">
      <webidl>  <ref>HTMLElement</ref> createTHead();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTHead" id="::HTMLTableElement::deleteTHead">
      <webidl>  void deleteTHead();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tFoot" id="::HTMLTableElement::tFoot">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tFoot;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTFoot" id="::HTMLTableElement::createTFoot">
      <webidl>  <ref>HTMLElement</ref> createTFoot();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTFoot" id="::HTMLTableElement::deleteTFoot">
      <webidl>  void deleteTFoot();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="tBodies" id="::HTMLTableElement::tBodies">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> tBodies;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="createTBody" id="::HTMLTableElement::createTBody">
      <webidl>  <ref>HTMLElement</ref> createTBody();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="rows" id="::HTMLTableElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="border" id="::HTMLTableElement::border">
      <webidl>           attribute DOMString border;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sortable" id="::HTMLTableElement::sortable">
      <webidl>           attribute boolean sortable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="stopSorting" id="::HTMLTableElement::stopSorting">
      <webidl>  void stopSorting();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLTableCaptionElement" id="::HTMLTableCaptionElement">
    <webidl>interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableColElement" id="::HTMLTableColElement">
    <webidl>interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="span" id="::HTMLTableColElement::span">
      <webidl>           attribute unsigned long span;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" id="::HTMLTableSectionElement">
    <webidl>interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="rows" id="::HTMLTableSectionElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableSectionElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableSectionElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableRowElement" id="::HTMLTableRowElement">
    <webidl>interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="rowIndex" id="::HTMLTableRowElement::rowIndex">
      <webidl>  readonly attribute long rowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="sectionRowIndex" id="::HTMLTableRowElement::sectionRowIndex">
      <webidl>  readonly attribute long sectionRowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="cells" id="::HTMLTableRowElement::cells">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> cells;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertCell" id="::HTMLTableRowElement::insertCell">
      <webidl>  <ref>HTMLElement</ref> insertCell(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteCell" id="::HTMLTableRowElement::deleteCell">
      <webidl>  void deleteCell(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableDataCellElement" id="::HTMLTableDataCellElement">
    <webidl>interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableHeaderCellElement" id="::HTMLTableHeaderCellElement">
    <webidl>interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
           attribute DOMString sorted;
  void sort();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
    <Attribute name="scope" id="::HTMLTableHeaderCellElement::scope">
      <webidl>           attribute DOMString scope;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="abbr" id="::HTMLTableHeaderCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sorted" id="::HTMLTableHeaderCellElement::sorted">
      <webidl>           attribute DOMString sorted;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="sort" id="::HTMLTableHeaderCellElement::sort">
      <webidl>  void sort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLTableCellElement" id="::HTMLTableCellElement">
    <webidl>interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="colSpan" id="::HTMLTableCellElement::colSpan">
      <webidl>           attribute unsigned long colSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="rowSpan" id="::HTMLTableCellElement::rowSpan">
      <webidl>           attribute unsigned long rowSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="headers" id="::HTMLTableCellElement::headers">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="cellIndex" id="::HTMLTableCellElement::cellIndex">
      <webidl>  readonly attribute long cellIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFormElement" id="::HTMLFormElement">
    <webidl>[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter object (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="acceptCharset" id="::HTMLFormElement::acceptCharset">
      <webidl>           attribute DOMString acceptCharset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="action" id="::HTMLFormElement::action">
      <webidl>           attribute DOMString action;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLFormElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enctype" id="::HTMLFormElement::enctype">
      <webidl>           attribute DOMString enctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="encoding" id="::HTMLFormElement::encoding">
      <webidl>           attribute DOMString encoding;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="method" id="::HTMLFormElement::method">
      <webidl>           attribute DOMString method;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFormElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noValidate" id="::HTMLFormElement::noValidate">
      <webidl>           attribute boolean noValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="target" id="::HTMLFormElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="elements" id="::HTMLFormElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="length" id="::HTMLFormElement::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>Element</ref> (unsigned long index);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="submit" id="::HTMLFormElement::submit">
      <webidl>  void submit();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="reset" id="::HTMLFormElement::reset">
      <webidl>  void reset();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="checkValidity" id="::HTMLFormElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLFieldSetElement" id="::HTMLFieldSetElement">
    <webidl>interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLFieldSetElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLFieldSetElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFieldSetElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLFieldSetElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="elements" id="::HTMLFieldSetElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLFieldSetElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLFieldSetElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLFieldSetElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLFieldSetElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLFieldSetElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLLegendElement" id="::HTMLLegendElement">
    <webidl>interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="form" id="::HTMLLegendElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLabelElement" id="::HTMLLabelElement">
    <webidl>interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="form" id="::HTMLLabelElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLLabelElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="control" id="::HTMLLabelElement::control">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? control;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" id="::HTMLInputElement">
    <webidl>interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="accept" id="::HTMLInputElement::accept">
      <webidl>           attribute DOMString accept;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLInputElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLInputElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLInputElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultChecked" id="::HTMLInputElement::defaultChecked">
      <webidl>           attribute boolean defaultChecked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="checked" id="::HTMLInputElement::checked">
      <webidl>           attribute boolean checked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLInputElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLInputElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLInputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="files" id="::HTMLInputElement::files">
      <webidl>  readonly attribute <ref>FileList</ref>? files;</webidl>
      <Type name="FileList" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLInputElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLInputElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLInputElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLInputElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLInputElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLInputElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="indeterminate" id="::HTMLInputElement::indeterminate">
      <webidl>           attribute boolean indeterminate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="inputMode" id="::HTMLInputElement::inputMode">
      <webidl>           attribute DOMString inputMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="list" id="::HTMLInputElement::list">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? list;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="max" id="::HTMLInputElement::max">
      <webidl>           attribute DOMString max;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLInputElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="min" id="::HTMLInputElement::min">
      <webidl>           attribute DOMString min;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLInputElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLInputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="pattern" id="::HTMLInputElement::pattern">
      <webidl>           attribute DOMString pattern;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLInputElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLInputElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLInputElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLInputElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="src" id="::HTMLInputElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="step" id="::HTMLInputElement::step">
      <webidl>           attribute DOMString step;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLInputElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLInputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLInputElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueAsDate" id="::HTMLInputElement::valueAsDate">
      <webidl>           attribute Date? valueAsDate;</webidl>
      <Type type="Date" nullable="nullable"/>
    </Attribute>
    <Attribute name="valueAsNumber" id="::HTMLInputElement::valueAsNumber">
      <webidl>           attribute unrestricted double valueAsNumber;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="width" id="::HTMLInputElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="stepUp" id="::HTMLInputElement::stepUp">
      <webidl>  void stepUp(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="stepDown" id="::HTMLInputElement::stepDown">
      <webidl>  void stepDown(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLInputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLInputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLInputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLInputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLInputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLInputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLInputElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLInputElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLInputElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLInputElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLInputElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLButtonElement" id="::HTMLButtonElement">
    <webidl>interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute <ref>HTMLMenuElement</ref>? menu;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLButtonElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLButtonElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLButtonElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLButtonElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLButtonElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLButtonElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLButtonElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLButtonElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLButtonElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLButtonElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLButtonElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="menu" id="::HTMLButtonElement::menu">
      <webidl>           attribute <ref>HTMLMenuElement</ref>? menu;</webidl>
      <Type name="HTMLMenuElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLButtonElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLButtonElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLButtonElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLButtonElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLButtonElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLButtonElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSelectElement" id="::HTMLSelectElement">
    <webidl>interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref> item(unsigned long index);
  object namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLSelectElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLSelectElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLSelectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLSelectElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLSelectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="required" id="::HTMLSelectElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLSelectElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLSelectElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="options" id="::HTMLSelectElement::options">
      <webidl>  readonly attribute <ref>HTMLOptionsCollection</ref> options;</webidl>
      <Type name="HTMLOptionsCollection"/>
    </Attribute>
    <Attribute name="length" id="::HTMLSelectElement::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::HTMLSelectElement::item">
      <webidl>  getter <ref>Element</ref> item(unsigned long index);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="namedItem" id="::HTMLSelectElement::namedItem">
      <webidl>  object namedItem(DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLSelectElement::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLSelectElement::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="selectedOptions" id="::HTMLSelectElement::selectedOptions">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> selectedOptions;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="selectedIndex" id="::HTMLSelectElement::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="value" id="::HTMLSelectElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLSelectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLSelectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLSelectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLSelectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLSelectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLSelectElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDataListElement" id="::HTMLDataListElement">
    <webidl>interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="options" id="::HTMLDataListElement::options">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> options;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptGroupElement" id="::HTMLOptGroupElement">
    <webidl>interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptGroupElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptGroupElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionElement" id="::HTMLOptionElement">
    <webidl>[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Option">
        <webidl>NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="text" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="value">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="defaultSelected" value="false">
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="selected" value="false">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptionElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLOptionElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptionElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultSelected" id="::HTMLOptionElement::defaultSelected">
      <webidl>           attribute boolean defaultSelected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="selected" id="::HTMLOptionElement::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOptionElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLOptionElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="index" id="::HTMLOptionElement::index">
      <webidl>  readonly attribute long index;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTextAreaElement" id="::HTMLTextAreaElement">
    <webidl>interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autocomplete" id="::HTMLTextAreaElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLTextAreaElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="cols" id="::HTMLTextAreaElement::cols">
      <webidl>           attribute unsigned long cols;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLTextAreaElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLTextAreaElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLTextAreaElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="inputMode" id="::HTMLTextAreaElement::inputMode">
      <webidl>           attribute DOMString inputMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLTextAreaElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLTextAreaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLTextAreaElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLTextAreaElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLTextAreaElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLTextAreaElement::rows">
      <webidl>           attribute unsigned long rows;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="wrap" id="::HTMLTextAreaElement::wrap">
      <webidl>           attribute DOMString wrap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLTextAreaElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLTextAreaElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLTextAreaElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="textLength" id="::HTMLTextAreaElement::textLength">
      <webidl>  readonly attribute unsigned long textLength;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLTextAreaElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLTextAreaElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLTextAreaElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLTextAreaElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLTextAreaElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLTextAreaElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLTextAreaElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLTextAreaElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLTextAreaElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLTextAreaElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLTextAreaElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLKeygenElement" id="::HTMLKeygenElement">
    <webidl>interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLKeygenElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="challenge" id="::HTMLKeygenElement::challenge">
      <webidl>           attribute DOMString challenge;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLKeygenElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLKeygenElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="keytype" id="::HTMLKeygenElement::keytype">
      <webidl>           attribute DOMString keytype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLKeygenElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLKeygenElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLKeygenElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLKeygenElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLKeygenElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLKeygenElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLKeygenElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLKeygenElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOutputElement" id="::HTMLOutputElement">
    <webidl>interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="htmlFor" id="::HTMLOutputElement::htmlFor">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLOutputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLOutputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLOutputElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLOutputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOutputElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLOutputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLOutputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLOutputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLOutputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLOutputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLOutputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLProgressElement" id="::HTMLProgressElement">
    <webidl>interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLProgressElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLProgressElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="position" id="::HTMLProgressElement::position">
      <webidl>  readonly attribute double position;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="labels" id="::HTMLProgressElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMeterElement" id="::HTMLMeterElement">
    <webidl>interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLMeterElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="min" id="::HTMLMeterElement::min">
      <webidl>           attribute double min;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLMeterElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="low" id="::HTMLMeterElement::low">
      <webidl>           attribute double low;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="high" id="::HTMLMeterElement::high">
      <webidl>           attribute double high;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="optimum" id="::HTMLMeterElement::optimum">
      <webidl>           attribute double optimum;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="labels" id="::HTMLMeterElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Enum name="SelectionMode" id="::SelectionMode">
    <webidl>enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot;,
};</webidl>
    <EnumValue stringvalue="select">
      <webidl>  &quot;select</webidl>
    </EnumValue>
    <EnumValue stringvalue="start">
      <webidl>  &quot;start</webidl>
    </EnumValue>
    <EnumValue stringvalue="end">
      <webidl>  &quot;end</webidl>
    </EnumValue>
    <EnumValue stringvalue="preserve">
      <webidl>  &quot;preserve</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ValidityState" id="::ValidityState">
    <webidl>interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};</webidl>
    <Attribute readonly="readonly" name="valueMissing" id="::ValidityState::valueMissing">
      <webidl>  readonly attribute boolean valueMissing;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="typeMismatch" id="::ValidityState::typeMismatch">
      <webidl>  readonly attribute boolean typeMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="patternMismatch" id="::ValidityState::patternMismatch">
      <webidl>  readonly attribute boolean patternMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="tooLong" id="::ValidityState::tooLong">
      <webidl>  readonly attribute boolean tooLong;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="rangeUnderflow" id="::ValidityState::rangeUnderflow">
      <webidl>  readonly attribute boolean rangeUnderflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="rangeOverflow" id="::ValidityState::rangeOverflow">
      <webidl>  readonly attribute boolean rangeOverflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="stepMismatch" id="::ValidityState::stepMismatch">
      <webidl>  readonly attribute boolean stepMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="badInput" id="::ValidityState::badInput">
      <webidl>  readonly attribute boolean badInput;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="customError" id="::ValidityState::customError">
      <webidl>  readonly attribute boolean customError;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="valid" id="::ValidityState::valid">
      <webidl>  readonly attribute boolean valid;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDetailsElement" id="::HTMLDetailsElement">
    <webidl>interface HTMLDetailsElement : <ref>HTMLElement</ref> {
           attribute boolean open;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="open" id="::HTMLDetailsElement::open">
      <webidl>           attribute boolean open;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuElement" id="::HTMLMenuElement">
    <webidl>interface HTMLMenuElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="type" id="::HTMLMenuElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLMenuElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuItemElement" id="::HTMLMenuItemElement">
    <webidl>interface HTMLMenuItemElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute <ref>HTMLElement</ref>? command;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="type" id="::HTMLMenuItemElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLMenuItemElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="icon" id="::HTMLMenuItemElement::icon">
      <webidl>           attribute DOMString icon;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLMenuItemElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="checked" id="::HTMLMenuItemElement::checked">
      <webidl>           attribute boolean checked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="radiogroup" id="::HTMLMenuItemElement::radiogroup">
      <webidl>           attribute DOMString radiogroup;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="default" id="::HTMLMenuItemElement::default">
      <webidl>           attribute boolean default;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="command" id="::HTMLMenuItemElement::command">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? command;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="RelatedEvent" id="::RelatedEvent">
    <webidl>[Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)]
interface RelatedEvent : <ref>Event</ref> {
  readonly attribute <ref>EventTarget</ref>? relatedTarget;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="RelatedEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="relatedTarget" id="::RelatedEvent::relatedTarget">
      <webidl>  readonly attribute <ref>EventTarget</ref>? relatedTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="RelatedEventInit" id="::RelatedEventInit">
    <webidl>dictionary RelatedEventInit : <ref>EventInit</ref> {
  <ref>EventTarget</ref>? relatedTarget;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="relatedTarget" id="::RelatedEventInit::relatedTarget">
      <webidl>  <ref>EventTarget</ref>? relatedTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HTMLDialogElement" id="::HTMLDialogElement">
    <webidl>interface HTMLDialogElement : <ref>HTMLElement</ref> {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void close(optional DOMString returnValue);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="open" id="::HTMLDialogElement::open">
      <webidl>           attribute boolean open;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="returnValue" id="::HTMLDialogElement::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="show" id="::HTMLDialogElement::show">
      <webidl>  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="anchor">
          <Type type="union">
            <Type name="MouseEvent"/>
            <Type name="Element"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="showModal" id="::HTMLDialogElement::showModal">
      <webidl>  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="anchor">
          <Type type="union">
            <Type name="MouseEvent"/>
            <Type name="Element"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::HTMLDialogElement::close">
      <webidl>  void close(optional DOMString returnValue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="returnValue">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Window" id="::Window">
    <webidl>[NamedPropertiesObject]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();
  any showModalDialog(DOMString url, optional any argument);


};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedPropertiesObject">
        <webidl>NamedPropertiesObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="window" id="::Window::window">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="self" id="::Window::self">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="document" id="::Window::document">
      <webidl>  [Unforgeable] readonly attribute <ref>Document</ref> document;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Document"/>
    </Attribute>
    <Attribute name="name" id="::Window::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="location" id="::Window::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location"/>
    </Attribute>
    <Attribute readonly="readonly" name="history" id="::Window::history">
      <webidl>  readonly attribute <ref>History</ref> history;</webidl>
      <Type name="History"/>
    </Attribute>
    <Attribute readonly="readonly" name="locationbar" id="::Window::locationbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="menubar" id="::Window::menubar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="personalbar" id="::Window::personalbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="scrollbars" id="::Window::scrollbars">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="statusbar" id="::Window::statusbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="toolbar" id="::Window::toolbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="status" id="::Window::status">
      <webidl>           attribute DOMString status;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="close" id="::Window::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stop" id="::Window::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="focus" id="::Window::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::Window::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="frames" id="::Window::frames">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="length" id="::Window::length">
      <webidl>  [Replaceable] readonly attribute unsigned long length;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="top" id="::Window::top">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="opener" id="::Window::opener">
      <webidl>           attribute <ref>WindowProxy</ref>? opener;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="parent" id="::Window::parent">
      <webidl>  readonly attribute <ref>WindowProxy</ref> parent;</webidl>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="frameElement" id="::Window::frameElement">
      <webidl>  readonly attribute <ref>Element</ref>? frameElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="open" id="::Window::open">
      <webidl>  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument optional="optional" name="url" stringvalue="about:blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="target" stringvalue="_blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="features" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter <ref>WindowProxy</ref> (unsigned long index);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="navigator" id="::Window::navigator">
      <webidl>  readonly attribute <ref>Navigator</ref> navigator;</webidl>
      <Type name="Navigator"/>
    </Attribute>
    <Attribute readonly="readonly" name="external" id="::Window::external">
      <webidl>  readonly attribute <ref>External</ref> external;</webidl>
      <Type name="External"/>
    </Attribute>
    <Attribute readonly="readonly" name="applicationCache" id="::Window::applicationCache">
      <webidl>  readonly attribute <ref>ApplicationCache</ref> applicationCache;</webidl>
      <Type name="ApplicationCache"/>
    </Attribute>
    <Operation name="alert" id="::Window::alert">
      <webidl>  void alert(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="confirm" id="::Window::confirm">
      <webidl>  boolean confirm(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="prompt" id="::Window::prompt">
      <webidl>  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="default" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="print" id="::Window::print">
      <webidl>  void print();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="showModalDialog" id="::Window::showModalDialog">
      <webidl>  any showModalDialog(DOMString url, optional any argument);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="argument">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="GlobalEventHandlers">
    <webidl><ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Implements name1="Window" name2="WindowEventHandlers">
    <webidl><ref>Window</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="BarProp" id="::BarProp">
    <webidl>interface BarProp {
           attribute boolean visible;
};</webidl>
    <Attribute name="visible" id="::BarProp::visible">
      <webidl>           attribute boolean visible;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="History" id="::History">
    <webidl>interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::History::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="state" id="::History::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
    <Operation name="go" id="::History::go">
      <webidl>  void go(optional long delta);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="delta">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="back" id="::History::back">
      <webidl>  void back();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="forward" id="::History::forward">
      <webidl>  void forward();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pushState" id="::History::pushState">
      <webidl>  void pushState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceState" id="::History::replaceState">
      <webidl>  void replaceState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Location" id="::Location">
    <webidl>[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Unforgeable">
        <webidl>Unforgeable</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="assign" id="::Location::assign">
      <webidl>  void assign(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replace" id="::Location::replace">
      <webidl>  void replace(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="reload" id="::Location::reload">
      <webidl>  void reload();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Location" name2="URLUtils">
    <webidl><ref>Location</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="PopStateEvent" id="::PopStateEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PopStateEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="state" id="::PopStateEvent::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
  </Interface>
  <Dictionary name="PopStateEventInit" id="::PopStateEventInit">
    <webidl>dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="state" id="::PopStateEventInit::state">
      <webidl>  any state;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HashChangeEvent" id="::HashChangeEvent">
    <webidl>[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="HashChangeEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="oldURL" id="::HashChangeEvent::oldURL">
      <webidl>  readonly attribute DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="newURL" id="::HashChangeEvent::newURL">
      <webidl>  readonly attribute DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Dictionary name="HashChangeEventInit" id="::HashChangeEventInit">
    <webidl>dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="oldURL" id="::HashChangeEventInit::oldURL">
      <webidl>  DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="newURL" id="::HashChangeEventInit::newURL">
      <webidl>  DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="PageTransitionEvent" id="::PageTransitionEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PageTransitionEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="persisted" id="::PageTransitionEvent::persisted">
      <webidl>  readonly attribute boolean persisted;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Dictionary name="PageTransitionEventInit" id="::PageTransitionEventInit">
    <webidl>dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="persisted" id="::PageTransitionEventInit::persisted">
      <webidl>  boolean persisted;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="BeforeUnloadEvent" id="::BeforeUnloadEvent">
    <webidl>interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="returnValue" id="::BeforeUnloadEvent::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="ApplicationCache" id="::ApplicationCache">
    <webidl>interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Const name="UNCACHED" value="0" id="::ApplicationCache::UNCACHED">
      <webidl>  const unsigned short UNCACHED = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="IDLE" value="1" id="::ApplicationCache::IDLE">
      <webidl>  const unsigned short IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CHECKING" value="2" id="::ApplicationCache::CHECKING">
      <webidl>  const unsigned short CHECKING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOWNLOADING" value="3" id="::ApplicationCache::DOWNLOADING">
      <webidl>  const unsigned short DOWNLOADING = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="UPDATEREADY" value="4" id="::ApplicationCache::UPDATEREADY">
      <webidl>  const unsigned short UPDATEREADY = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="OBSOLETE" value="5" id="::ApplicationCache::OBSOLETE">
      <webidl>  const unsigned short OBSOLETE = 5;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="status" id="::ApplicationCache::status">
      <webidl>  readonly attribute unsigned short status;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Operation name="update" id="::ApplicationCache::update">
      <webidl>  void update();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="abort" id="::ApplicationCache::abort">
      <webidl>  void abort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="swapCache" id="::ApplicationCache::swapCache">
      <webidl>  void swapCache();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onchecking" id="::ApplicationCache::onchecking">
      <webidl>           attribute <ref>EventHandler</ref> onchecking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::ApplicationCache::onerror">
      <webidl>           attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onnoupdate" id="::ApplicationCache::onnoupdate">
      <webidl>           attribute <ref>EventHandler</ref> onnoupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondownloading" id="::ApplicationCache::ondownloading">
      <webidl>           attribute <ref>EventHandler</ref> ondownloading;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::ApplicationCache::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onupdateready" id="::ApplicationCache::onupdateready">
      <webidl>           attribute <ref>EventHandler</ref> onupdateready;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncached" id="::ApplicationCache::oncached">
      <webidl>           attribute <ref>EventHandler</ref> oncached;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onobsolete" id="::ApplicationCache::onobsolete">
      <webidl>           attribute <ref>EventHandler</ref> onobsolete;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorOnLine" id="::NavigatorOnLine">
    <webidl>[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="onLine" id="::NavigatorOnLine::onLine">
      <webidl>  readonly attribute boolean onLine;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Callback name="EventHandlerNonNull" id="::EventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type name="Event"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="EventHandler" id="::EventHandler">
    <webidl>typedef <ref>EventHandlerNonNull</ref>? EventHandler;</webidl>
    <Type name="EventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Callback name="OnErrorEventHandlerNonNull" id="::OnErrorEventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type type="union">
          <Type name="Event"/>
          <Type type="DOMString"/>
        </Type>
      </Argument>
      <Argument optional="optional" name="source">
        <Type type="DOMString"/>
      </Argument>
      <Argument optional="optional" name="lineno">
        <Type type="unsigned long"/>
      </Argument>
      <Argument optional="optional" name="column">
        <Type type="unsigned long"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="OnErrorEventHandler" id="::OnErrorEventHandler">
    <webidl>typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;</webidl>
    <Type name="OnErrorEventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Interface name="GlobalEventHandlers" id="::GlobalEventHandlers">
    <webidl>[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> onclose;
           attribute <ref>EventHandler</ref> oncontextmenu;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondrag;
           attribute <ref>EventHandler</ref> ondragend;
           attribute <ref>EventHandler</ref> ondragenter;
           attribute <ref>EventHandler</ref> ondragexit;
           attribute <ref>EventHandler</ref> ondragleave;
           attribute <ref>EventHandler</ref> ondragover;
           attribute <ref>EventHandler</ref> ondragstart;
           attribute <ref>EventHandler</ref> ondrop;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onsort;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onabort" id="::GlobalEventHandlers::onabort">
      <webidl>           attribute <ref>EventHandler</ref> onabort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onblur" id="::GlobalEventHandlers::onblur">
      <webidl>           attribute <ref>EventHandler</ref> onblur;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::GlobalEventHandlers::onerror">
      <webidl>           attribute <ref>OnErrorEventHandler</ref> onerror;</webidl>
      <Type name="OnErrorEventHandler"/>
    </Attribute>
    <Attribute name="onfocus" id="::GlobalEventHandlers::onfocus">
      <webidl>           attribute <ref>EventHandler</ref> onfocus;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncancel" id="::GlobalEventHandlers::oncancel">
      <webidl>           attribute <ref>EventHandler</ref> oncancel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::GlobalEventHandlers::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::GlobalEventHandlers::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onchange" id="::GlobalEventHandlers::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onclick" id="::GlobalEventHandlers::onclick">
      <webidl>           attribute <ref>EventHandler</ref> onclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onclose" id="::GlobalEventHandlers::onclose">
      <webidl>           attribute <ref>EventHandler</ref> onclose;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncontextmenu" id="::GlobalEventHandlers::oncontextmenu">
      <webidl>           attribute <ref>EventHandler</ref> oncontextmenu;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncuechange" id="::GlobalEventHandlers::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondblclick" id="::GlobalEventHandlers::ondblclick">
      <webidl>           attribute <ref>EventHandler</ref> ondblclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondrag" id="::GlobalEventHandlers::ondrag">
      <webidl>           attribute <ref>EventHandler</ref> ondrag;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragend" id="::GlobalEventHandlers::ondragend">
      <webidl>           attribute <ref>EventHandler</ref> ondragend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragenter" id="::GlobalEventHandlers::ondragenter">
      <webidl>           attribute <ref>EventHandler</ref> ondragenter;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragexit" id="::GlobalEventHandlers::ondragexit">
      <webidl>           attribute <ref>EventHandler</ref> ondragexit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragleave" id="::GlobalEventHandlers::ondragleave">
      <webidl>           attribute <ref>EventHandler</ref> ondragleave;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragover" id="::GlobalEventHandlers::ondragover">
      <webidl>           attribute <ref>EventHandler</ref> ondragover;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragstart" id="::GlobalEventHandlers::ondragstart">
      <webidl>           attribute <ref>EventHandler</ref> ondragstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondrop" id="::GlobalEventHandlers::ondrop">
      <webidl>           attribute <ref>EventHandler</ref> ondrop;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::GlobalEventHandlers::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onemptied" id="::GlobalEventHandlers::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::GlobalEventHandlers::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninput" id="::GlobalEventHandlers::oninput">
      <webidl>           attribute <ref>EventHandler</ref> oninput;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninvalid" id="::GlobalEventHandlers::oninvalid">
      <webidl>           attribute <ref>EventHandler</ref> oninvalid;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeydown" id="::GlobalEventHandlers::onkeydown">
      <webidl>           attribute <ref>EventHandler</ref> onkeydown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeypress" id="::GlobalEventHandlers::onkeypress">
      <webidl>           attribute <ref>EventHandler</ref> onkeypress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeyup" id="::GlobalEventHandlers::onkeyup">
      <webidl>           attribute <ref>EventHandler</ref> onkeyup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onload" id="::GlobalEventHandlers::onload">
      <webidl>           attribute <ref>EventHandler</ref> onload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::GlobalEventHandlers::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::GlobalEventHandlers::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadstart" id="::GlobalEventHandlers::onloadstart">
      <webidl>           attribute <ref>EventHandler</ref> onloadstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousedown" id="::GlobalEventHandlers::onmousedown">
      <webidl>           attribute <ref>EventHandler</ref> onmousedown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseenter" id="::GlobalEventHandlers::onmouseenter">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseleave" id="::GlobalEventHandlers::onmouseleave">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousemove" id="::GlobalEventHandlers::onmousemove">
      <webidl>           attribute <ref>EventHandler</ref> onmousemove;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseout" id="::GlobalEventHandlers::onmouseout">
      <webidl>           attribute <ref>EventHandler</ref> onmouseout;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseover" id="::GlobalEventHandlers::onmouseover">
      <webidl>           attribute <ref>EventHandler</ref> onmouseover;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseup" id="::GlobalEventHandlers::onmouseup">
      <webidl>           attribute <ref>EventHandler</ref> onmouseup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousewheel" id="::GlobalEventHandlers::onmousewheel">
      <webidl>           attribute <ref>EventHandler</ref> onmousewheel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::GlobalEventHandlers::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::GlobalEventHandlers::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::GlobalEventHandlers::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::GlobalEventHandlers::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::GlobalEventHandlers::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onreset" id="::GlobalEventHandlers::onreset">
      <webidl>           attribute <ref>EventHandler</ref> onreset;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onscroll" id="::GlobalEventHandlers::onscroll">
      <webidl>           attribute <ref>EventHandler</ref> onscroll;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeked" id="::GlobalEventHandlers::onseeked">
      <webidl>           attribute <ref>EventHandler</ref> onseeked;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeking" id="::GlobalEventHandlers::onseeking">
      <webidl>           attribute <ref>EventHandler</ref> onseeking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onselect" id="::GlobalEventHandlers::onselect">
      <webidl>           attribute <ref>EventHandler</ref> onselect;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onshow" id="::GlobalEventHandlers::onshow">
      <webidl>           attribute <ref>EventHandler</ref> onshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsort" id="::GlobalEventHandlers::onsort">
      <webidl>           attribute <ref>EventHandler</ref> onsort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstalled" id="::GlobalEventHandlers::onstalled">
      <webidl>           attribute <ref>EventHandler</ref> onstalled;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsubmit" id="::GlobalEventHandlers::onsubmit">
      <webidl>           attribute <ref>EventHandler</ref> onsubmit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsuspend" id="::GlobalEventHandlers::onsuspend">
      <webidl>           attribute <ref>EventHandler</ref> onsuspend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::GlobalEventHandlers::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::GlobalEventHandlers::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::GlobalEventHandlers::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowEventHandlers" id="::WindowEventHandlers">
    <webidl>[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>EventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onfullscreenchange;
           attribute <ref>EventHandler</ref> onfullscreenerror;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onafterprint" id="::WindowEventHandlers::onafterprint">
      <webidl>           attribute <ref>EventHandler</ref> onafterprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeprint" id="::WindowEventHandlers::onbeforeprint">
      <webidl>           attribute <ref>EventHandler</ref> onbeforeprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeunload" id="::WindowEventHandlers::onbeforeunload">
      <webidl>           attribute <ref>EventHandler</ref> onbeforeunload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfullscreenchange" id="::WindowEventHandlers::onfullscreenchange">
      <webidl>           attribute <ref>EventHandler</ref> onfullscreenchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfullscreenerror" id="::WindowEventHandlers::onfullscreenerror">
      <webidl>           attribute <ref>EventHandler</ref> onfullscreenerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onhashchange" id="::WindowEventHandlers::onhashchange">
      <webidl>           attribute <ref>EventHandler</ref> onhashchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmessage" id="::WindowEventHandlers::onmessage">
      <webidl>           attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onoffline" id="::WindowEventHandlers::onoffline">
      <webidl>           attribute <ref>EventHandler</ref> onoffline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ononline" id="::WindowEventHandlers::ononline">
      <webidl>           attribute <ref>EventHandler</ref> ononline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpagehide" id="::WindowEventHandlers::onpagehide">
      <webidl>           attribute <ref>EventHandler</ref> onpagehide;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpageshow" id="::WindowEventHandlers::onpageshow">
      <webidl>           attribute <ref>EventHandler</ref> onpageshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpopstate" id="::WindowEventHandlers::onpopstate">
      <webidl>           attribute <ref>EventHandler</ref> onpopstate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onresize" id="::WindowEventHandlers::onresize">
      <webidl>           attribute <ref>EventHandler</ref> onresize;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstorage" id="::WindowEventHandlers::onstorage">
      <webidl>           attribute <ref>EventHandler</ref> onstorage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onunload" id="::WindowEventHandlers::onunload">
      <webidl>           attribute <ref>EventHandler</ref> onunload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowBase64" id="::WindowBase64">
    <webidl>[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="btoa" id="::WindowBase64::btoa">
      <webidl>  DOMString btoa(DOMString btoa);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="btoa">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="atob" id="::WindowBase64::atob">
      <webidl>  DOMString atob(DOMString atob);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="atob">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowBase64">
    <webidl><ref>Window</ref> implements <ref>WindowBase64</ref>;</webidl>
  </Implements>
  <Interface name="WindowTimers" id="::WindowTimers">
    <webidl>[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearTimeout" id="::WindowTimers::clearTimeout">
      <webidl>  void clearTimeout(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearInterval" id="::WindowTimers::clearInterval">
      <webidl>  void clearInterval(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowTimers">
    <webidl><ref>Window</ref> implements <ref>WindowTimers</ref>;</webidl>
  </Implements>
  <Interface name="WindowModal" id="::WindowModal">
    <webidl>[NoInterfaceObject] interface WindowModal {
  readonly attribute any dialogArguments;
           attribute DOMString returnValue;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="dialogArguments" id="::WindowModal::dialogArguments">
      <webidl>  readonly attribute any dialogArguments;</webidl>
      <Type type="any"/>
    </Attribute>
    <Attribute name="returnValue" id="::WindowModal::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Navigator" id="::Navigator">
    <webidl>interface Navigator {
};</webidl>
  </Interface>
  <Implements name1="Navigator" name2="NavigatorID">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorID</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorLanguage">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorOnLine">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorContentUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorStorageUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;</webidl>
  </Implements>
  <Interface name="NavigatorID" id="::NavigatorID">
    <webidl>[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString userAgent;

  readonly attribute DOMString product; 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="appName" id="::NavigatorID::appName">
      <webidl>  readonly attribute DOMString appName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="appVersion" id="::NavigatorID::appVersion">
      <webidl>  readonly attribute DOMString appVersion;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="platform" id="::NavigatorID::platform">
      <webidl>  readonly attribute DOMString platform;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="userAgent" id="::NavigatorID::userAgent">
      <webidl>  readonly attribute DOMString userAgent;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="product" id="::NavigatorID::product">
      <webidl>  readonly attribute DOMString product;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorLanguage" id="::NavigatorLanguage">
    <webidl>[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="language" id="::NavigatorLanguage::language">
      <webidl>  readonly attribute DOMString? language;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorContentUtils" id="::NavigatorContentUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="registerProtocolHandler" id="::NavigatorContentUtils::registerProtocolHandler">
      <webidl>  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="registerContentHandler" id="::NavigatorContentUtils::registerContentHandler">
      <webidl>  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isProtocolHandlerRegistered" id="::NavigatorContentUtils::isProtocolHandlerRegistered">
      <webidl>  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isContentHandlerRegistered" id="::NavigatorContentUtils::isContentHandlerRegistered">
      <webidl>  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterProtocolHandler" id="::NavigatorContentUtils::unregisterProtocolHandler">
      <webidl>  void unregisterProtocolHandler(DOMString scheme, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterContentHandler" id="::NavigatorContentUtils::unregisterContentHandler">
      <webidl>  void unregisterContentHandler(DOMString mimeType, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NavigatorStorageUtils" id="::NavigatorStorageUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorStorageUtils {
  void yieldForStorageUpdates();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="yieldForStorageUpdates" id="::NavigatorStorageUtils::yieldForStorageUpdates">
      <webidl>  void yieldForStorageUpdates();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="External" id="::External">
    <webidl>interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};</webidl>
    <Operation name="AddSearchProvider" id="::External::AddSearchProvider">
      <webidl>  void AddSearchProvider(DOMString engineURL);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="IsSearchProviderInstalled" id="::External::IsSearchProviderInstalled">
      <webidl>  unsigned long IsSearchProviderInstalled(DOMString engineURL);</webidl>
      <Type type="unsigned long"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="ImageBitmap" id="::ImageBitmap">
    <webidl>interface ImageBitmap {
};</webidl>
  </Interface>
  <Callback name="ImageBitmapCallback" id="::ImageBitmapCallback">
    <webidl>callback ImageBitmapCallback = void (<ref>ImageBitmap</ref> image);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="image">
        <Type name="ImageBitmap"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="ImageBitmapSource" id="::ImageBitmapSource">
    <webidl>typedef (<ref>HTMLImageElement</ref> or
         <ref>HTMLVideoElement</ref> or
         <ref>HTMLCanvasElement</ref> or
         <ref>Blob</ref> or
         <ref>ImageData</ref> or
         <ref>CanvasRenderingContext2D</ref> or
         <ref>ImageBitmap</ref>) ImageBitmapSource;</webidl>
    <Type type="union">
      <Type name="HTMLImageElement"/>
      <Type name="HTMLVideoElement"/>
      <Type name="HTMLCanvasElement"/>
      <Type name="Blob"/>
      <Type name="ImageData"/>
      <Type name="CanvasRenderingContext2D"/>
      <Type name="ImageBitmap"/>
    </Type>
  </Typedef>
  <Interface name="ImageBitmapFactories" id="::ImageBitmapFactories">
    <webidl>[NoInterfaceObject]
interface ImageBitmapFactories {
  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="createImageBitmap" id="::ImageBitmapFactories::createImageBitmap">
      <webidl>  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="image">
          <Type name="ImageBitmapSource"/>
        </Argument>
        <Argument name="_callback">
          <Type name="ImageBitmapCallback"/>
        </Argument>
        <Argument optional="optional" name="sx">
          <Type type="long"/>
        </Argument>
        <Argument name="sy">
          <Type type="long"/>
        </Argument>
        <Argument name="sw">
          <Type type="long"/>
        </Argument>
        <Argument name="sh">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="ImageBitmapFactories">
    <webidl><ref>Window</ref> implements <ref>ImageBitmapFactories</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerGlobalScope" name2="ImageBitmapFactories">
    <webidl><ref>WorkerGlobalScope</ref> implements <ref>ImageBitmapFactories</ref>;</webidl>
  </Implements>
  <Interface name="DataTransfer" id="::DataTransfer">
    <webidl>interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute <ref>DataTransferItemList</ref> items;

  void setDragImage(<ref>Element</ref> image, long x, long y);

  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute <ref>FileList</ref> files;
};</webidl>
    <Attribute name="dropEffect" id="::DataTransfer::dropEffect">
      <webidl>           attribute DOMString dropEffect;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="effectAllowed" id="::DataTransfer::effectAllowed">
      <webidl>           attribute DOMString effectAllowed;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="items" id="::DataTransfer::items">
      <webidl>  readonly attribute <ref>DataTransferItemList</ref> items;</webidl>
      <Type name="DataTransferItemList"/>
    </Attribute>
    <Operation name="setDragImage" id="::DataTransfer::setDragImage">
      <webidl>  void setDragImage(<ref>Element</ref> image, long x, long y);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="image">
          <Type name="Element"/>
        </Argument>
        <Argument name="x">
          <Type type="long"/>
        </Argument>
        <Argument name="y">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="types" id="::DataTransfer::types">
      <webidl>  readonly attribute DOMString[] types;</webidl>
      <Type type="array">
        <Type type="DOMString"/>
      </Type>
    </Attribute>
    <Operation name="getData" id="::DataTransfer::getData">
      <webidl>  DOMString getData(DOMString format);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="format">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setData" id="::DataTransfer::setData">
      <webidl>  void setData(DOMString format, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="format">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearData" id="::DataTransfer::clearData">
      <webidl>  void clearData(optional DOMString format);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="format">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="files" id="::DataTransfer::files">
      <webidl>  readonly attribute <ref>FileList</ref> files;</webidl>
      <Type name="FileList"/>
    </Attribute>
  </Interface>
  <Interface name="DataTransferItemList" id="::DataTransferItemList">
    <webidl>interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter <ref>DataTransferItem</ref> (unsigned long index);
  void remove(unsigned long index);
  void clear();

  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);
  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::DataTransferItemList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>DataTransferItem</ref> (unsigned long index);</webidl>
      <Type name="DataTransferItem"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::DataTransferItemList::remove">
      <webidl>  void remove(unsigned long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clear" id="::DataTransferItemList::clear">
      <webidl>  void clear();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="add" id="::DataTransferItemList::add">
      <webidl>  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);</webidl>
      <Type name="DataTransferItem" nullable="nullable"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::DataTransferItemList::add">
      <webidl>  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);</webidl>
      <Type name="DataTransferItem" nullable="nullable"/>
      <ArgumentList>
        <Argument name="data">
          <Type name="File"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DataTransferItem" id="::DataTransferItem">
    <webidl>interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(<ref>FunctionStringCallback</ref>? _callback);
  <ref>File</ref>? getAsFile();
};</webidl>
    <Attribute readonly="readonly" name="kind" id="::DataTransferItem::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::DataTransferItem::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="getAsString" id="::DataTransferItem::getAsString">
      <webidl>  void getAsString(<ref>FunctionStringCallback</ref>? _callback);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="_callback">
          <Type name="FunctionStringCallback" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAsFile" id="::DataTransferItem::getAsFile">
      <webidl>  <ref>File</ref>? getAsFile();</webidl>
      <Type name="File" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="FunctionStringCallback" id="::FunctionStringCallback">
    <webidl>[Callback, NoInterfaceObject]
interface FunctionStringCallback {
  void handleEvent(DOMString data);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Callback">
        <webidl>Callback</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl> NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="handleEvent" id="::FunctionStringCallback::handleEvent">
      <webidl>  void handleEvent(DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DragEvent" id="::DragEvent">
    <webidl>[Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)]
interface DragEvent : <ref>MouseEvent</ref> {
  readonly attribute <ref>DataTransfer</ref>? dataTransfer;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="DragEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="MouseEvent"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="dataTransfer" id="::DragEvent::dataTransfer">
      <webidl>  readonly attribute <ref>DataTransfer</ref>? dataTransfer;</webidl>
      <Type name="DataTransfer" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="DragEventInit" id="::DragEventInit">
    <webidl>dictionary DragEventInit : <ref>EventInit</ref> {
  <ref>Window</ref>? view = null;
  long detail = 0;
  long screenX = 0;
  long screenY = 0;
  long clientX = 0;
  long clientY = 0;
  boolean ctrlKey = false;
  boolean shiftKey = false;
  boolean altKey = false;
  boolean metaKey = false;
  unsigned short button = 0;
  unsigned short buttons = 0;
  <ref>EventTarget</ref>? relatedTarget = null;
  <ref>DataTransfer</ref>? dataTransfer;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="view" value="null" id="::DragEventInit::view">
      <webidl>  <ref>Window</ref>? view = null;</webidl>
      <Type name="Window" nullable="nullable"/>
    </DictionaryMember>
    <DictionaryMember name="detail" value="0" id="::DragEventInit::detail">
      <webidl>  long detail = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="screenX" value="0" id="::DragEventInit::screenX">
      <webidl>  long screenX = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="screenY" value="0" id="::DragEventInit::screenY">
      <webidl>  long screenY = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="clientX" value="0" id="::DragEventInit::clientX">
      <webidl>  long clientX = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="clientY" value="0" id="::DragEventInit::clientY">
      <webidl>  long clientY = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="ctrlKey" value="false" id="::DragEventInit::ctrlKey">
      <webidl>  boolean ctrlKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="shiftKey" value="false" id="::DragEventInit::shiftKey">
      <webidl>  boolean shiftKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="altKey" value="false" id="::DragEventInit::altKey">
      <webidl>  boolean altKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="metaKey" value="false" id="::DragEventInit::metaKey">
      <webidl>  boolean metaKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="button" value="0" id="::DragEventInit::button">
      <webidl>  unsigned short button = 0;</webidl>
      <Type type="unsigned short"/>
    </DictionaryMember>
    <DictionaryMember name="buttons" value="0" id="::DragEventInit::buttons">
      <webidl>  unsigned short buttons = 0;</webidl>
      <Type type="unsigned short"/>
    </DictionaryMember>
    <DictionaryMember name="relatedTarget" value="null" id="::DragEventInit::relatedTarget">
      <webidl>  <ref>EventTarget</ref>? relatedTarget = null;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </DictionaryMember>
    <DictionaryMember name="dataTransfer" id="::DragEventInit::dataTransfer">
      <webidl>  <ref>DataTransfer</ref>? dataTransfer;</webidl>
      <Type name="DataTransfer" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HTMLAppletElement" id="::HTMLAppletElement">
    <webidl>interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="align" id="::HTMLAppletElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLAppletElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLAppletElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLAppletElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLAppletElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLAppletElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLAppletElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAppletElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="_object" id="::HTMLAppletElement::_object">
      <webidl>           attribute DOMString _object;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLAppletElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLAppletElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMarqueeElement" id="::HTMLMarqueeElement">
    <webidl>interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="behavior" id="::HTMLMarqueeElement::behavior">
      <webidl>           attribute DOMString behavior;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLMarqueeElement::bgColor">
      <webidl>           attribute DOMString bgColor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="direction" id="::HTMLMarqueeElement::direction">
      <webidl>           attribute DOMString direction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLMarqueeElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLMarqueeElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMarqueeElement::loop">
      <webidl>           attribute long loop;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="scrollAmount" id="::HTMLMarqueeElement::scrollAmount">
      <webidl>           attribute unsigned long scrollAmount;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="scrollDelay" id="::HTMLMarqueeElement::scrollDelay">
      <webidl>           attribute unsigned long scrollDelay;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="trueSpeed" id="::HTMLMarqueeElement::trueSpeed">
      <webidl>           attribute boolean trueSpeed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLMarqueeElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLMarqueeElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="onbounce" id="::HTMLMarqueeElement::onbounce">
      <webidl>           attribute <ref>EventHandler</ref> onbounce;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfinish" id="::HTMLMarqueeElement::onfinish">
      <webidl>           attribute <ref>EventHandler</ref> onfinish;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstart" id="::HTMLMarqueeElement::onstart">
      <webidl>           attribute <ref>EventHandler</ref> onstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Operation name="start" id="::HTMLMarqueeElement::start">
      <webidl>  void start();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stop" id="::HTMLMarqueeElement::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLFrameSetElement" id="::HTMLFrameSetElement">
    <webidl>interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cols" id="::HTMLFrameSetElement::cols">
      <webidl>           attribute DOMString cols;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLFrameSetElement::rows">
      <webidl>           attribute DOMString rows;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLFrameSetElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLFrameElement" id="::HTMLFrameElement">
    <webidl>interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noResize" id="::HTMLFrameElement::noResize">
      <webidl>           attribute boolean noResize;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAnchorElement" partial="partial" id="::HTMLAnchorElement">
    <webidl>partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};</webidl>
    <Attribute name="coords" id="::HTMLAnchorElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLAnchorElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAnchorElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLAnchorElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAnchorElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" partial="partial" id="::HTMLAreaElement">
    <webidl>partial interface HTMLAreaElement {
           attribute boolean noHref;
};</webidl>
    <Attribute name="noHref" id="::HTMLAreaElement::noHref">
      <webidl>           attribute boolean noHref;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBodyElement" partial="partial" id="::HTMLBodyElement">
    <webidl>partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};</webidl>
    <Attribute name="text" id="::HTMLBodyElement::text">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString text;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="link" id="::HTMLBodyElement::link">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString link;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vLink" id="::HTMLBodyElement::vLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="aLink" id="::HTMLBodyElement::aLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString aLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLBodyElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="background" id="::HTMLBodyElement::background">
      <webidl>                            attribute DOMString background;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBRElement" partial="partial" id="::HTMLBRElement">
    <webidl>partial interface HTMLBRElement {
           attribute DOMString clear;
};</webidl>
    <Attribute name="clear" id="::HTMLBRElement::clear">
      <webidl>           attribute DOMString clear;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCaptionElement" partial="partial" id="::HTMLTableCaptionElement">
    <webidl>partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLTableCaptionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableColElement" partial="partial" id="::HTMLTableColElement">
    <webidl>partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLTableColElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableColElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableColElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableColElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableColElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDirectoryElement" id="::HTMLDirectoryElement">
    <webidl>interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="compact" id="::HTMLDirectoryElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDivElement" partial="partial" id="::HTMLDivElement">
    <webidl>partial interface HTMLDivElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLDivElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" partial="partial" id="::HTMLDListElement">
    <webidl>partial interface HTMLDListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLDListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" partial="partial" id="::HTMLEmbedElement">
    <webidl>partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};</webidl>
    <Attribute name="align" id="::HTMLEmbedElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLEmbedElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFontElement" id="::HTMLFontElement">
    <webidl>interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="color" id="::HTMLFontElement::color">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString color;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="face" id="::HTMLFontElement::face">
      <webidl>                            attribute DOMString face;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="size" id="::HTMLFontElement::size">
      <webidl>                            attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHeadingElement" partial="partial" id="::HTMLHeadingElement">
    <webidl>partial interface HTMLHeadingElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLHeadingElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHRElement" partial="partial" id="::HTMLHRElement">
    <webidl>partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLHRElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="color" id="::HTMLHRElement::color">
      <webidl>           attribute DOMString color;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noShade" id="::HTMLHRElement::noShade">
      <webidl>           attribute boolean noShade;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLHRElement::size">
      <webidl>           attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLHRElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHtmlElement" partial="partial" id="::HTMLHtmlElement">
    <webidl>partial interface HTMLHtmlElement {
           attribute DOMString version;
};</webidl>
    <Attribute name="version" id="::HTMLHtmlElement::version">
      <webidl>           attribute DOMString version;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" partial="partial" id="::HTMLIFrameElement">
    <webidl>partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <Attribute name="align" id="::HTMLIFrameElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLIFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLIFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLIFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLIFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLIFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" partial="partial" id="::HTMLImageElement">
    <webidl>partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="name" id="::HTMLImageElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="align" id="::HTMLImageElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLImageElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLImageElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLImageElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLImageElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" partial="partial" id="::HTMLInputElement">
    <webidl>partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};</webidl>
    <Attribute name="align" id="::HTMLInputElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLInputElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLegendElement" partial="partial" id="::HTMLLegendElement">
    <webidl>partial interface HTMLLegendElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLLegendElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLIElement" partial="partial" id="::HTMLLIElement">
    <webidl>partial interface HTMLLIElement {
           attribute DOMString type;
};</webidl>
    <Attribute name="type" id="::HTMLLIElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" partial="partial" id="::HTMLLinkElement">
    <webidl>partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};</webidl>
    <Attribute name="charset" id="::HTMLLinkElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLLinkElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLLinkElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuElement" partial="partial" id="::HTMLMenuElement">
    <webidl>partial interface HTMLMenuElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLMenuElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMetaElement" partial="partial" id="::HTMLMetaElement">
    <webidl>partial interface HTMLMetaElement {
           attribute DOMString scheme;
};</webidl>
    <Attribute name="scheme" id="::HTMLMetaElement::scheme">
      <webidl>           attribute DOMString scheme;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLObjectElement" partial="partial" id="::HTMLObjectElement">
    <webidl>partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="align" id="::HTMLObjectElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLObjectElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLObjectElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="declare" id="::HTMLObjectElement::declare">
      <webidl>           attribute boolean declare;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLObjectElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="standby" id="::HTMLObjectElement::standby">
      <webidl>           attribute DOMString standby;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLObjectElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLObjectElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeType" id="::HTMLObjectElement::codeType">
      <webidl>           attribute DOMString codeType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLObjectElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" partial="partial" id="::HTMLOListElement">
    <webidl>partial interface HTMLOListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLOListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParagraphElement" partial="partial" id="::HTMLParagraphElement">
    <webidl>partial interface HTMLParagraphElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLParagraphElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParamElement" partial="partial" id="::HTMLParamElement">
    <webidl>partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};</webidl>
    <Attribute name="type" id="::HTMLParamElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueType" id="::HTMLParamElement::valueType">
      <webidl>           attribute DOMString valueType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLPreElement" partial="partial" id="::HTMLPreElement">
    <webidl>partial interface HTMLPreElement {
           attribute long width;
};</webidl>
    <Attribute name="width" id="::HTMLPreElement::width">
      <webidl>           attribute long width;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLScriptElement" partial="partial" id="::HTMLScriptElement">
    <webidl>partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};</webidl>
    <Attribute name="event" id="::HTMLScriptElement::event">
      <webidl>           attribute DOMString event;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLScriptElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableElement" partial="partial" id="::HTMLTableElement">
    <webidl>partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};</webidl>
    <Attribute name="align" id="::HTMLTableElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frame" id="::HTMLTableElement::frame">
      <webidl>           attribute DOMString frame;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rules" id="::HTMLTableElement::rules">
      <webidl>           attribute DOMString rules;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="summary" id="::HTMLTableElement::summary">
      <webidl>           attribute DOMString summary;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellPadding" id="::HTMLTableElement::cellPadding">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellPadding;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellSpacing" id="::HTMLTableElement::cellSpacing">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" partial="partial" id="::HTMLTableSectionElement">
    <webidl>partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};</webidl>
    <Attribute name="align" id="::HTMLTableSectionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableSectionElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableSectionElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableSectionElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCellElement" partial="partial" id="::HTMLTableCellElement">
    <webidl>partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableCellElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="axis" id="::HTMLTableCellElement::axis">
      <webidl>           attribute DOMString axis;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLTableCellElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableCellElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableCellElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableCellElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noWrap" id="::HTMLTableCellElement::noWrap">
      <webidl>           attribute boolean noWrap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableCellElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableCellElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableDataCellElement" partial="partial" id="::HTMLTableDataCellElement">
    <webidl>partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};</webidl>
    <Attribute name="abbr" id="::HTMLTableDataCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableRowElement" partial="partial" id="::HTMLTableRowElement">
    <webidl>partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableRowElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableRowElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableRowElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableRowElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableRowElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" partial="partial" id="::HTMLUListElement">
    <webidl>partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};</webidl>
    <Attribute name="compact" id="::HTMLUListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="type" id="::HTMLUListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();

  readonly attribute <ref>HTMLAllCollection</ref> all;
};</webidl>
    <Attribute name="fgColor" id="::Document::fgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString fgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="linkColor" id="::Document::linkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString linkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vlinkColor" id="::Document::vlinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alinkColor" id="::Document::alinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString alinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::Document::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="anchors" id="::Document::anchors">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> anchors;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="applets" id="::Document::applets">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> applets;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="clear" id="::Document::clear">
      <webidl>  void clear();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="all" id="::Document::all">
      <webidl>  readonly attribute <ref>HTMLAllCollection</ref> all;</webidl>
      <Type name="HTMLAllCollection"/>
    </Attribute>
  </Interface>
</Definitions>
<Definitions>
  <webidl>[Exposed=<ref>Worker</ref>] interface WorkerGlobalScope : <ref>EventTarget</ref> {
  readonly attribute <ref>WorkerGlobalScope</ref> self;
  readonly attribute <ref>WorkerLocation</ref> location;

  void close();
  attribute <ref>OnErrorEventHandler</ref> onerror;
  attribute <ref>EventHandler</ref> onlanguagechange;
  attribute <ref>EventHandler</ref> onoffline;
  attribute <ref>EventHandler</ref> ononline;

};

[Global=(<ref>Worker</ref>,<ref>DedicatedWorker</ref>),Exposed=<ref>DedicatedWorker</ref>]
interface DedicatedWorkerGlobalScope : <ref>WorkerGlobalScope</ref> {
  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  attribute <ref>EventHandler</ref> onmessage;
};
[Global=(<ref>Worker</ref>,<ref>SharedWorker</ref>),Exposed=<ref>SharedWorker</ref>]
interface SharedWorkerGlobalScope : <ref>WorkerGlobalScope</ref> {
  readonly attribute DOMString name;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;
  attribute <ref>EventHandler</ref> onconnect;
};
[NoInterfaceObject, Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface AbstractWorker {
    attribute <ref>EventHandler</ref> onerror;
};
[Constructor(DOMString scriptURL), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Worker : <ref>EventTarget</ref> {
  void terminate();

  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  attribute <ref>EventHandler</ref> onmessage;
};
<ref>Worker</ref> implements <ref>AbstractWorker</ref>;
[Constructor(DOMString scriptURL, optional DOMString name), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface SharedWorker : <ref>EventTarget</ref> {
  readonly attribute <ref>MessagePort</ref> port;
};
<ref>SharedWorker</ref> implements <ref>AbstractWorker</ref>;
[Exposed=<ref>Worker</ref>]
partial interface WorkerGlobalScope { 
  void importScripts(DOMString... urls);
  readonly attribute <ref>WorkerNavigator</ref> navigator;
};
<ref>WorkerGlobalScope</ref> implements <ref>WindowTimers</ref>;
<ref>WorkerGlobalScope</ref> implements <ref>WindowBase64</ref>;
[Exposed=<ref>Worker</ref>]
interface WorkerNavigator {};
<ref>WorkerNavigator</ref> implements <ref>NavigatorID</ref>;
<ref>WorkerNavigator</ref> implements <ref>NavigatorLanguage</ref>;
<ref>WorkerNavigator</ref> implements <ref>NavigatorOnLine</ref>;
[Exposed=<ref>Worker</ref>]
interface WorkerLocation { };
<ref>WorkerLocation</ref> implements <ref>URLUtilsReadOnly</ref>;</webidl>
  <Interface name="WorkerGlobalScope" id="::WorkerGlobalScope">
    <webidl>[Exposed=<ref>Worker</ref>] interface WorkerGlobalScope : <ref>EventTarget</ref> {
  readonly attribute <ref>WorkerGlobalScope</ref> self;
  readonly attribute <ref>WorkerLocation</ref> location;

  void close();
  attribute <ref>OnErrorEventHandler</ref> onerror;
  attribute <ref>EventHandler</ref> onlanguagechange;
  attribute <ref>EventHandler</ref> onoffline;
  attribute <ref>EventHandler</ref> ononline;

};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Worker</ref>]</webidl>
        <TypeList>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="self" readonly="readonly" id="::WorkerGlobalScope::self">
      <webidl>  readonly attribute <ref>WorkerGlobalScope</ref> self;</webidl>
      <Type name="WorkerGlobalScope"/>
    </Attribute>
    <Attribute name="location" readonly="readonly" id="::WorkerGlobalScope::location">
      <webidl>  readonly attribute <ref>WorkerLocation</ref> location;</webidl>
      <Type name="WorkerLocation"/>
    </Attribute>
    <Operation name="close" id="::WorkerGlobalScope::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onerror" id="::WorkerGlobalScope::onerror">
      <webidl>  attribute <ref>OnErrorEventHandler</ref> onerror;</webidl>
      <Type name="OnErrorEventHandler"/>
    </Attribute>
    <Attribute name="onlanguagechange" id="::WorkerGlobalScope::onlanguagechange">
      <webidl>  attribute <ref>EventHandler</ref> onlanguagechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onoffline" id="::WorkerGlobalScope::onoffline">
      <webidl>  attribute <ref>EventHandler</ref> onoffline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ononline" id="::WorkerGlobalScope::ononline">
      <webidl>  attribute <ref>EventHandler</ref> ononline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="DedicatedWorkerGlobalScope" id="::DedicatedWorkerGlobalScope">
    <webidl>[Global=(<ref>Worker</ref>,<ref>DedicatedWorker</ref>),Exposed=<ref>DedicatedWorker</ref>]
interface DedicatedWorkerGlobalScope : <ref>WorkerGlobalScope</ref> {
  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  attribute <ref>EventHandler</ref> onmessage;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Global">
        <webidl>Global=(<ref>Worker</ref>,<ref>DedicatedWorker</ref>),</webidl>
        <TypeList>
          <Type name="Worker"/>
          <Type name="DedicatedWorker"/>
        </TypeList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>DedicatedWorker</ref>]</webidl>
        <TypeList>
          <Type name="DedicatedWorker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="WorkerGlobalScope"/>
    </InterfaceInheritance>
    <Operation name="postMessage" id="::DedicatedWorkerGlobalScope::postMessage">
      <webidl>  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="message">
          <Type type="any"/>
        </Argument>
        <Argument optional="optional" name="transfer">
          <Type type="sequence">
            <Type name="Transferable"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onmessage" id="::DedicatedWorkerGlobalScope::onmessage">
      <webidl>  attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="SharedWorkerGlobalScope" id="::SharedWorkerGlobalScope">
    <webidl>[Global=(<ref>Worker</ref>,<ref>SharedWorker</ref>),Exposed=<ref>SharedWorker</ref>]
interface SharedWorkerGlobalScope : <ref>WorkerGlobalScope</ref> {
  readonly attribute DOMString name;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;
  attribute <ref>EventHandler</ref> onconnect;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Global">
        <webidl>Global=(<ref>Worker</ref>,<ref>SharedWorker</ref>),</webidl>
        <TypeList>
          <Type name="Worker"/>
          <Type name="SharedWorker"/>
        </TypeList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>SharedWorker</ref>]</webidl>
        <TypeList>
          <Type name="SharedWorker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="WorkerGlobalScope"/>
    </InterfaceInheritance>
    <Attribute name="name" readonly="readonly" id="::SharedWorkerGlobalScope::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="applicationCache" readonly="readonly" id="::SharedWorkerGlobalScope::applicationCache">
      <webidl>  readonly attribute <ref>ApplicationCache</ref> applicationCache;</webidl>
      <Type name="ApplicationCache"/>
    </Attribute>
    <Attribute name="onconnect" id="::SharedWorkerGlobalScope::onconnect">
      <webidl>  attribute <ref>EventHandler</ref> onconnect;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="AbstractWorker" id="::AbstractWorker">
    <webidl>[NoInterfaceObject, Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface AbstractWorker {
    attribute <ref>EventHandler</ref> onerror;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onerror" id="::AbstractWorker::onerror">
      <webidl>    attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="Worker" id="::Worker">
    <webidl>[Constructor(DOMString scriptURL), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Worker : <ref>EventTarget</ref> {
  void terminate();

  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);
  attribute <ref>EventHandler</ref> onmessage;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString scriptURL)</webidl>
        <ArgumentList>
          <Argument name="scriptURL">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Operation name="terminate" id="::Worker::terminate">
      <webidl>  void terminate();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="postMessage" id="::Worker::postMessage">
      <webidl>  void postMessage(any message, optional sequence&lt;<ref>Transferable</ref>> transfer);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="message">
          <Type type="any"/>
        </Argument>
        <Argument optional="optional" name="transfer">
          <Type type="sequence">
            <Type name="Transferable"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onmessage" id="::Worker::onmessage">
      <webidl>  attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Implements name1="Worker" name2="AbstractWorker">
    <webidl><ref>Worker</ref> implements <ref>AbstractWorker</ref>;</webidl>
  </Implements>
  <Interface name="SharedWorker" id="::SharedWorker">
    <webidl>[Constructor(DOMString scriptURL, optional DOMString name), Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface SharedWorker : <ref>EventTarget</ref> {
  readonly attribute <ref>MessagePort</ref> port;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString scriptURL, optional DOMString name)</webidl>
        <ArgumentList>
          <Argument name="scriptURL">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute name="port" readonly="readonly" id="::SharedWorker::port">
      <webidl>  readonly attribute <ref>MessagePort</ref> port;</webidl>
      <Type name="MessagePort"/>
    </Attribute>
  </Interface>
  <Implements name1="SharedWorker" name2="AbstractWorker">
    <webidl><ref>SharedWorker</ref> implements <ref>AbstractWorker</ref>;</webidl>
  </Implements>
  <Interface name="WorkerGlobalScope" partial="partial" id="::WorkerGlobalScope">
    <webidl>[Exposed=<ref>Worker</ref>]
partial interface WorkerGlobalScope { 
  void importScripts(DOMString... urls);
  readonly attribute <ref>WorkerNavigator</ref> navigator;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Worker</ref>]</webidl>
        <TypeList>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="importScripts" id="::WorkerGlobalScope::importScripts">
      <webidl>  void importScripts(DOMString... urls);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="urls">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="navigator" readonly="readonly" id="::WorkerGlobalScope::navigator">
      <webidl>  readonly attribute <ref>WorkerNavigator</ref> navigator;</webidl>
      <Type name="WorkerNavigator"/>
    </Attribute>
  </Interface>
  <Implements name1="WorkerGlobalScope" name2="WindowTimers">
    <webidl><ref>WorkerGlobalScope</ref> implements <ref>WindowTimers</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerGlobalScope" name2="WindowBase64">
    <webidl><ref>WorkerGlobalScope</ref> implements <ref>WindowBase64</ref>;</webidl>
  </Implements>
  <Interface name="WorkerNavigator" id="::WorkerNavigator">
    <webidl>[Exposed=<ref>Worker</ref>]
interface WorkerNavigator {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Worker</ref>]</webidl>
        <TypeList>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
  </Interface>
  <Implements name1="WorkerNavigator" name2="NavigatorID">
    <webidl><ref>WorkerNavigator</ref> implements <ref>NavigatorID</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerNavigator" name2="NavigatorLanguage">
    <webidl><ref>WorkerNavigator</ref> implements <ref>NavigatorLanguage</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerNavigator" name2="NavigatorOnLine">
    <webidl><ref>WorkerNavigator</ref> implements <ref>NavigatorOnLine</ref>;</webidl>
  </Implements>
  <Interface name="WorkerLocation" id="::WorkerLocation">
    <webidl>[Exposed=<ref>Worker</ref>]
interface WorkerLocation { };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Worker</ref>]</webidl>
        <TypeList>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
  </Interface>
  <Implements name1="WorkerLocation" name2="URLUtilsReadOnly">
    <webidl><ref>WorkerLocation</ref> implements <ref>URLUtilsReadOnly</ref>;</webidl>
  </Implements>
</Definitions>
<Definitions>
  <webidl>enum ReferrerPolicy {
  &quot;&quot;,
  &quot;no-referrer&quot;,
  &quot;no-referrer-when-downgrade&quot;,
  &quot;origin-only&quot;,
  &quot;origin-when-cross-origin&quot;,
  &quot;unsafe-url&quot;
};
typedef (<ref>Headers</ref> or sequence&lt;sequence&lt;ByteString>>) HeadersInit;
[Constructor(optional <ref>HeadersInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Headers {
  void append(ByteString name, ByteString value);
  void delete(ByteString name);
  ByteString? get(ByteString name);
  sequence&lt;ByteString> getAll(ByteString name);
  boolean has(ByteString name);
  void set(ByteString name, ByteString value);
  iterable&lt;ByteString, ByteString>;
};
typedef any JSON;
typedef (<ref>Blob</ref> or <ref>BufferSource</ref> or <ref>FormData</ref> or <ref>URLSearchParams</ref> or USVString) BodyInit;
[NoInterfaceObject,
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Body {
  readonly attribute boolean bodyUsed;
  [NewObject] Promise&lt;<ref>ArrayBuffer</ref>> arrayBuffer();
  [NewObject] Promise&lt;<ref>Blob</ref>> blob();
  [NewObject] Promise&lt;<ref>FormData</ref>> formData();
  [NewObject] Promise&lt;<ref>JSON</ref>> json();
  [NewObject] Promise&lt;USVString> text();
};
typedef (<ref>Request</ref> or USVString) RequestInfo;

[Constructor(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Request {
  readonly attribute ByteString method;
  readonly attribute USVString url;
  [SameObject] readonly attribute <ref>Headers</ref> headers;

  readonly attribute <ref>RequestType</ref> type;
  readonly attribute <ref>RequestDestination</ref> destination;
  readonly attribute USVString referrer;
  readonly attribute <ref>ReferrerPolicy</ref> referrerPolicy;
  readonly attribute <ref>RequestMode</ref> mode;
  readonly attribute <ref>RequestCredentials</ref> credentials;
  readonly attribute <ref>RequestCache</ref> cache;
  readonly attribute <ref>RequestRedirect</ref> redirect;
  readonly attribute DOMString integrity;

  [NewObject] <ref>Request</ref> clone();
};
<ref>Request</ref> implements <ref>Body</ref>;

dictionary RequestInit {
  ByteString method;
  <ref>HeadersInit</ref> headers;
  <ref>BodyInit</ref>? body;
  USVString referrer;
  <ref>ReferrerPolicy</ref> referrerPolicy;
  <ref>RequestMode</ref> mode;
  <ref>RequestCredentials</ref> credentials;
  <ref>RequestCache</ref> cache;
  <ref>RequestRedirect</ref> redirect;
  DOMString integrity;
  any window; 
};

enum RequestType { &quot;&quot;, &quot;audio&quot;, &quot;font&quot;, &quot;image&quot;, &quot;script&quot;, &quot;style&quot;, &quot;track&quot;, &quot;video&quot; };
enum RequestDestination { &quot;&quot;, &quot;document&quot;, &quot;sharedworker&quot;, &quot;subresource&quot;, &quot;unknown&quot;, &quot;worker&quot; };
enum RequestMode { &quot;navigate&quot;, &quot;same-origin&quot;, &quot;no-cors&quot;, &quot;cors&quot; };
enum RequestCredentials { &quot;omit&quot;, &quot;same-origin&quot;, &quot;include&quot; };
enum RequestCache { &quot;default&quot;, &quot;no-store&quot;, &quot;reload&quot;, &quot;no-cache&quot;, &quot;force-cache&quot; };
enum RequestRedirect { &quot;follow&quot;, &quot;error&quot;, &quot;manual&quot; };
[Constructor(optional <ref>BodyInit</ref>? body = null, optional <ref>ResponseInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Response {
  [NewObject] static <ref>Response</ref> error();
  [NewObject] static <ref>Response</ref> redirect(USVString url, optional unsigned short status = 302);

  readonly attribute <ref>ResponseType</ref> type;

  readonly attribute USVString url;
  readonly attribute unsigned short status;
  readonly attribute boolean ok;
  readonly attribute ByteString statusText;
  [SameObject] readonly attribute <ref>Headers</ref> headers;
  readonly attribute <ref>ReadableStream</ref>? body;

  [NewObject] <ref>Response</ref> clone();
};
<ref>Response</ref> implements <ref>Body</ref>;

dictionary ResponseInit {
  unsigned short status = 200;
  ByteString statusText = &quot;OK&quot;;
  <ref>HeadersInit</ref> headers;
};

enum ResponseType { &quot;basic&quot;, &quot;cors&quot;, &quot;default&quot;, &quot;error&quot;, &quot;opaque&quot;, &quot;opaqueredirect&quot; };
[NoInterfaceObject,
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface GlobalFetch {
  [NewObject] Promise&lt;<ref>Response</ref>> fetch(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init);
};
<ref>Window</ref> implements <ref>GlobalFetch</ref>;
<ref>WorkerGlobalScope</ref> implements <ref>GlobalFetch</ref>;</webidl>
  <Enum name="ReferrerPolicy" id="::ReferrerPolicy">
    <webidl>enum ReferrerPolicy {
  &quot;&quot;,
  &quot;no-referrer&quot;,
  &quot;no-referrer-when-downgrade&quot;,
  &quot;origin-only&quot;,
  &quot;origin-when-cross-origin&quot;,
  &quot;unsafe-url&quot;
};</webidl>
    <EnumValue stringvalue="">
      <webidl>  &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="no-referrer">
      <webidl>  &quot;no-referrer</webidl>
    </EnumValue>
    <EnumValue stringvalue="no-referrer-when-downgrade">
      <webidl>  &quot;no-referrer-when-downgrade</webidl>
    </EnumValue>
    <EnumValue stringvalue="origin-only">
      <webidl>  &quot;origin-only</webidl>
    </EnumValue>
    <EnumValue stringvalue="origin-when-cross-origin">
      <webidl>  &quot;origin-when-cross-origin</webidl>
    </EnumValue>
    <EnumValue stringvalue="unsafe-url">
      <webidl>  &quot;unsafe-url</webidl>
    </EnumValue>
  </Enum>
  <Typedef name="HeadersInit" id="::HeadersInit">
    <webidl>typedef (<ref>Headers</ref> or sequence&lt;sequence&lt;ByteString>>) HeadersInit;</webidl>
    <Type type="union">
      <Type name="Headers"/>
      <Type type="sequence">
        <Type type="sequence">
          <Type type="ByteString"/>
        </Type>
      </Type>
    </Type>
  </Typedef>
  <Interface name="Headers" id="::Headers">
    <webidl>[Constructor(optional <ref>HeadersInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Headers {
  void append(ByteString name, ByteString value);
  void delete(ByteString name);
  ByteString? get(ByteString name);
  sequence&lt;ByteString> getAll(ByteString name);
  boolean has(ByteString name);
  void set(ByteString name, ByteString value);
  iterable&lt;ByteString, ByteString>;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional <ref>HeadersInit</ref> init)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="init">
            <Type name="HeadersInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="append" id="::Headers::append">
      <webidl>  void append(ByteString name, ByteString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
        <Argument name="value">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="delete" id="::Headers::delete">
      <webidl>  void delete(ByteString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="get" id="::Headers::get">
      <webidl>  ByteString? get(ByteString name);</webidl>
      <Type type="ByteString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAll" id="::Headers::getAll">
      <webidl>  sequence&lt;ByteString> getAll(ByteString name);</webidl>
      <Type type="sequence">
        <Type type="ByteString"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="has" id="::Headers::has">
      <webidl>  boolean has(ByteString name);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="set" id="::Headers::set">
      <webidl>  void set(ByteString name, ByteString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="ByteString"/>
        </Argument>
        <Argument name="value">
          <Type type="ByteString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Iterable>
      <webidl>  iterable&lt;ByteString, ByteString>;</webidl>
      <Key>
        <Type type="ByteString"/>
      </Key>
      <Value>
        <Type type="ByteString"/>
      </Value>
    </Iterable>
  </Interface>
  <Typedef name="JSON" id="::JSON">
    <webidl>typedef any JSON;</webidl>
    <Type type="any"/>
  </Typedef>
  <Typedef name="BodyInit" id="::BodyInit">
    <webidl>typedef (<ref>Blob</ref> or <ref>BufferSource</ref> or <ref>FormData</ref> or <ref>URLSearchParams</ref> or USVString) BodyInit;</webidl>
    <Type type="union">
      <Type name="Blob"/>
      <Type name="BufferSource"/>
      <Type name="FormData"/>
      <Type name="URLSearchParams"/>
      <Type type="USVString"/>
    </Type>
  </Typedef>
  <Interface name="Body" id="::Body">
    <webidl>[NoInterfaceObject,
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Body {
  readonly attribute boolean bodyUsed;
  [NewObject] Promise&lt;<ref>ArrayBuffer</ref>> arrayBuffer();
  [NewObject] Promise&lt;<ref>Blob</ref>> blob();
  [NewObject] Promise&lt;<ref>FormData</ref>> formData();
  [NewObject] Promise&lt;<ref>JSON</ref>> json();
  [NewObject] Promise&lt;USVString> text();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="bodyUsed" readonly="readonly" id="::Body::bodyUsed">
      <webidl>  readonly attribute boolean bodyUsed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="arrayBuffer" id="::Body::arrayBuffer">
      <webidl>  [NewObject] Promise&lt;<ref>ArrayBuffer</ref>> arrayBuffer();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type name="ArrayBuffer"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="blob" id="::Body::blob">
      <webidl>  [NewObject] Promise&lt;<ref>Blob</ref>> blob();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type name="Blob"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="formData" id="::Body::formData">
      <webidl>  [NewObject] Promise&lt;<ref>FormData</ref>> formData();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type name="FormData"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="json" id="::Body::json">
      <webidl>  [NewObject] Promise&lt;<ref>JSON</ref>> json();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type name="JSON"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="text" id="::Body::text">
      <webidl>  [NewObject] Promise&lt;USVString> text();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type type="USVString"/>
      </Type>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Typedef name="RequestInfo" id="::RequestInfo">
    <webidl>typedef (<ref>Request</ref> or USVString) RequestInfo;</webidl>
    <Type type="union">
      <Type name="Request"/>
      <Type type="USVString"/>
    </Type>
  </Typedef>
  <Interface name="Request" id="::Request">
    <webidl>[Constructor(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Request {
  readonly attribute ByteString method;
  readonly attribute USVString url;
  [SameObject] readonly attribute <ref>Headers</ref> headers;

  readonly attribute <ref>RequestType</ref> type;
  readonly attribute <ref>RequestDestination</ref> destination;
  readonly attribute USVString referrer;
  readonly attribute <ref>ReferrerPolicy</ref> referrerPolicy;
  readonly attribute <ref>RequestMode</ref> mode;
  readonly attribute <ref>RequestCredentials</ref> credentials;
  readonly attribute <ref>RequestCache</ref> cache;
  readonly attribute <ref>RequestRedirect</ref> redirect;
  readonly attribute DOMString integrity;

  [NewObject] <ref>Request</ref> clone();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init)</webidl>
        <ArgumentList>
          <Argument name="input">
            <Type name="RequestInfo"/>
          </Argument>
          <Argument optional="optional" name="init">
            <Type name="RequestInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="method" readonly="readonly" id="::Request::method">
      <webidl>  readonly attribute ByteString method;</webidl>
      <Type type="ByteString"/>
    </Attribute>
    <Attribute name="url" readonly="readonly" id="::Request::url">
      <webidl>  readonly attribute USVString url;</webidl>
      <Type type="USVString"/>
    </Attribute>
    <Attribute name="headers" readonly="readonly" id="::Request::headers">
      <webidl>  [SameObject] readonly attribute <ref>Headers</ref> headers;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Headers"/>
    </Attribute>
    <Attribute name="type" readonly="readonly" id="::Request::type">
      <webidl>  readonly attribute <ref>RequestType</ref> type;</webidl>
      <Type name="RequestType"/>
    </Attribute>
    <Attribute name="destination" readonly="readonly" id="::Request::destination">
      <webidl>  readonly attribute <ref>RequestDestination</ref> destination;</webidl>
      <Type name="RequestDestination"/>
    </Attribute>
    <Attribute name="referrer" readonly="readonly" id="::Request::referrer">
      <webidl>  readonly attribute USVString referrer;</webidl>
      <Type type="USVString"/>
    </Attribute>
    <Attribute name="referrerPolicy" readonly="readonly" id="::Request::referrerPolicy">
      <webidl>  readonly attribute <ref>ReferrerPolicy</ref> referrerPolicy;</webidl>
      <Type name="ReferrerPolicy"/>
    </Attribute>
    <Attribute name="mode" readonly="readonly" id="::Request::mode">
      <webidl>  readonly attribute <ref>RequestMode</ref> mode;</webidl>
      <Type name="RequestMode"/>
    </Attribute>
    <Attribute name="credentials" readonly="readonly" id="::Request::credentials">
      <webidl>  readonly attribute <ref>RequestCredentials</ref> credentials;</webidl>
      <Type name="RequestCredentials"/>
    </Attribute>
    <Attribute name="cache" readonly="readonly" id="::Request::cache">
      <webidl>  readonly attribute <ref>RequestCache</ref> cache;</webidl>
      <Type name="RequestCache"/>
    </Attribute>
    <Attribute name="redirect" readonly="readonly" id="::Request::redirect">
      <webidl>  readonly attribute <ref>RequestRedirect</ref> redirect;</webidl>
      <Type name="RequestRedirect"/>
    </Attribute>
    <Attribute name="integrity" readonly="readonly" id="::Request::integrity">
      <webidl>  readonly attribute DOMString integrity;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="clone" id="::Request::clone">
      <webidl>  [NewObject] <ref>Request</ref> clone();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Request"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Request" name2="Body">
    <webidl><ref>Request</ref> implements <ref>Body</ref>;</webidl>
  </Implements>
  <Dictionary name="RequestInit" id="::RequestInit">
    <webidl>dictionary RequestInit {
  ByteString method;
  <ref>HeadersInit</ref> headers;
  <ref>BodyInit</ref>? body;
  USVString referrer;
  <ref>ReferrerPolicy</ref> referrerPolicy;
  <ref>RequestMode</ref> mode;
  <ref>RequestCredentials</ref> credentials;
  <ref>RequestCache</ref> cache;
  <ref>RequestRedirect</ref> redirect;
  DOMString integrity;
  any window; 
};</webidl>
    <DictionaryMember name="method" id="::RequestInit::method">
      <webidl>  ByteString method;</webidl>
      <Type type="ByteString"/>
    </DictionaryMember>
    <DictionaryMember name="headers" id="::RequestInit::headers">
      <webidl>  <ref>HeadersInit</ref> headers;</webidl>
      <Type name="HeadersInit"/>
    </DictionaryMember>
    <DictionaryMember name="body" id="::RequestInit::body">
      <webidl>  <ref>BodyInit</ref>? body;</webidl>
      <Type name="BodyInit" nullable="nullable"/>
    </DictionaryMember>
    <DictionaryMember name="referrer" id="::RequestInit::referrer">
      <webidl>  USVString referrer;</webidl>
      <Type type="USVString"/>
    </DictionaryMember>
    <DictionaryMember name="referrerPolicy" id="::RequestInit::referrerPolicy">
      <webidl>  <ref>ReferrerPolicy</ref> referrerPolicy;</webidl>
      <Type name="ReferrerPolicy"/>
    </DictionaryMember>
    <DictionaryMember name="mode" id="::RequestInit::mode">
      <webidl>  <ref>RequestMode</ref> mode;</webidl>
      <Type name="RequestMode"/>
    </DictionaryMember>
    <DictionaryMember name="credentials" id="::RequestInit::credentials">
      <webidl>  <ref>RequestCredentials</ref> credentials;</webidl>
      <Type name="RequestCredentials"/>
    </DictionaryMember>
    <DictionaryMember name="cache" id="::RequestInit::cache">
      <webidl>  <ref>RequestCache</ref> cache;</webidl>
      <Type name="RequestCache"/>
    </DictionaryMember>
    <DictionaryMember name="redirect" id="::RequestInit::redirect">
      <webidl>  <ref>RequestRedirect</ref> redirect;</webidl>
      <Type name="RequestRedirect"/>
    </DictionaryMember>
    <DictionaryMember name="integrity" id="::RequestInit::integrity">
      <webidl>  DOMString integrity;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="window" id="::RequestInit::window">
      <webidl>  any window;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Enum name="RequestType" id="::RequestType">
    <webidl>enum RequestType { &quot;&quot;, &quot;audio&quot;, &quot;font&quot;, &quot;image&quot;, &quot;script&quot;, &quot;style&quot;, &quot;track&quot;, &quot;video&quot; };</webidl>
    <EnumValue stringvalue="">
      <webidl> &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="audio">
      <webidl> &quot;audio</webidl>
    </EnumValue>
    <EnumValue stringvalue="font">
      <webidl> &quot;font</webidl>
    </EnumValue>
    <EnumValue stringvalue="image">
      <webidl> &quot;image</webidl>
    </EnumValue>
    <EnumValue stringvalue="script">
      <webidl> &quot;script</webidl>
    </EnumValue>
    <EnumValue stringvalue="style">
      <webidl> &quot;style</webidl>
    </EnumValue>
    <EnumValue stringvalue="track">
      <webidl> &quot;track</webidl>
    </EnumValue>
    <EnumValue stringvalue="video">
      <webidl> &quot;video</webidl>
    </EnumValue>
  </Enum>
  <Enum name="RequestDestination" id="::RequestDestination">
    <webidl>enum RequestDestination { &quot;&quot;, &quot;document&quot;, &quot;sharedworker&quot;, &quot;subresource&quot;, &quot;unknown&quot;, &quot;worker&quot; };</webidl>
    <EnumValue stringvalue="">
      <webidl> &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="document">
      <webidl> &quot;document</webidl>
    </EnumValue>
    <EnumValue stringvalue="sharedworker">
      <webidl> &quot;sharedworker</webidl>
    </EnumValue>
    <EnumValue stringvalue="subresource">
      <webidl> &quot;subresource</webidl>
    </EnumValue>
    <EnumValue stringvalue="unknown">
      <webidl> &quot;unknown</webidl>
    </EnumValue>
    <EnumValue stringvalue="worker">
      <webidl> &quot;worker</webidl>
    </EnumValue>
  </Enum>
  <Enum name="RequestMode" id="::RequestMode">
    <webidl>enum RequestMode { &quot;navigate&quot;, &quot;same-origin&quot;, &quot;no-cors&quot;, &quot;cors&quot; };</webidl>
    <EnumValue stringvalue="navigate">
      <webidl> &quot;navigate</webidl>
    </EnumValue>
    <EnumValue stringvalue="same-origin">
      <webidl> &quot;same-origin</webidl>
    </EnumValue>
    <EnumValue stringvalue="no-cors">
      <webidl> &quot;no-cors</webidl>
    </EnumValue>
    <EnumValue stringvalue="cors">
      <webidl> &quot;cors</webidl>
    </EnumValue>
  </Enum>
  <Enum name="RequestCredentials" id="::RequestCredentials">
    <webidl>enum RequestCredentials { &quot;omit&quot;, &quot;same-origin&quot;, &quot;include&quot; };</webidl>
    <EnumValue stringvalue="omit">
      <webidl> &quot;omit</webidl>
    </EnumValue>
    <EnumValue stringvalue="same-origin">
      <webidl> &quot;same-origin</webidl>
    </EnumValue>
    <EnumValue stringvalue="include">
      <webidl> &quot;include</webidl>
    </EnumValue>
  </Enum>
  <Enum name="RequestCache" id="::RequestCache">
    <webidl>enum RequestCache { &quot;default&quot;, &quot;no-store&quot;, &quot;reload&quot;, &quot;no-cache&quot;, &quot;force-cache&quot; };</webidl>
    <EnumValue stringvalue="default">
      <webidl> &quot;default</webidl>
    </EnumValue>
    <EnumValue stringvalue="no-store">
      <webidl> &quot;no-store</webidl>
    </EnumValue>
    <EnumValue stringvalue="reload">
      <webidl> &quot;reload</webidl>
    </EnumValue>
    <EnumValue stringvalue="no-cache">
      <webidl> &quot;no-cache</webidl>
    </EnumValue>
    <EnumValue stringvalue="force-cache">
      <webidl> &quot;force-cache</webidl>
    </EnumValue>
  </Enum>
  <Enum name="RequestRedirect" id="::RequestRedirect">
    <webidl>enum RequestRedirect { &quot;follow&quot;, &quot;error&quot;, &quot;manual&quot; };</webidl>
    <EnumValue stringvalue="follow">
      <webidl> &quot;follow</webidl>
    </EnumValue>
    <EnumValue stringvalue="error">
      <webidl> &quot;error</webidl>
    </EnumValue>
    <EnumValue stringvalue="manual">
      <webidl> &quot;manual</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Response" id="::Response">
    <webidl>[Constructor(optional <ref>BodyInit</ref>? body = null, optional <ref>ResponseInit</ref> init),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Response {
  [NewObject] static <ref>Response</ref> error();
  [NewObject] static <ref>Response</ref> redirect(USVString url, optional unsigned short status = 302);

  readonly attribute <ref>ResponseType</ref> type;

  readonly attribute USVString url;
  readonly attribute unsigned short status;
  readonly attribute boolean ok;
  readonly attribute ByteString statusText;
  [SameObject] readonly attribute <ref>Headers</ref> headers;
  readonly attribute <ref>ReadableStream</ref>? body;

  [NewObject] <ref>Response</ref> clone();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional <ref>BodyInit</ref>? body = null, optional <ref>ResponseInit</ref> init)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="body" value="null">
            <Type name="BodyInit" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="init">
            <Type name="ResponseInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation static="static" name="error" id="::Response::error">
      <webidl>  [NewObject] static <ref>Response</ref> error();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Response"/>
      <ArgumentList/>
    </Operation>
    <Operation static="static" name="redirect" id="::Response::redirect">
      <webidl>  [NewObject] static <ref>Response</ref> redirect(USVString url, optional unsigned short status = 302);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Response"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="USVString"/>
        </Argument>
        <Argument optional="optional" name="status" value="302">
          <Type type="unsigned short"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="type" readonly="readonly" id="::Response::type">
      <webidl>  readonly attribute <ref>ResponseType</ref> type;</webidl>
      <Type name="ResponseType"/>
    </Attribute>
    <Attribute name="url" readonly="readonly" id="::Response::url">
      <webidl>  readonly attribute USVString url;</webidl>
      <Type type="USVString"/>
    </Attribute>
    <Attribute name="status" readonly="readonly" id="::Response::status">
      <webidl>  readonly attribute unsigned short status;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="ok" readonly="readonly" id="::Response::ok">
      <webidl>  readonly attribute boolean ok;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="statusText" readonly="readonly" id="::Response::statusText">
      <webidl>  readonly attribute ByteString statusText;</webidl>
      <Type type="ByteString"/>
    </Attribute>
    <Attribute name="headers" readonly="readonly" id="::Response::headers">
      <webidl>  [SameObject] readonly attribute <ref>Headers</ref> headers;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Headers"/>
    </Attribute>
    <Attribute name="body" readonly="readonly" id="::Response::body">
      <webidl>  readonly attribute <ref>ReadableStream</ref>? body;</webidl>
      <Type name="ReadableStream" nullable="nullable"/>
    </Attribute>
    <Operation name="clone" id="::Response::clone">
      <webidl>  [NewObject] <ref>Response</ref> clone();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Response"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Response" name2="Body">
    <webidl><ref>Response</ref> implements <ref>Body</ref>;</webidl>
  </Implements>
  <Dictionary name="ResponseInit" id="::ResponseInit">
    <webidl>dictionary ResponseInit {
  unsigned short status = 200;
  ByteString statusText = &quot;OK&quot;;
  <ref>HeadersInit</ref> headers;
};</webidl>
    <DictionaryMember name="status" value="200" id="::ResponseInit::status">
      <webidl>  unsigned short status = 200;</webidl>
      <Type type="unsigned short"/>
    </DictionaryMember>
    <DictionaryMember name="statusText" stringvalue="OK" id="::ResponseInit::statusText">
      <webidl>  ByteString statusText = &quot;OK&quot;;</webidl>
      <Type type="ByteString"/>
    </DictionaryMember>
    <DictionaryMember name="headers" id="::ResponseInit::headers">
      <webidl>  <ref>HeadersInit</ref> headers;</webidl>
      <Type name="HeadersInit"/>
    </DictionaryMember>
  </Dictionary>
  <Enum name="ResponseType" id="::ResponseType">
    <webidl>enum ResponseType { &quot;basic&quot;, &quot;cors&quot;, &quot;default&quot;, &quot;error&quot;, &quot;opaque&quot;, &quot;opaqueredirect&quot; };</webidl>
    <EnumValue stringvalue="basic">
      <webidl> &quot;basic</webidl>
    </EnumValue>
    <EnumValue stringvalue="cors">
      <webidl> &quot;cors</webidl>
    </EnumValue>
    <EnumValue stringvalue="default">
      <webidl> &quot;default</webidl>
    </EnumValue>
    <EnumValue stringvalue="error">
      <webidl> &quot;error</webidl>
    </EnumValue>
    <EnumValue stringvalue="opaque">
      <webidl> &quot;opaque</webidl>
    </EnumValue>
    <EnumValue stringvalue="opaqueredirect">
      <webidl> &quot;opaqueredirect</webidl>
    </EnumValue>
  </Enum>
  <Interface name="GlobalFetch" id="::GlobalFetch">
    <webidl>[NoInterfaceObject,
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface GlobalFetch {
  [NewObject] Promise&lt;<ref>Response</ref>> fetch(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="fetch" id="::GlobalFetch::fetch">
      <webidl>  [NewObject] Promise&lt;<ref>Response</ref>> fetch(<ref>RequestInfo</ref> input, optional <ref>RequestInit</ref> init);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="Promise">
        <Type name="Response"/>
      </Type>
      <ArgumentList>
        <Argument name="input">
          <Type name="RequestInfo"/>
        </Argument>
        <Argument optional="optional" name="init">
          <Type name="RequestInit"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="GlobalFetch">
    <webidl><ref>Window</ref> implements <ref>GlobalFetch</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerGlobalScope" name2="GlobalFetch">
    <webidl><ref>WorkerGlobalScope</ref> implements <ref>GlobalFetch</ref>;</webidl>
  </Implements>
</Definitions>
<Definitions>
  <webidl>    interface FileList {
      getter <ref>File</ref>? item(unsigned long index);
      readonly attribute unsigned long length;
    };
    

    [Constructor, 
     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)] 
    interface Blob {
      
      readonly attribute unsigned long long size;
      readonly attribute DOMString type;
      
      
      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);
      void close(); 
    
    };

    dictionary BlobPropertyBag {
                
      DOMString type = &quot;&quot;;
        
    };
    

interface File : <ref>Blob</ref> {

  readonly attribute DOMString name;
  readonly attribute Date lastModifiedDate;

};
          


        [Constructor]
        interface FileReader: <ref>EventTarget</ref> {

          void readAsArrayBuffer(<ref>Blob</ref> blob);
          void readAsText(<ref>Blob</ref> blob, optional DOMString label);
          void readAsDataURL(<ref>Blob</ref> blob);

          void abort();

          const unsigned short EMPTY = 0;
          const unsigned short LOADING = 1;
          const unsigned short DONE = 2;


          readonly attribute unsigned short readyState;

          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;

          readonly attribute <ref>DOMError</ref>? error;

          attribute <ref>EventHandler</ref> onloadstart;
          attribute <ref>EventHandler</ref> onprogress;
          attribute <ref>EventHandler</ref> onload;
          attribute <ref>EventHandler</ref> onabort;
          attribute <ref>EventHandler</ref> onerror;
          attribute <ref>EventHandler</ref> onloadend;

        };
          


        [Constructor]
        interface FileReaderSync {


          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob); 
          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);
          DOMString readAsDataURL(<ref>Blob</ref> blob);
        };
        

        partial interface URL {

            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);
            static void revokeObjectURL(DOMString url);
        };
        
        dictionary objectURLOptions
        {
                boolean autoRevoke = true;

        };</webidl>
  <Interface name="FileList" id="::FileList">
    <webidl>    interface FileList {
      getter <ref>File</ref>? item(unsigned long index);
      readonly attribute unsigned long length;
    };</webidl>
    <Operation getter="getter" name="item" id="::FileList::item">
      <webidl>      getter <ref>File</ref>? item(unsigned long index);</webidl>
      <Type name="File" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="length" id="::FileList::length">
      <webidl>      readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="Blob" id="::Blob">
    <webidl>    [Constructor, 
     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)] 
    interface Blob {
      
      readonly attribute unsigned long long size;
      readonly attribute DOMString type;
      
      
      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);
      void close(); 
    
    };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Constructor">
        <webidl>     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)</webidl>
        <ArgumentList>
          <Argument name="blobParts">
            <Type type="sequence">
              <Type type="union">
                <Type name="ArrayBuffer"/>
                <Type name="ArrayBufferView"/>
                <Type name="Blob"/>
                <Type type="DOMString"/>
              </Type>
            </Type>
          </Argument>
          <Argument optional="optional" name="options">
            <Type name="BlobPropertyBag"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="size" id="::Blob::size">
      <webidl>      readonly attribute unsigned long long size;</webidl>
      <Type type="unsigned long long"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::Blob::type">
      <webidl>      readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="slice" id="::Blob::slice">
      <webidl>      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);</webidl>
      <Type name="Blob"/>
      <ArgumentList>
        <Argument optional="optional" name="start">
          <Type type="long long"/>
        </Argument>
        <Argument optional="optional" name="end">
          <Type type="long long"/>
        </Argument>
        <Argument optional="optional" name="contentType">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::Blob::close">
      <webidl>      void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Dictionary name="BlobPropertyBag" id="::BlobPropertyBag">
    <webidl>    dictionary BlobPropertyBag {
                
      DOMString type = &quot;&quot;;
        
    };</webidl>
    <DictionaryMember name="type" stringvalue="" id="::BlobPropertyBag::type">
      <webidl>      DOMString type = &quot;&quot;;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="File" id="::File">
    <webidl>interface File : <ref>Blob</ref> {

  readonly attribute DOMString name;
  readonly attribute Date lastModifiedDate;

};</webidl>
    <InterfaceInheritance>
      <Name name="Blob"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="name" id="::File::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="lastModifiedDate" id="::File::lastModifiedDate">
      <webidl>  readonly attribute Date lastModifiedDate;</webidl>
      <Type type="Date"/>
    </Attribute>
  </Interface>
  <Interface name="FileReader" id="::FileReader">
    <webidl>        [Constructor]
        interface FileReader: <ref>EventTarget</ref> {

          void readAsArrayBuffer(<ref>Blob</ref> blob);
          void readAsText(<ref>Blob</ref> blob, optional DOMString label);
          void readAsDataURL(<ref>Blob</ref> blob);

          void abort();

          const unsigned short EMPTY = 0;
          const unsigned short LOADING = 1;
          const unsigned short DONE = 2;


          readonly attribute unsigned short readyState;

          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;

          readonly attribute <ref>DOMError</ref>? error;

          attribute <ref>EventHandler</ref> onloadstart;
          attribute <ref>EventHandler</ref> onprogress;
          attribute <ref>EventHandler</ref> onload;
          attribute <ref>EventHandler</ref> onabort;
          attribute <ref>EventHandler</ref> onerror;
          attribute <ref>EventHandler</ref> onloadend;

        };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Operation name="readAsArrayBuffer" id="::FileReader::readAsArrayBuffer">
      <webidl>          void readAsArrayBuffer(<ref>Blob</ref> blob);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsText" id="::FileReader::readAsText">
      <webidl>          void readAsText(<ref>Blob</ref> blob, optional DOMString label);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="label">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsDataURL" id="::FileReader::readAsDataURL">
      <webidl>          void readAsDataURL(<ref>Blob</ref> blob);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="abort" id="::FileReader::abort">
      <webidl>          void abort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Const name="EMPTY" value="0" id="::FileReader::EMPTY">
      <webidl>          const unsigned short EMPTY = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADING" value="1" id="::FileReader::LOADING">
      <webidl>          const unsigned short LOADING = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DONE" value="2" id="::FileReader::DONE">
      <webidl>          const unsigned short DONE = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::FileReader::readyState">
      <webidl>          readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="result" id="::FileReader::result">
      <webidl>          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;</webidl>
      <Type type="union" nullable="nullable">
        <Type type="DOMString"/>
        <Type name="ArrayBuffer"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="error" id="::FileReader::error">
      <webidl>          readonly attribute <ref>DOMError</ref>? error;</webidl>
      <Type name="DOMError" nullable="nullable"/>
    </Attribute>
    <Attribute name="onloadstart" id="::FileReader::onloadstart">
      <webidl>          attribute <ref>EventHandler</ref> onloadstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::FileReader::onprogress">
      <webidl>          attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onload" id="::FileReader::onload">
      <webidl>          attribute <ref>EventHandler</ref> onload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onabort" id="::FileReader::onabort">
      <webidl>          attribute <ref>EventHandler</ref> onabort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::FileReader::onerror">
      <webidl>          attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadend" id="::FileReader::onloadend">
      <webidl>          attribute <ref>EventHandler</ref> onloadend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="FileReaderSync" id="::FileReaderSync">
    <webidl>        [Constructor]
        interface FileReaderSync {


          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob); 
          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);
          DOMString readAsDataURL(<ref>Blob</ref> blob);
        };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="readAsArrayBuffer" id="::FileReaderSync::readAsArrayBuffer">
      <webidl>          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob);</webidl>
      <Type name="ArrayBuffer"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsText" id="::FileReaderSync::readAsText">
      <webidl>          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="label">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsDataURL" id="::FileReaderSync::readAsDataURL">
      <webidl>          DOMString readAsDataURL(<ref>Blob</ref> blob);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="URL" partial="partial" id="::URL">
    <webidl>        partial interface URL {

            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);
            static void revokeObjectURL(DOMString url);
        };</webidl>
    <Operation static="static" name="createObjectURL" id="::URL::createObjectURL">
      <webidl>            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type name="objectURLOptions"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation static="static" name="revokeObjectURL" id="::URL::revokeObjectURL">
      <webidl>            static void revokeObjectURL(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="objectURLOptions" id="::objectURLOptions">
    <webidl>        dictionary objectURLOptions
        {
                boolean autoRevoke = true;

        };</webidl>
    <DictionaryMember name="autoRevoke" value="true" id="::objectURLOptions::autoRevoke">
      <webidl>                boolean autoRevoke = true;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
</Definitions>
</Module>
