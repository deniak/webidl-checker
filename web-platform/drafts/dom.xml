<Definitions>
  <webidl>[Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute <ref>EventTarget</ref>? target;
  readonly attribute <ref>EventTarget</ref>? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};

[Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface CustomEvent : <ref>Event</ref> {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};

dictionary CustomEventInit : <ref>EventInit</ref> {
  any detail = null;
};

[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface EventTarget {
  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  boolean dispatchEvent(<ref>Event</ref> event);
};

callback interface EventListener {
  void handleEvent(<ref>Event</ref> event);
};

dictionary EventListenerOptions {
  boolean capture;
  boolean passive;
};

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonElementParentNode {
  <ref>Element</ref>? getElementById(DOMString elementId);
};
<ref>Document</ref> implements <ref>NonElementParentNode</ref>;
<ref>DocumentFragment</ref> implements <ref>NonElementParentNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ParentNode {
  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;
  readonly attribute <ref>Element</ref>? firstElementChild;
  readonly attribute <ref>Element</ref>? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);

  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);
  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);
  <ref>Element</ref>? querySelector(DOMString selectors);
  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);
};
<ref>Document</ref> implements <ref>ParentNode</ref>;
<ref>DocumentFragment</ref> implements <ref>ParentNode</ref>;
<ref>Element</ref> implements <ref>ParentNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonDocumentTypeChildNode {
  readonly attribute <ref>Element</ref>? previousElementSibling;
  readonly attribute <ref>Element</ref>? nextElementSibling;
};
<ref>Element</ref> implements <ref>NonDocumentTypeChildNode</ref>;
<ref>CharacterData</ref> implements <ref>NonDocumentTypeChildNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ChildNode {
  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void remove();
};
<ref>DocumentType</ref> implements <ref>ChildNode</ref>;
<ref>Element</ref> implements <ref>ChildNode</ref>;
<ref>CharacterData</ref> implements <ref>ChildNode</ref>;

interface Elements : <ref>Array</ref> {
  <ref>Element</ref>? query(DOMString relativeSelectors);
  <ref>Elements</ref> queryAll(DOMString relativeSelectors);
};

[Exposed=<ref>Window</ref>]
interface NodeList {
  getter <ref>Node</ref>? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;<ref>Node</ref>>;
};

[Exposed=<ref>Window</ref>]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  getter <ref>Element</ref>? namedItem(DOMString name);
};

[Constructor(<ref>MutationCallback</ref> callback)]
interface MutationObserver {
  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);
  void disconnect();
  sequence&lt;<ref>MutationRecord</ref>> takeRecords();
};

callback MutationCallback = void (sequence&lt;<ref>MutationRecord</ref>> mutations, <ref>MutationObserver</ref> observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};

[Exposed=<ref>Window</ref>]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute <ref>Node</ref> target;
  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;
  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};

[Exposed=<ref>Window</ref>]
interface Node : <ref>EventTarget</ref> {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; 
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; 
  const unsigned short ENTITY_REFERENCE_NODE = 5; 
  const unsigned short ENTITY_NODE = 6; 
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; 
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString baseURI;

  readonly attribute <ref>Document</ref>? ownerDocument;
  readonly attribute <ref>Node</ref>? parentNode;
  readonly attribute <ref>Element</ref>? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;
  readonly attribute <ref>Node</ref>? firstChild;
  readonly attribute <ref>Node</ref>? lastChild;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);
  boolean isEqualNode(<ref>Node</ref>? otherNode);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(<ref>Node</ref> other);
  boolean contains(<ref>Node</ref>? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);
  <ref>Node</ref> appendChild(<ref>Node</ref> node);
  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);
  <ref>Node</ref> removeChild(<ref>Node</ref> child);
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface Document : <ref>Node</ref> {
  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; 
  readonly attribute DOMString inputEncoding; 
  readonly attribute DOMString contentType;

  readonly attribute <ref>DocumentType</ref>? doctype;
  readonly attribute <ref>Element</ref>? documentElement;
  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);

  [NewObject] <ref>Element</ref> createElement(DOMString localName);
  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();
  [NewObject] <ref>Text</ref> createTextNode(DOMString data);
  [NewObject] <ref>Comment</ref> createComment(DOMString data);
  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);
  <ref>Node</ref> adoptNode(<ref>Node</ref> node);

  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);
  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] <ref>Event</ref> createEvent(DOMString interface);

  [NewObject] <ref>Range</ref> createRange();

  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
};

[Exposed=<ref>Window</ref>]
interface XMLDocument : <ref>Document</ref> {};

[Exposed=<ref>Window</ref>]
interface DOMImplementation {
  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);
  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);

  boolean hasFeature(); 
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface DocumentFragment : <ref>Node</ref> {
};

[Exposed=<ref>Window</ref>]
interface DocumentType : <ref>Node</ref> {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};

[Exposed=<ref>Window</ref>]
interface Element : <ref>Node</ref> {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;

  boolean hasAttributes();
  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;
  sequence&lt;DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);
  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);

  <ref>Element</ref>? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); 

  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);
};
[Exposed=<ref>Window</ref>]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter <ref>Attr</ref>? item(unsigned long index);
  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);
  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);
  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);
};

[Exposed=<ref>Window</ref>]
interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
  [TreatNullAs=EmptyString] attribute DOMString nodeValue; 
  [TreatNullAs=EmptyString] attribute DOMString textContent; 

  readonly attribute <ref>Element</ref>? ownerElement;

  readonly attribute boolean specified; 
};
[Exposed=<ref>Window</ref>]
interface CharacterData : <ref>Node</ref> {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};

[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Text : <ref>CharacterData</ref> {
  [NewObject] <ref>Text</ref> splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};
[Exposed=<ref>Window</ref>]
interface ProcessingInstruction : <ref>CharacterData</ref> {
  readonly attribute DOMString target;
};
[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Comment : <ref>CharacterData</ref> {
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface Range {
  readonly attribute <ref>Node</ref> startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute <ref>Node</ref> endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute <ref>Node</ref> commonAncestorContainer;

  void setStart(<ref>Node</ref> node, unsigned long offset);
  void setEnd(<ref>Node</ref> node, unsigned long offset);
  void setStartBefore(<ref>Node</ref> node);
  void setStartAfter(<ref>Node</ref> node);
  void setEndBefore(<ref>Node</ref> node);
  void setEndAfter(<ref>Node</ref> node);
  void collapse(optional boolean toStart = false);
  void selectNode(<ref>Node</ref> node);
  void selectNodeContents(<ref>Node</ref> node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);

  void deleteContents();
  [NewObject] <ref>DocumentFragment</ref> extractContents();
  [NewObject] <ref>DocumentFragment</ref> cloneContents();
  void insertNode(<ref>Node</ref> node);
  void surroundContents(<ref>Node</ref> newParent);

  [NewObject] <ref>Range</ref> cloneRange();
  void detach();

  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);
  short comparePoint(<ref>Node</ref> node, unsigned long offset);

  boolean intersectsNode(<ref>Node</ref> node);

  stringifier;
};

[Exposed=<ref>Window</ref>]
interface NodeIterator {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute <ref>Node</ref> referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;

  <ref>Node</ref>? nextNode();
  <ref>Node</ref>? previousNode();

  void detach();
};

[Exposed=<ref>Window</ref>]
interface TreeWalker {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;
           attribute <ref>Node</ref> currentNode;

  <ref>Node</ref>? parentNode();
  <ref>Node</ref>? firstChild();
  <ref>Node</ref>? lastChild();
  <ref>Node</ref>? previousSibling();
  <ref>Node</ref>? nextSibling();
  <ref>Node</ref>? previousNode();
  <ref>Node</ref>? nextNode();
};
[Exposed=<ref>Window</ref>]
callback interface NodeFilter {
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; 
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; 
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; 
  const unsigned long SHOW_ENTITY = 0x20; 
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; 

  unsigned short acceptNode(<ref>Node</ref> node);
};

interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  void replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  stringifier;
  iterable&lt;DOMString>;
};

interface DOMSettableTokenList : <ref>DOMTokenList</ref> {
            attribute DOMString value;
};

[Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute <ref>EventTarget</ref>? target;
  readonly attribute <ref>EventTarget</ref>? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};

[Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface CustomEvent : <ref>Event</ref> {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};

dictionary CustomEventInit : <ref>EventInit</ref> {
  any detail = null;
};

[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface EventTarget {
  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  boolean dispatchEvent(<ref>Event</ref> event);
};

callback interface EventListener {
  void handleEvent(<ref>Event</ref> event);
};

dictionary EventListenerOptions {
  boolean capture;
  boolean passive;
};

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonElementParentNode {
  <ref>Element</ref>? getElementById(DOMString elementId);
};
<ref>Document</ref> implements <ref>NonElementParentNode</ref>;
<ref>DocumentFragment</ref> implements <ref>NonElementParentNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ParentNode {
  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;
  readonly attribute <ref>Element</ref>? firstElementChild;
  readonly attribute <ref>Element</ref>? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);

  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);
  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);
  <ref>Element</ref>? querySelector(DOMString selectors);
  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);
};
<ref>Document</ref> implements <ref>ParentNode</ref>;
<ref>DocumentFragment</ref> implements <ref>ParentNode</ref>;
<ref>Element</ref> implements <ref>ParentNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonDocumentTypeChildNode {
  readonly attribute <ref>Element</ref>? previousElementSibling;
  readonly attribute <ref>Element</ref>? nextElementSibling;
};
<ref>Element</ref> implements <ref>NonDocumentTypeChildNode</ref>;
<ref>CharacterData</ref> implements <ref>NonDocumentTypeChildNode</ref>;

[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ChildNode {
  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void remove();
};
<ref>DocumentType</ref> implements <ref>ChildNode</ref>;
<ref>Element</ref> implements <ref>ChildNode</ref>;
<ref>CharacterData</ref> implements <ref>ChildNode</ref>;

interface Elements : <ref>Array</ref> {
  <ref>Element</ref>? query(DOMString relativeSelectors);
  <ref>Elements</ref> queryAll(DOMString relativeSelectors);
};

[Exposed=<ref>Window</ref>]
interface NodeList {
  getter <ref>Node</ref>? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;<ref>Node</ref>>;
};

[Exposed=<ref>Window</ref>]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  getter <ref>Element</ref>? namedItem(DOMString name);
};

[Constructor(<ref>MutationCallback</ref> callback)]
interface MutationObserver {
  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);
  void disconnect();
  sequence&lt;<ref>MutationRecord</ref>> takeRecords();
};

callback MutationCallback = void (sequence&lt;<ref>MutationRecord</ref>> mutations, <ref>MutationObserver</ref> observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};

[Exposed=<ref>Window</ref>]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute <ref>Node</ref> target;
  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;
  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};

[Exposed=<ref>Window</ref>]
interface Node : <ref>EventTarget</ref> {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; 
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; 
  const unsigned short ENTITY_REFERENCE_NODE = 5; 
  const unsigned short ENTITY_NODE = 6; 
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; 
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString baseURI;

  readonly attribute <ref>Document</ref>? ownerDocument;
  readonly attribute <ref>Node</ref>? parentNode;
  readonly attribute <ref>Element</ref>? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;
  readonly attribute <ref>Node</ref>? firstChild;
  readonly attribute <ref>Node</ref>? lastChild;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);
  boolean isEqualNode(<ref>Node</ref>? otherNode);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(<ref>Node</ref> other);
  boolean contains(<ref>Node</ref>? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);
  <ref>Node</ref> appendChild(<ref>Node</ref> node);
  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);
  <ref>Node</ref> removeChild(<ref>Node</ref> child);
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface Document : <ref>Node</ref> {
  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; 
  readonly attribute DOMString inputEncoding; 
  readonly attribute DOMString contentType;

  readonly attribute <ref>DocumentType</ref>? doctype;
  readonly attribute <ref>Element</ref>? documentElement;
  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);

  [NewObject] <ref>Element</ref> createElement(DOMString localName);
  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();
  [NewObject] <ref>Text</ref> createTextNode(DOMString data);
  [NewObject] <ref>Comment</ref> createComment(DOMString data);
  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);
  <ref>Node</ref> adoptNode(<ref>Node</ref> node);

  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);
  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] <ref>Event</ref> createEvent(DOMString interface);

  [NewObject] <ref>Range</ref> createRange();

  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
};

[Exposed=<ref>Window</ref>]
interface XMLDocument : <ref>Document</ref> {};

[Exposed=<ref>Window</ref>]
interface DOMImplementation {
  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);
  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);

  boolean hasFeature(); 
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface DocumentFragment : <ref>Node</ref> {
};

[Exposed=<ref>Window</ref>]
interface DocumentType : <ref>Node</ref> {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};

[Exposed=<ref>Window</ref>]
interface Element : <ref>Node</ref> {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;

  boolean hasAttributes();
  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;
  sequence&lt;DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);
  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);

  <ref>Element</ref>? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); 

  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);
};
[Exposed=<ref>Window</ref>]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter <ref>Attr</ref>? item(unsigned long index);
  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);
  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);
  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);
};

[Exposed=<ref>Window</ref>]
interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
  [TreatNullAs=EmptyString] attribute DOMString nodeValue; 
  [TreatNullAs=EmptyString] attribute DOMString textContent; 

  readonly attribute <ref>Element</ref>? ownerElement;

  readonly attribute boolean specified; 
};
[Exposed=<ref>Window</ref>]
interface CharacterData : <ref>Node</ref> {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};

[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Text : <ref>CharacterData</ref> {
  [NewObject] <ref>Text</ref> splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};
[Exposed=<ref>Window</ref>]
interface ProcessingInstruction : <ref>CharacterData</ref> {
  readonly attribute DOMString target;
};
[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Comment : <ref>CharacterData</ref> {
};

[Constructor,
 Exposed=<ref>Window</ref>]
interface Range {
  readonly attribute <ref>Node</ref> startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute <ref>Node</ref> endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute <ref>Node</ref> commonAncestorContainer;

  void setStart(<ref>Node</ref> node, unsigned long offset);
  void setEnd(<ref>Node</ref> node, unsigned long offset);
  void setStartBefore(<ref>Node</ref> node);
  void setStartAfter(<ref>Node</ref> node);
  void setEndBefore(<ref>Node</ref> node);
  void setEndAfter(<ref>Node</ref> node);
  void collapse(optional boolean toStart = false);
  void selectNode(<ref>Node</ref> node);
  void selectNodeContents(<ref>Node</ref> node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);

  void deleteContents();
  [NewObject] <ref>DocumentFragment</ref> extractContents();
  [NewObject] <ref>DocumentFragment</ref> cloneContents();
  void insertNode(<ref>Node</ref> node);
  void surroundContents(<ref>Node</ref> newParent);

  [NewObject] <ref>Range</ref> cloneRange();
  void detach();

  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);
  short comparePoint(<ref>Node</ref> node, unsigned long offset);

  boolean intersectsNode(<ref>Node</ref> node);

  stringifier;
};

[Exposed=<ref>Window</ref>]
interface NodeIterator {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute <ref>Node</ref> referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;

  <ref>Node</ref>? nextNode();
  <ref>Node</ref>? previousNode();

  void detach();
};

[Exposed=<ref>Window</ref>]
interface TreeWalker {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;
           attribute <ref>Node</ref> currentNode;

  <ref>Node</ref>? parentNode();
  <ref>Node</ref>? firstChild();
  <ref>Node</ref>? lastChild();
  <ref>Node</ref>? previousSibling();
  <ref>Node</ref>? nextSibling();
  <ref>Node</ref>? previousNode();
  <ref>Node</ref>? nextNode();
};
[Exposed=<ref>Window</ref>]
callback interface NodeFilter {
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; 
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; 
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; 
  const unsigned long SHOW_ENTITY = 0x20; 
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; 

  unsigned short acceptNode(<ref>Node</ref> node);
};

interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  void replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  stringifier;
  iterable&lt;DOMString>;
};

interface DOMSettableTokenList : <ref>DOMTokenList</ref> {
            attribute DOMString value;
};</webidl>
  <Interface name="Event" id="::Event">
    <webidl>[Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute <ref>EventTarget</ref>? target;
  readonly attribute <ref>EventTarget</ref>? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="EventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="type" readonly="readonly" id="::Event::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" readonly="readonly" id="::Event::target">
      <webidl>  readonly attribute <ref>EventTarget</ref>? target;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
    <Attribute name="currentTarget" readonly="readonly" id="::Event::currentTarget">
      <webidl>  readonly attribute <ref>EventTarget</ref>? currentTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
    <Const name="NONE" value="0" id="::Event::NONE">
      <webidl>  const unsigned short NONE = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CAPTURING_PHASE" value="1" id="::Event::CAPTURING_PHASE">
      <webidl>  const unsigned short CAPTURING_PHASE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="AT_TARGET" value="2" id="::Event::AT_TARGET">
      <webidl>  const unsigned short AT_TARGET = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="BUBBLING_PHASE" value="3" id="::Event::BUBBLING_PHASE">
      <webidl>  const unsigned short BUBBLING_PHASE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="eventPhase" readonly="readonly" id="::Event::eventPhase">
      <webidl>  readonly attribute unsigned short eventPhase;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Operation name="stopPropagation" id="::Event::stopPropagation">
      <webidl>  void stopPropagation();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stopImmediatePropagation" id="::Event::stopImmediatePropagation">
      <webidl>  void stopImmediatePropagation();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="bubbles" readonly="readonly" id="::Event::bubbles">
      <webidl>  readonly attribute boolean bubbles;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="cancelable" readonly="readonly" id="::Event::cancelable">
      <webidl>  readonly attribute boolean cancelable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="preventDefault" id="::Event::preventDefault">
      <webidl>  void preventDefault();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="defaultPrevented" readonly="readonly" id="::Event::defaultPrevented">
      <webidl>  readonly attribute boolean defaultPrevented;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="isTrusted" readonly="readonly" id="::Event::isTrusted">
      <webidl>  [Unforgeable] readonly attribute boolean isTrusted;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="timeStamp" readonly="readonly" id="::Event::timeStamp">
      <webidl>  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;</webidl>
      <Type name="DOMTimeStamp"/>
    </Attribute>
    <Operation name="initEvent" id="::Event::initEvent">
      <webidl>  void initEvent(DOMString type, boolean bubbles, boolean cancelable);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="bubbles">
          <Type type="boolean"/>
        </Argument>
        <Argument name="cancelable">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="EventInit" id="::EventInit">
    <webidl>dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};</webidl>
    <DictionaryMember name="bubbles" value="false" id="::EventInit::bubbles">
      <webidl>  boolean bubbles = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="cancelable" value="false" id="::EventInit::cancelable">
      <webidl>  boolean cancelable = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="CustomEvent" id="::CustomEvent">
    <webidl>[Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface CustomEvent : <ref>Event</ref> {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="CustomEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="detail" readonly="readonly" id="::CustomEvent::detail">
      <webidl>  readonly attribute any detail;</webidl>
      <Type type="any"/>
    </Attribute>
    <Operation name="initCustomEvent" id="::CustomEvent::initCustomEvent">
      <webidl>  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="bubbles">
          <Type type="boolean"/>
        </Argument>
        <Argument name="cancelable">
          <Type type="boolean"/>
        </Argument>
        <Argument name="detail">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="CustomEventInit" id="::CustomEventInit">
    <webidl>dictionary CustomEventInit : <ref>EventInit</ref> {
  any detail = null;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="detail" value="null" id="::CustomEventInit::detail">
      <webidl>  any detail = null;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="EventTarget" id="::EventTarget">
    <webidl>[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface EventTarget {
  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  boolean dispatchEvent(<ref>Event</ref> event);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="addEventListener" id="::EventTarget::addEventListener">
      <webidl>  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="callback">
          <Type name="EventListener" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type type="union">
            <Type name="EventListenerOptions"/>
            <Type type="boolean"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeEventListener" id="::EventTarget::removeEventListener">
      <webidl>  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="callback">
          <Type name="EventListener" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type type="union">
            <Type name="EventListenerOptions"/>
            <Type type="boolean"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="dispatchEvent" id="::EventTarget::dispatchEvent">
      <webidl>  boolean dispatchEvent(<ref>Event</ref> event);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="event">
          <Type name="Event"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="EventListener" callback="callback" id="::EventListener">
    <webidl>callback interface EventListener {
  void handleEvent(<ref>Event</ref> event);
};</webidl>
    <Operation name="handleEvent" id="::EventListener::handleEvent">
      <webidl>  void handleEvent(<ref>Event</ref> event);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="event">
          <Type name="Event"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="EventListenerOptions" id="::EventListenerOptions">
    <webidl>dictionary EventListenerOptions {
  boolean capture;
  boolean passive;
};</webidl>
    <DictionaryMember name="capture" id="::EventListenerOptions::capture">
      <webidl>  boolean capture;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="passive" id="::EventListenerOptions::passive">
      <webidl>  boolean passive;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="NonElementParentNode" id="::NonElementParentNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonElementParentNode {
  <ref>Element</ref>? getElementById(DOMString elementId);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="getElementById" id="::NonElementParentNode::getElementById">
      <webidl>  <ref>Element</ref>? getElementById(DOMString elementId);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="elementId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Document" name2="NonElementParentNode">
    <webidl><ref>Document</ref> implements <ref>NonElementParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="DocumentFragment" name2="NonElementParentNode">
    <webidl><ref>DocumentFragment</ref> implements <ref>NonElementParentNode</ref>;</webidl>
  </Implements>
  <Interface name="ParentNode" id="::ParentNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ParentNode {
  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;
  readonly attribute <ref>Element</ref>? firstElementChild;
  readonly attribute <ref>Element</ref>? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);

  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);
  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);
  <ref>Element</ref>? querySelector(DOMString selectors);
  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="children" readonly="readonly" id="::ParentNode::children">
      <webidl>  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="firstElementChild" readonly="readonly" id="::ParentNode::firstElementChild">
      <webidl>  readonly attribute <ref>Element</ref>? firstElementChild;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="lastElementChild" readonly="readonly" id="::ParentNode::lastElementChild">
      <webidl>  readonly attribute <ref>Element</ref>? lastElementChild;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="childElementCount" readonly="readonly" id="::ParentNode::childElementCount">
      <webidl>  readonly attribute unsigned long childElementCount;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="prepend" id="::ParentNode::prepend">
      <webidl>  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="append" id="::ParentNode::append">
      <webidl>  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="query" id="::ParentNode::query">
      <webidl>  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryAll" id="::ParentNode::queryAll">
      <webidl>  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unscopeable">
          <webidl> Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Elements"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="querySelector" id="::ParentNode::querySelector">
      <webidl>  <ref>Element</ref>? querySelector(DOMString selectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="querySelectorAll" id="::ParentNode::querySelectorAll">
      <webidl>  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Document" name2="ParentNode">
    <webidl><ref>Document</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="DocumentFragment" name2="ParentNode">
    <webidl><ref>DocumentFragment</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="Element" name2="ParentNode">
    <webidl><ref>Element</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Interface name="NonDocumentTypeChildNode" id="::NonDocumentTypeChildNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonDocumentTypeChildNode {
  readonly attribute <ref>Element</ref>? previousElementSibling;
  readonly attribute <ref>Element</ref>? nextElementSibling;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="previousElementSibling" readonly="readonly" id="::NonDocumentTypeChildNode::previousElementSibling">
      <webidl>  readonly attribute <ref>Element</ref>? previousElementSibling;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextElementSibling" readonly="readonly" id="::NonDocumentTypeChildNode::nextElementSibling">
      <webidl>  readonly attribute <ref>Element</ref>? nextElementSibling;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Implements name1="Element" name2="NonDocumentTypeChildNode">
    <webidl><ref>Element</ref> implements <ref>NonDocumentTypeChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="CharacterData" name2="NonDocumentTypeChildNode">
    <webidl><ref>CharacterData</ref> implements <ref>NonDocumentTypeChildNode</ref>;</webidl>
  </Implements>
  <Interface name="ChildNode" id="::ChildNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ChildNode {
  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void remove();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="before" id="::ChildNode::before">
      <webidl>  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="after" id="::ChildNode::after">
      <webidl>  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceWith" id="::ChildNode::replaceWith">
      <webidl>  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::ChildNode::remove">
      <webidl>  [Unscopeable] void remove();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="DocumentType" name2="ChildNode">
    <webidl><ref>DocumentType</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="Element" name2="ChildNode">
    <webidl><ref>Element</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="CharacterData" name2="ChildNode">
    <webidl><ref>CharacterData</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Interface name="Elements" id="::Elements">
    <webidl>interface Elements : <ref>Array</ref> {
  <ref>Element</ref>? query(DOMString relativeSelectors);
  <ref>Elements</ref> queryAll(DOMString relativeSelectors);
};</webidl>
    <InterfaceInheritance>
      <Name name="Array"/>
    </InterfaceInheritance>
    <Operation name="query" id="::Elements::query">
      <webidl>  <ref>Element</ref>? query(DOMString relativeSelectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryAll" id="::Elements::queryAll">
      <webidl>  <ref>Elements</ref> queryAll(DOMString relativeSelectors);</webidl>
      <Type name="Elements"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NodeList" id="::NodeList">
    <webidl>[Exposed=<ref>Window</ref>]
interface NodeList {
  getter <ref>Node</ref>? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;<ref>Node</ref>>;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation getter="getter" name="item" id="::NodeList::item">
      <webidl>  getter <ref>Node</ref>? item(unsigned long index);</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="length" readonly="readonly" id="::NodeList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Iterable>
      <webidl>  iterable&lt;<ref>Node</ref>>;</webidl>
      <Value>
        <Type name="Node"/>
      </Value>
    </Iterable>
  </Interface>
  <Interface name="HTMLCollection" id="::HTMLCollection">
    <webidl>[Exposed=<ref>Window</ref>]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  getter <ref>Element</ref>? namedItem(DOMString name);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="length" readonly="readonly" id="::HTMLCollection::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::HTMLCollection::item">
      <webidl>  getter <ref>Element</ref>? item(unsigned long index);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="namedItem" id="::HTMLCollection::namedItem">
      <webidl>  getter <ref>Element</ref>? namedItem(DOMString name);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MutationObserver" id="::MutationObserver">
    <webidl>[Constructor(<ref>MutationCallback</ref> callback)]
interface MutationObserver {
  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);
  void disconnect();
  sequence&lt;<ref>MutationRecord</ref>> takeRecords();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(<ref>MutationCallback</ref> callback)</webidl>
        <ArgumentList>
          <Argument name="callback">
            <Type name="MutationCallback"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="observe" id="::MutationObserver::observe">
      <webidl>  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="target">
          <Type name="Node"/>
        </Argument>
        <Argument name="options">
          <Type name="MutationObserverInit"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="disconnect" id="::MutationObserver::disconnect">
      <webidl>  void disconnect();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="takeRecords" id="::MutationObserver::takeRecords">
      <webidl>  sequence&lt;<ref>MutationRecord</ref>> takeRecords();</webidl>
      <Type type="sequence">
        <Type name="MutationRecord"/>
      </Type>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Callback name="MutationCallback" id="::MutationCallback">
    <webidl>callback MutationCallback = void (sequence&lt;<ref>MutationRecord</ref>> mutations, <ref>MutationObserver</ref> observer);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="mutations">
        <Type type="sequence">
          <Type name="MutationRecord"/>
        </Type>
      </Argument>
      <Argument name="observer">
        <Type name="MutationObserver"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Dictionary name="MutationObserverInit" id="::MutationObserverInit">
    <webidl>dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};</webidl>
    <DictionaryMember name="childList" value="false" id="::MutationObserverInit::childList">
      <webidl>  boolean childList = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributes" id="::MutationObserverInit::attributes">
      <webidl>  boolean attributes;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="characterData" id="::MutationObserverInit::characterData">
      <webidl>  boolean characterData;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="subtree" value="false" id="::MutationObserverInit::subtree">
      <webidl>  boolean subtree = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributeOldValue" id="::MutationObserverInit::attributeOldValue">
      <webidl>  boolean attributeOldValue;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="characterDataOldValue" id="::MutationObserverInit::characterDataOldValue">
      <webidl>  boolean characterDataOldValue;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributeFilter" id="::MutationObserverInit::attributeFilter">
      <webidl>  sequence&lt;DOMString> attributeFilter;</webidl>
      <Type type="sequence">
        <Type type="DOMString"/>
      </Type>
    </DictionaryMember>
  </Dictionary>
  <Interface name="MutationRecord" id="::MutationRecord">
    <webidl>[Exposed=<ref>Window</ref>]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute <ref>Node</ref> target;
  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;
  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="type" readonly="readonly" id="::MutationRecord::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" readonly="readonly" id="::MutationRecord::target">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> target;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="addedNodes" readonly="readonly" id="::MutationRecord::addedNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="removedNodes" readonly="readonly" id="::MutationRecord::removedNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="previousSibling" readonly="readonly" id="::MutationRecord::previousSibling">
      <webidl>  readonly attribute <ref>Node</ref>? previousSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextSibling" readonly="readonly" id="::MutationRecord::nextSibling">
      <webidl>  readonly attribute <ref>Node</ref>? nextSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="attributeName" readonly="readonly" id="::MutationRecord::attributeName">
      <webidl>  readonly attribute DOMString? attributeName;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="attributeNamespace" readonly="readonly" id="::MutationRecord::attributeNamespace">
      <webidl>  readonly attribute DOMString? attributeNamespace;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="oldValue" readonly="readonly" id="::MutationRecord::oldValue">
      <webidl>  readonly attribute DOMString? oldValue;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Node" id="::Node">
    <webidl>[Exposed=<ref>Window</ref>]
interface Node : <ref>EventTarget</ref> {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; 
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; 
  const unsigned short ENTITY_REFERENCE_NODE = 5; 
  const unsigned short ENTITY_NODE = 6; 
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; 
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString baseURI;

  readonly attribute <ref>Document</ref>? ownerDocument;
  readonly attribute <ref>Node</ref>? parentNode;
  readonly attribute <ref>Element</ref>? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;
  readonly attribute <ref>Node</ref>? firstChild;
  readonly attribute <ref>Node</ref>? lastChild;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);
  boolean isEqualNode(<ref>Node</ref>? otherNode);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(<ref>Node</ref> other);
  boolean contains(<ref>Node</ref>? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);
  <ref>Node</ref> appendChild(<ref>Node</ref> node);
  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);
  <ref>Node</ref> removeChild(<ref>Node</ref> child);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Const name="ELEMENT_NODE" value="1" id="::Node::ELEMENT_NODE">
      <webidl>  const unsigned short ELEMENT_NODE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ATTRIBUTE_NODE" value="2" id="::Node::ATTRIBUTE_NODE">
      <webidl>  const unsigned short ATTRIBUTE_NODE = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="TEXT_NODE" value="3" id="::Node::TEXT_NODE">
      <webidl>  const unsigned short TEXT_NODE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CDATA_SECTION_NODE" value="4" id="::Node::CDATA_SECTION_NODE">
      <webidl>  const unsigned short CDATA_SECTION_NODE = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ENTITY_REFERENCE_NODE" value="5" id="::Node::ENTITY_REFERENCE_NODE">
      <webidl>  const unsigned short ENTITY_REFERENCE_NODE = 5;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ENTITY_NODE" value="6" id="::Node::ENTITY_NODE">
      <webidl>  const unsigned short ENTITY_NODE = 6;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="PROCESSING_INSTRUCTION_NODE" value="7" id="::Node::PROCESSING_INSTRUCTION_NODE">
      <webidl>  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="COMMENT_NODE" value="8" id="::Node::COMMENT_NODE">
      <webidl>  const unsigned short COMMENT_NODE = 8;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_NODE" value="9" id="::Node::DOCUMENT_NODE">
      <webidl>  const unsigned short DOCUMENT_NODE = 9;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_TYPE_NODE" value="10" id="::Node::DOCUMENT_TYPE_NODE">
      <webidl>  const unsigned short DOCUMENT_TYPE_NODE = 10;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_FRAGMENT_NODE" value="11" id="::Node::DOCUMENT_FRAGMENT_NODE">
      <webidl>  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NOTATION_NODE" value="12" id="::Node::NOTATION_NODE">
      <webidl>  const unsigned short NOTATION_NODE = 12;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="nodeType" readonly="readonly" id="::Node::nodeType">
      <webidl>  readonly attribute unsigned short nodeType;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="nodeName" readonly="readonly" id="::Node::nodeName">
      <webidl>  readonly attribute DOMString nodeName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="baseURI" readonly="readonly" id="::Node::baseURI">
      <webidl>  readonly attribute DOMString baseURI;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ownerDocument" readonly="readonly" id="::Node::ownerDocument">
      <webidl>  readonly attribute <ref>Document</ref>? ownerDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute name="parentNode" readonly="readonly" id="::Node::parentNode">
      <webidl>  readonly attribute <ref>Node</ref>? parentNode;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="parentElement" readonly="readonly" id="::Node::parentElement">
      <webidl>  readonly attribute <ref>Element</ref>? parentElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="hasChildNodes" id="::Node::hasChildNodes">
      <webidl>  boolean hasChildNodes();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="childNodes" readonly="readonly" id="::Node::childNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="firstChild" readonly="readonly" id="::Node::firstChild">
      <webidl>  readonly attribute <ref>Node</ref>? firstChild;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="lastChild" readonly="readonly" id="::Node::lastChild">
      <webidl>  readonly attribute <ref>Node</ref>? lastChild;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="previousSibling" readonly="readonly" id="::Node::previousSibling">
      <webidl>  readonly attribute <ref>Node</ref>? previousSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextSibling" readonly="readonly" id="::Node::nextSibling">
      <webidl>  readonly attribute <ref>Node</ref>? nextSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nodeValue" id="::Node::nodeValue">
      <webidl>           attribute DOMString? nodeValue;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="textContent" id="::Node::textContent">
      <webidl>           attribute DOMString? textContent;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Operation name="normalize" id="::Node::normalize">
      <webidl>  void normalize();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="cloneNode" id="::Node::cloneNode">
      <webidl>  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
      <ArgumentList>
        <Argument optional="optional" name="deep" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isEqualNode" id="::Node::isEqualNode">
      <webidl>  boolean isEqualNode(<ref>Node</ref>? otherNode);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="otherNode">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="DOCUMENT_POSITION_DISCONNECTED" value="0x01" id="::Node::DOCUMENT_POSITION_DISCONNECTED">
      <webidl>  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_PRECEDING" value="0x02" id="::Node::DOCUMENT_POSITION_PRECEDING">
      <webidl>  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_FOLLOWING" value="0x04" id="::Node::DOCUMENT_POSITION_FOLLOWING">
      <webidl>  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_CONTAINS" value="0x08" id="::Node::DOCUMENT_POSITION_CONTAINS">
      <webidl>  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_CONTAINED_BY" value="0x10" id="::Node::DOCUMENT_POSITION_CONTAINED_BY">
      <webidl>  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" value="0x20" id="::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC">
      <webidl>  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Operation name="compareDocumentPosition" id="::Node::compareDocumentPosition">
      <webidl>  unsigned short compareDocumentPosition(<ref>Node</ref> other);</webidl>
      <Type type="unsigned short"/>
      <ArgumentList>
        <Argument name="other">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="contains" id="::Node::contains">
      <webidl>  boolean contains(<ref>Node</ref>? other);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="other">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="lookupPrefix" id="::Node::lookupPrefix">
      <webidl>  DOMString? lookupPrefix(DOMString? namespace);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="lookupNamespaceURI" id="::Node::lookupNamespaceURI">
      <webidl>  DOMString? lookupNamespaceURI(DOMString? prefix);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="prefix">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isDefaultNamespace" id="::Node::isDefaultNamespace">
      <webidl>  boolean isDefaultNamespace(DOMString? namespace);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="insertBefore" id="::Node::insertBefore">
      <webidl>  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="child">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="appendChild" id="::Node::appendChild">
      <webidl>  <ref>Node</ref> appendChild(<ref>Node</ref> node);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceChild" id="::Node::replaceChild">
      <webidl>  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="child">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeChild" id="::Node::removeChild">
      <webidl>  <ref>Node</ref> removeChild(<ref>Node</ref> child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="child">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Document" id="::Document">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface Document : <ref>Node</ref> {
  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; 
  readonly attribute DOMString inputEncoding; 
  readonly attribute DOMString contentType;

  readonly attribute <ref>DocumentType</ref>? doctype;
  readonly attribute <ref>Element</ref>? documentElement;
  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);

  [NewObject] <ref>Element</ref> createElement(DOMString localName);
  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();
  [NewObject] <ref>Text</ref> createTextNode(DOMString data);
  [NewObject] <ref>Comment</ref> createComment(DOMString data);
  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);
  <ref>Node</ref> adoptNode(<ref>Node</ref> node);

  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);
  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] <ref>Event</ref> createEvent(DOMString interface);

  [NewObject] <ref>Range</ref> createRange();

  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="implementation" readonly="readonly" id="::Document::implementation">
      <webidl>  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMImplementation"/>
    </Attribute>
    <Attribute name="URL" readonly="readonly" id="::Document::URL">
      <webidl>  readonly attribute DOMString URL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="documentURI" readonly="readonly" id="::Document::documentURI">
      <webidl>  readonly attribute DOMString documentURI;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="origin" readonly="readonly" id="::Document::origin">
      <webidl>  readonly attribute DOMString origin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="compatMode" readonly="readonly" id="::Document::compatMode">
      <webidl>  readonly attribute DOMString compatMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="characterSet" readonly="readonly" id="::Document::characterSet">
      <webidl>  readonly attribute DOMString characterSet;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" readonly="readonly" id="::Document::charset">
      <webidl>  readonly attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="inputEncoding" readonly="readonly" id="::Document::inputEncoding">
      <webidl>  readonly attribute DOMString inputEncoding;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="contentType" readonly="readonly" id="::Document::contentType">
      <webidl>  readonly attribute DOMString contentType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="doctype" readonly="readonly" id="::Document::doctype">
      <webidl>  readonly attribute <ref>DocumentType</ref>? doctype;</webidl>
      <Type name="DocumentType" nullable="nullable"/>
    </Attribute>
    <Attribute name="documentElement" readonly="readonly" id="::Document::documentElement">
      <webidl>  readonly attribute <ref>Element</ref>? documentElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="getElementsByTagName" id="::Document::getElementsByTagName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagNameNS" id="::Document::getElementsByTagNameNS">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByClassName" id="::Document::getElementsByClassName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="classNames">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createElement" id="::Document::createElement">
      <webidl>  [NewObject] <ref>Element</ref> createElement(DOMString localName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createElementNS" id="::Document::createElementNS">
      <webidl>  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createDocumentFragment" id="::Document::createDocumentFragment">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="createTextNode" id="::Document::createTextNode">
      <webidl>  [NewObject] <ref>Text</ref> createTextNode(DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Text"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createComment" id="::Document::createComment">
      <webidl>  [NewObject] <ref>Comment</ref> createComment(DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Comment"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createProcessingInstruction" id="::Document::createProcessingInstruction">
      <webidl>  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="ProcessingInstruction"/>
      <ArgumentList>
        <Argument name="target">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="importNode" id="::Document::importNode">
      <webidl>  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="deep" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="adoptNode" id="::Document::adoptNode">
      <webidl>  <ref>Node</ref> adoptNode(<ref>Node</ref> node);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createAttribute" id="::Document::createAttribute">
      <webidl>  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createAttributeNS" id="::Document::createAttributeNS">
      <webidl>  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createEvent" id="::Document::createEvent">
      <webidl>  [NewObject] <ref>Event</ref> createEvent(DOMString interface);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Event"/>
      <ArgumentList>
        <Argument name="interface">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createRange" id="::Document::createRange">
      <webidl>  [NewObject] <ref>Range</ref> createRange();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Range"/>
      <ArgumentList/>
    </Operation>
    <Operation name="createNodeIterator" id="::Document::createNodeIterator">
      <webidl>  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeIterator"/>
      <ArgumentList>
        <Argument name="root">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="whatToShow" value="0xFFFFFFFF">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="filter" value="null">
          <Type name="NodeFilter" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createTreeWalker" id="::Document::createTreeWalker">
      <webidl>  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="TreeWalker"/>
      <ArgumentList>
        <Argument name="root">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="whatToShow" value="0xFFFFFFFF">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="filter" value="null">
          <Type name="NodeFilter" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="XMLDocument" id="::XMLDocument">
    <webidl>[Exposed=<ref>Window</ref>]
interface XMLDocument : <ref>Document</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Document"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="DOMImplementation" id="::DOMImplementation">
    <webidl>[Exposed=<ref>Window</ref>]
interface DOMImplementation {
  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);
  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);

  boolean hasFeature(); 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="createDocumentType" id="::DOMImplementation::createDocumentType">
      <webidl>  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentType"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="publicId">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="systemId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createDocument" id="::DOMImplementation::createDocument">
      <webidl>  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="XMLDocument"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <ExtendedAttributeList>
            <ExtendedAttribute name="TreatNullAs" value="EmptyString">
              <webidl>TreatNullAs</webidl>
            </ExtendedAttribute>
          </ExtendedAttributeList>
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="doctype" value="null">
          <Type name="DocumentType" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createHTMLDocument" id="::DOMImplementation::createHTMLDocument">
      <webidl>  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Document"/>
      <ArgumentList>
        <Argument optional="optional" name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasFeature" id="::DOMImplementation::hasFeature">
      <webidl>  boolean hasFeature();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="DocumentFragment" id="::DocumentFragment">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface DocumentFragment : <ref>Node</ref> {
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="DocumentType" id="::DocumentType">
    <webidl>[Exposed=<ref>Window</ref>]
interface DocumentType : <ref>Node</ref> {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="name" readonly="readonly" id="::DocumentType::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="publicId" readonly="readonly" id="::DocumentType::publicId">
      <webidl>  readonly attribute DOMString publicId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="systemId" readonly="readonly" id="::DocumentType::systemId">
      <webidl>  readonly attribute DOMString systemId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Element" id="::Element">
    <webidl>[Exposed=<ref>Window</ref>]
interface Element : <ref>Node</ref> {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;

  boolean hasAttributes();
  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;
  sequence&lt;DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);
  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);

  <ref>Element</ref>? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); 

  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="namespaceURI" readonly="readonly" id="::Element::namespaceURI">
      <webidl>  readonly attribute DOMString? namespaceURI;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="prefix" readonly="readonly" id="::Element::prefix">
      <webidl>  readonly attribute DOMString? prefix;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="localName" readonly="readonly" id="::Element::localName">
      <webidl>  readonly attribute DOMString localName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="tagName" readonly="readonly" id="::Element::tagName">
      <webidl>  readonly attribute DOMString tagName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="id" id="::Element::id">
      <webidl>           attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="className" id="::Element::className">
      <webidl>           attribute DOMString className;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="classList" readonly="readonly" id="::Element::classList">
      <webidl>  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Operation name="hasAttributes" id="::Element::hasAttributes">
      <webidl>  boolean hasAttributes();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="attributes" readonly="readonly" id="::Element::attributes">
      <webidl>  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NamedNodeMap"/>
    </Attribute>
    <Operation name="getAttributeNames" id="::Element::getAttributeNames">
      <webidl>  sequence&lt;DOMString> getAttributeNames();</webidl>
      <Type type="sequence">
        <Type type="DOMString"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="getAttribute" id="::Element::getAttribute">
      <webidl>  DOMString? getAttribute(DOMString qualifiedName);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNS" id="::Element::getAttributeNS">
      <webidl>  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttribute" id="::Element::setAttribute">
      <webidl>  void setAttribute(DOMString qualifiedName, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNS" id="::Element::setAttributeNS">
      <webidl>  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttribute" id="::Element::removeAttribute">
      <webidl>  void removeAttribute(DOMString qualifiedName);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttributeNS" id="::Element::removeAttributeNS">
      <webidl>  void removeAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasAttribute" id="::Element::hasAttribute">
      <webidl>  boolean hasAttribute(DOMString qualifiedName);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasAttributeNS" id="::Element::hasAttributeNS">
      <webidl>  boolean hasAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNode" id="::Element::getAttributeNode">
      <webidl>  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNodeNS" id="::Element::getAttributeNodeNS">
      <webidl>  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNode" id="::Element::setAttributeNode">
      <webidl>  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNodeNS" id="::Element::setAttributeNodeNS">
      <webidl>  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttributeNode" id="::Element::removeAttributeNode">
      <webidl>  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="closest" id="::Element::closest">
      <webidl>  <ref>Element</ref>? closest(DOMString selectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="matches" id="::Element::matches">
      <webidl>  boolean matches(DOMString selectors);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="webkitMatchesSelector" id="::Element::webkitMatchesSelector">
      <webidl>  boolean webkitMatchesSelector(DOMString selectors);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagName" id="::Element::getElementsByTagName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagNameNS" id="::Element::getElementsByTagNameNS">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByClassName" id="::Element::getElementsByClassName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="classNames">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NamedNodeMap" id="::NamedNodeMap">
    <webidl>[Exposed=<ref>Window</ref>]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter <ref>Attr</ref>? item(unsigned long index);
  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);
  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);
  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="length" readonly="readonly" id="::NamedNodeMap::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::NamedNodeMap::item">
      <webidl>  getter <ref>Attr</ref>? item(unsigned long index);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="getNamedItem" id="::NamedNodeMap::getNamedItem">
      <webidl>  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getNamedItemNS" id="::NamedNodeMap::getNamedItemNS">
      <webidl>  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setNamedItem" id="::NamedNodeMap::setNamedItem">
      <webidl>  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setNamedItemNS" id="::NamedNodeMap::setNamedItemNS">
      <webidl>  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeNamedItem" id="::NamedNodeMap::removeNamedItem">
      <webidl>  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeNamedItemNS" id="::NamedNodeMap::removeNamedItemNS">
      <webidl>  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Attr" id="::Attr">
    <webidl>[Exposed=<ref>Window</ref>]
interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
  [TreatNullAs=EmptyString] attribute DOMString nodeValue; 
  [TreatNullAs=EmptyString] attribute DOMString textContent; 

  readonly attribute <ref>Element</ref>? ownerElement;

  readonly attribute boolean specified; 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="namespaceURI" readonly="readonly" id="::Attr::namespaceURI">
      <webidl>  readonly attribute DOMString? namespaceURI;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="prefix" readonly="readonly" id="::Attr::prefix">
      <webidl>  readonly attribute DOMString? prefix;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="localName" readonly="readonly" id="::Attr::localName">
      <webidl>  readonly attribute DOMString localName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" readonly="readonly" id="::Attr::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::Attr::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="nodeValue" id="::Attr::nodeValue">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString nodeValue;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="textContent" id="::Attr::textContent">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString textContent;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ownerElement" readonly="readonly" id="::Attr::ownerElement">
      <webidl>  readonly attribute <ref>Element</ref>? ownerElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="specified" readonly="readonly" id="::Attr::specified">
      <webidl>  readonly attribute boolean specified;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="CharacterData" id="::CharacterData">
    <webidl>[Exposed=<ref>Window</ref>]
interface CharacterData : <ref>Node</ref> {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="data" id="::CharacterData::data">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString data;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="length" readonly="readonly" id="::CharacterData::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="substringData" id="::CharacterData::substringData">
      <webidl>  DOMString substringData(unsigned long offset, unsigned long count);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="appendData" id="::CharacterData::appendData">
      <webidl>  void appendData(DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="insertData" id="::CharacterData::insertData">
      <webidl>  void insertData(unsigned long offset, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteData" id="::CharacterData::deleteData">
      <webidl>  void deleteData(unsigned long offset, unsigned long count);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceData" id="::CharacterData::replaceData">
      <webidl>  void replaceData(unsigned long offset, unsigned long count, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Text" id="::Text">
    <webidl>[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Text : <ref>CharacterData</ref> {
  [NewObject] <ref>Text</ref> splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional DOMString data = &quot;&quot;)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="data" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
    <Operation name="splitText" id="::Text::splitText">
      <webidl>  [NewObject] <ref>Text</ref> splitText(unsigned long offset);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Text"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="wholeText" readonly="readonly" id="::Text::wholeText">
      <webidl>  readonly attribute DOMString wholeText;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="ProcessingInstruction" id="::ProcessingInstruction">
    <webidl>[Exposed=<ref>Window</ref>]
interface ProcessingInstruction : <ref>CharacterData</ref> {
  readonly attribute DOMString target;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
    <Attribute name="target" readonly="readonly" id="::ProcessingInstruction::target">
      <webidl>  readonly attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Comment" id="::Comment">
    <webidl>[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Comment : <ref>CharacterData</ref> {
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional DOMString data = &quot;&quot;)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="data" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="Range" id="::Range">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface Range {
  readonly attribute <ref>Node</ref> startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute <ref>Node</ref> endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute <ref>Node</ref> commonAncestorContainer;

  void setStart(<ref>Node</ref> node, unsigned long offset);
  void setEnd(<ref>Node</ref> node, unsigned long offset);
  void setStartBefore(<ref>Node</ref> node);
  void setStartAfter(<ref>Node</ref> node);
  void setEndBefore(<ref>Node</ref> node);
  void setEndAfter(<ref>Node</ref> node);
  void collapse(optional boolean toStart = false);
  void selectNode(<ref>Node</ref> node);
  void selectNodeContents(<ref>Node</ref> node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);

  void deleteContents();
  [NewObject] <ref>DocumentFragment</ref> extractContents();
  [NewObject] <ref>DocumentFragment</ref> cloneContents();
  void insertNode(<ref>Node</ref> node);
  void surroundContents(<ref>Node</ref> newParent);

  [NewObject] <ref>Range</ref> cloneRange();
  void detach();

  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);
  short comparePoint(<ref>Node</ref> node, unsigned long offset);

  boolean intersectsNode(<ref>Node</ref> node);

  stringifier;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="startContainer" readonly="readonly" id="::Range::startContainer">
      <webidl>  readonly attribute <ref>Node</ref> startContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="startOffset" readonly="readonly" id="::Range::startOffset">
      <webidl>  readonly attribute unsigned long startOffset;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="endContainer" readonly="readonly" id="::Range::endContainer">
      <webidl>  readonly attribute <ref>Node</ref> endContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="endOffset" readonly="readonly" id="::Range::endOffset">
      <webidl>  readonly attribute unsigned long endOffset;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="collapsed" readonly="readonly" id="::Range::collapsed">
      <webidl>  readonly attribute boolean collapsed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="commonAncestorContainer" readonly="readonly" id="::Range::commonAncestorContainer">
      <webidl>  readonly attribute <ref>Node</ref> commonAncestorContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Operation name="setStart" id="::Range::setStart">
      <webidl>  void setStart(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEnd" id="::Range::setEnd">
      <webidl>  void setEnd(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setStartBefore" id="::Range::setStartBefore">
      <webidl>  void setStartBefore(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setStartAfter" id="::Range::setStartAfter">
      <webidl>  void setStartAfter(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEndBefore" id="::Range::setEndBefore">
      <webidl>  void setEndBefore(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEndAfter" id="::Range::setEndAfter">
      <webidl>  void setEndAfter(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="collapse" id="::Range::collapse">
      <webidl>  void collapse(optional boolean toStart = false);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="toStart" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="selectNode" id="::Range::selectNode">
      <webidl>  void selectNode(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="selectNodeContents" id="::Range::selectNodeContents">
      <webidl>  void selectNodeContents(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="START_TO_START" value="0" id="::Range::START_TO_START">
      <webidl>  const unsigned short START_TO_START = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="START_TO_END" value="1" id="::Range::START_TO_END">
      <webidl>  const unsigned short START_TO_END = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="END_TO_END" value="2" id="::Range::END_TO_END">
      <webidl>  const unsigned short END_TO_END = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="END_TO_START" value="3" id="::Range::END_TO_START">
      <webidl>  const unsigned short END_TO_START = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Operation name="compareBoundaryPoints" id="::Range::compareBoundaryPoints">
      <webidl>  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);</webidl>
      <Type type="short"/>
      <ArgumentList>
        <Argument name="how">
          <Type type="unsigned short"/>
        </Argument>
        <Argument name="sourceRange">
          <Type name="Range"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteContents" id="::Range::deleteContents">
      <webidl>  void deleteContents();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="extractContents" id="::Range::extractContents">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> extractContents();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="cloneContents" id="::Range::cloneContents">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> cloneContents();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="insertNode" id="::Range::insertNode">
      <webidl>  void insertNode(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="surroundContents" id="::Range::surroundContents">
      <webidl>  void surroundContents(<ref>Node</ref> newParent);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="newParent">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="cloneRange" id="::Range::cloneRange">
      <webidl>  [NewObject] <ref>Range</ref> cloneRange();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Range"/>
      <ArgumentList/>
    </Operation>
    <Operation name="detach" id="::Range::detach">
      <webidl>  void detach();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="isPointInRange" id="::Range::isPointInRange">
      <webidl>  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="comparePoint" id="::Range::comparePoint">
      <webidl>  short comparePoint(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="short"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="intersectsNode" id="::Range::intersectsNode">
      <webidl>  boolean intersectsNode(<ref>Node</ref> node);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Stringifier>
      <webidl>  stringifier;</webidl>
    </Stringifier>
  </Interface>
  <Interface name="NodeIterator" id="::NodeIterator">
    <webidl>[Exposed=<ref>Window</ref>]
interface NodeIterator {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute <ref>Node</ref> referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;

  <ref>Node</ref>? nextNode();
  <ref>Node</ref>? previousNode();

  void detach();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="root" readonly="readonly" id="::NodeIterator::root">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> root;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="referenceNode" readonly="readonly" id="::NodeIterator::referenceNode">
      <webidl>  readonly attribute <ref>Node</ref> referenceNode;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="pointerBeforeReferenceNode" readonly="readonly" id="::NodeIterator::pointerBeforeReferenceNode">
      <webidl>  readonly attribute boolean pointerBeforeReferenceNode;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="whatToShow" readonly="readonly" id="::NodeIterator::whatToShow">
      <webidl>  readonly attribute unsigned long whatToShow;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="filter" readonly="readonly" id="::NodeIterator::filter">
      <webidl>  readonly attribute <ref>NodeFilter</ref>? filter;</webidl>
      <Type name="NodeFilter" nullable="nullable"/>
    </Attribute>
    <Operation name="nextNode" id="::NodeIterator::nextNode">
      <webidl>  <ref>Node</ref>? nextNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousNode" id="::NodeIterator::previousNode">
      <webidl>  <ref>Node</ref>? previousNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="detach" id="::NodeIterator::detach">
      <webidl>  void detach();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="TreeWalker" id="::TreeWalker">
    <webidl>[Exposed=<ref>Window</ref>]
interface TreeWalker {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;
           attribute <ref>Node</ref> currentNode;

  <ref>Node</ref>? parentNode();
  <ref>Node</ref>? firstChild();
  <ref>Node</ref>? lastChild();
  <ref>Node</ref>? previousSibling();
  <ref>Node</ref>? nextSibling();
  <ref>Node</ref>? previousNode();
  <ref>Node</ref>? nextNode();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="root" readonly="readonly" id="::TreeWalker::root">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> root;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="whatToShow" readonly="readonly" id="::TreeWalker::whatToShow">
      <webidl>  readonly attribute unsigned long whatToShow;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="filter" readonly="readonly" id="::TreeWalker::filter">
      <webidl>  readonly attribute <ref>NodeFilter</ref>? filter;</webidl>
      <Type name="NodeFilter" nullable="nullable"/>
    </Attribute>
    <Attribute name="currentNode" id="::TreeWalker::currentNode">
      <webidl>           attribute <ref>Node</ref> currentNode;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Operation name="parentNode" id="::TreeWalker::parentNode">
      <webidl>  <ref>Node</ref>? parentNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="firstChild" id="::TreeWalker::firstChild">
      <webidl>  <ref>Node</ref>? firstChild();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="lastChild" id="::TreeWalker::lastChild">
      <webidl>  <ref>Node</ref>? lastChild();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousSibling" id="::TreeWalker::previousSibling">
      <webidl>  <ref>Node</ref>? previousSibling();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="nextSibling" id="::TreeWalker::nextSibling">
      <webidl>  <ref>Node</ref>? nextSibling();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousNode" id="::TreeWalker::previousNode">
      <webidl>  <ref>Node</ref>? previousNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="nextNode" id="::TreeWalker::nextNode">
      <webidl>  <ref>Node</ref>? nextNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="NodeFilter" callback="callback" id="::NodeFilter">
    <webidl>[Exposed=<ref>Window</ref>]
callback interface NodeFilter {
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; 
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; 
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; 
  const unsigned long SHOW_ENTITY = 0x20; 
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; 

  unsigned short acceptNode(<ref>Node</ref> node);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Const name="FILTER_ACCEPT" value="1" id="::NodeFilter::FILTER_ACCEPT">
      <webidl>  const unsigned short FILTER_ACCEPT = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="FILTER_REJECT" value="2" id="::NodeFilter::FILTER_REJECT">
      <webidl>  const unsigned short FILTER_REJECT = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="FILTER_SKIP" value="3" id="::NodeFilter::FILTER_SKIP">
      <webidl>  const unsigned short FILTER_SKIP = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="SHOW_ALL" value="0xFFFFFFFF" id="::NodeFilter::SHOW_ALL">
      <webidl>  const unsigned long SHOW_ALL = 0xFFFFFFFF;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ELEMENT" value="0x1" id="::NodeFilter::SHOW_ELEMENT">
      <webidl>  const unsigned long SHOW_ELEMENT = 0x1;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ATTRIBUTE" value="0x2" id="::NodeFilter::SHOW_ATTRIBUTE">
      <webidl>  const unsigned long SHOW_ATTRIBUTE = 0x2;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_TEXT" value="0x4" id="::NodeFilter::SHOW_TEXT">
      <webidl>  const unsigned long SHOW_TEXT = 0x4;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_CDATA_SECTION" value="0x8" id="::NodeFilter::SHOW_CDATA_SECTION">
      <webidl>  const unsigned long SHOW_CDATA_SECTION = 0x8;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ENTITY_REFERENCE" value="0x10" id="::NodeFilter::SHOW_ENTITY_REFERENCE">
      <webidl>  const unsigned long SHOW_ENTITY_REFERENCE = 0x10;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ENTITY" value="0x20" id="::NodeFilter::SHOW_ENTITY">
      <webidl>  const unsigned long SHOW_ENTITY = 0x20;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_PROCESSING_INSTRUCTION" value="0x40" id="::NodeFilter::SHOW_PROCESSING_INSTRUCTION">
      <webidl>  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_COMMENT" value="0x80" id="::NodeFilter::SHOW_COMMENT">
      <webidl>  const unsigned long SHOW_COMMENT = 0x80;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT" value="0x100" id="::NodeFilter::SHOW_DOCUMENT">
      <webidl>  const unsigned long SHOW_DOCUMENT = 0x100;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT_TYPE" value="0x200" id="::NodeFilter::SHOW_DOCUMENT_TYPE">
      <webidl>  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT_FRAGMENT" value="0x400" id="::NodeFilter::SHOW_DOCUMENT_FRAGMENT">
      <webidl>  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_NOTATION" value="0x800" id="::NodeFilter::SHOW_NOTATION">
      <webidl>  const unsigned long SHOW_NOTATION = 0x800;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Operation name="acceptNode" id="::NodeFilter::acceptNode">
      <webidl>  unsigned short acceptNode(<ref>Node</ref> node);</webidl>
      <Type type="unsigned short"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DOMTokenList" id="::DOMTokenList">
    <webidl>interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  void replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  stringifier;
  iterable&lt;DOMString>;
};</webidl>
    <Attribute name="length" readonly="readonly" id="::DOMTokenList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::DOMTokenList::item">
      <webidl>  getter DOMString? item(unsigned long index);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="contains" id="::DOMTokenList::contains">
      <webidl>  boolean contains(DOMString token);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::DOMTokenList::add">
      <webidl>  void add(DOMString... tokens);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="tokens">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::DOMTokenList::remove">
      <webidl>  void remove(DOMString... tokens);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="tokens">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toggle" id="::DOMTokenList::toggle">
      <webidl>  boolean toggle(DOMString token, optional boolean force);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="force">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replace" id="::DOMTokenList::replace">
      <webidl>  void replace(DOMString token, DOMString newToken);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="newToken">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="supports" id="::DOMTokenList::supports">
      <webidl>  boolean supports(DOMString token);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Stringifier>
      <webidl>  stringifier;</webidl>
    </Stringifier>
    <Iterable>
      <webidl>  iterable&lt;DOMString>;</webidl>
      <Value>
        <Type type="DOMString"/>
      </Value>
    </Iterable>
  </Interface>
  <Interface name="DOMSettableTokenList" id="::DOMSettableTokenList">
    <webidl>interface DOMSettableTokenList : <ref>DOMTokenList</ref> {
            attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="DOMTokenList"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::DOMSettableTokenList::value">
      <webidl>            attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Event" id="::Event">
    <webidl>[Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute <ref>EventTarget</ref>? target;
  readonly attribute <ref>EventTarget</ref>? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>EventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="EventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="type" readonly="readonly" id="::Event::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" readonly="readonly" id="::Event::target">
      <webidl>  readonly attribute <ref>EventTarget</ref>? target;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
    <Attribute name="currentTarget" readonly="readonly" id="::Event::currentTarget">
      <webidl>  readonly attribute <ref>EventTarget</ref>? currentTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
    <Const name="NONE" value="0" id="::Event::NONE">
      <webidl>  const unsigned short NONE = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CAPTURING_PHASE" value="1" id="::Event::CAPTURING_PHASE">
      <webidl>  const unsigned short CAPTURING_PHASE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="AT_TARGET" value="2" id="::Event::AT_TARGET">
      <webidl>  const unsigned short AT_TARGET = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="BUBBLING_PHASE" value="3" id="::Event::BUBBLING_PHASE">
      <webidl>  const unsigned short BUBBLING_PHASE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="eventPhase" readonly="readonly" id="::Event::eventPhase">
      <webidl>  readonly attribute unsigned short eventPhase;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Operation name="stopPropagation" id="::Event::stopPropagation">
      <webidl>  void stopPropagation();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stopImmediatePropagation" id="::Event::stopImmediatePropagation">
      <webidl>  void stopImmediatePropagation();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="bubbles" readonly="readonly" id="::Event::bubbles">
      <webidl>  readonly attribute boolean bubbles;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="cancelable" readonly="readonly" id="::Event::cancelable">
      <webidl>  readonly attribute boolean cancelable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="preventDefault" id="::Event::preventDefault">
      <webidl>  void preventDefault();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="defaultPrevented" readonly="readonly" id="::Event::defaultPrevented">
      <webidl>  readonly attribute boolean defaultPrevented;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="isTrusted" readonly="readonly" id="::Event::isTrusted">
      <webidl>  [Unforgeable] readonly attribute boolean isTrusted;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="timeStamp" readonly="readonly" id="::Event::timeStamp">
      <webidl>  readonly attribute <ref>DOMTimeStamp</ref> timeStamp;</webidl>
      <Type name="DOMTimeStamp"/>
    </Attribute>
    <Operation name="initEvent" id="::Event::initEvent">
      <webidl>  void initEvent(DOMString type, boolean bubbles, boolean cancelable);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="bubbles">
          <Type type="boolean"/>
        </Argument>
        <Argument name="cancelable">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="EventInit" id="::EventInit">
    <webidl>dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};</webidl>
    <DictionaryMember name="bubbles" value="false" id="::EventInit::bubbles">
      <webidl>  boolean bubbles = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="cancelable" value="false" id="::EventInit::cancelable">
      <webidl>  boolean cancelable = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="CustomEvent" id="::CustomEvent">
    <webidl>[Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict),
 Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface CustomEvent : <ref>Event</ref> {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>CustomEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="CustomEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="detail" readonly="readonly" id="::CustomEvent::detail">
      <webidl>  readonly attribute any detail;</webidl>
      <Type type="any"/>
    </Attribute>
    <Operation name="initCustomEvent" id="::CustomEvent::initCustomEvent">
      <webidl>  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="bubbles">
          <Type type="boolean"/>
        </Argument>
        <Argument name="cancelable">
          <Type type="boolean"/>
        </Argument>
        <Argument name="detail">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="CustomEventInit" id="::CustomEventInit">
    <webidl>dictionary CustomEventInit : <ref>EventInit</ref> {
  any detail = null;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="detail" value="null" id="::CustomEventInit::detail">
      <webidl>  any detail = null;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="EventTarget" id="::EventTarget">
    <webidl>[Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]
interface EventTarget {
  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);
  boolean dispatchEvent(<ref>Event</ref> event);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=(<ref>Window</ref>,<ref>Worker</ref>)]</webidl>
        <TypeList>
          <Type name="Window"/>
          <Type name="Worker"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="addEventListener" id="::EventTarget::addEventListener">
      <webidl>  void addEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="callback">
          <Type name="EventListener" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type type="union">
            <Type name="EventListenerOptions"/>
            <Type type="boolean"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeEventListener" id="::EventTarget::removeEventListener">
      <webidl>  void removeEventListener(DOMString type, <ref>EventListener</ref>? callback, optional (<ref>EventListenerOptions</ref> or boolean) options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="callback">
          <Type name="EventListener" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type type="union">
            <Type name="EventListenerOptions"/>
            <Type type="boolean"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="dispatchEvent" id="::EventTarget::dispatchEvent">
      <webidl>  boolean dispatchEvent(<ref>Event</ref> event);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="event">
          <Type name="Event"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="EventListener" callback="callback" id="::EventListener">
    <webidl>callback interface EventListener {
  void handleEvent(<ref>Event</ref> event);
};</webidl>
    <Operation name="handleEvent" id="::EventListener::handleEvent">
      <webidl>  void handleEvent(<ref>Event</ref> event);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="event">
          <Type name="Event"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="EventListenerOptions" id="::EventListenerOptions">
    <webidl>dictionary EventListenerOptions {
  boolean capture;
  boolean passive;
};</webidl>
    <DictionaryMember name="capture" id="::EventListenerOptions::capture">
      <webidl>  boolean capture;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="passive" id="::EventListenerOptions::passive">
      <webidl>  boolean passive;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="NonElementParentNode" id="::NonElementParentNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonElementParentNode {
  <ref>Element</ref>? getElementById(DOMString elementId);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="getElementById" id="::NonElementParentNode::getElementById">
      <webidl>  <ref>Element</ref>? getElementById(DOMString elementId);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="elementId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Document" name2="NonElementParentNode">
    <webidl><ref>Document</ref> implements <ref>NonElementParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="DocumentFragment" name2="NonElementParentNode">
    <webidl><ref>DocumentFragment</ref> implements <ref>NonElementParentNode</ref>;</webidl>
  </Implements>
  <Interface name="ParentNode" id="::ParentNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ParentNode {
  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;
  readonly attribute <ref>Element</ref>? firstElementChild;
  readonly attribute <ref>Element</ref>? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);

  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);
  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);
  <ref>Element</ref>? querySelector(DOMString selectors);
  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="children" readonly="readonly" id="::ParentNode::children">
      <webidl>  [SameObject] readonly attribute <ref>HTMLCollection</ref> children;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="firstElementChild" readonly="readonly" id="::ParentNode::firstElementChild">
      <webidl>  readonly attribute <ref>Element</ref>? firstElementChild;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="lastElementChild" readonly="readonly" id="::ParentNode::lastElementChild">
      <webidl>  readonly attribute <ref>Element</ref>? lastElementChild;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="childElementCount" readonly="readonly" id="::ParentNode::childElementCount">
      <webidl>  readonly attribute unsigned long childElementCount;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="prepend" id="::ParentNode::prepend">
      <webidl>  [Unscopeable] void prepend((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="append" id="::ParentNode::append">
      <webidl>  [Unscopeable] void append((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="query" id="::ParentNode::query">
      <webidl>  [Unscopeable] <ref>Element</ref>? query(DOMString relativeSelectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryAll" id="::ParentNode::queryAll">
      <webidl>  [NewObject, Unscopeable] <ref>Elements</ref> queryAll(DOMString relativeSelectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unscopeable">
          <webidl> Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Elements"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="querySelector" id="::ParentNode::querySelector">
      <webidl>  <ref>Element</ref>? querySelector(DOMString selectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="querySelectorAll" id="::ParentNode::querySelectorAll">
      <webidl>  [NewObject] <ref>NodeList</ref> querySelectorAll(DOMString selectors);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Document" name2="ParentNode">
    <webidl><ref>Document</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="DocumentFragment" name2="ParentNode">
    <webidl><ref>DocumentFragment</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Implements name1="Element" name2="ParentNode">
    <webidl><ref>Element</ref> implements <ref>ParentNode</ref>;</webidl>
  </Implements>
  <Interface name="NonDocumentTypeChildNode" id="::NonDocumentTypeChildNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface NonDocumentTypeChildNode {
  readonly attribute <ref>Element</ref>? previousElementSibling;
  readonly attribute <ref>Element</ref>? nextElementSibling;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="previousElementSibling" readonly="readonly" id="::NonDocumentTypeChildNode::previousElementSibling">
      <webidl>  readonly attribute <ref>Element</ref>? previousElementSibling;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextElementSibling" readonly="readonly" id="::NonDocumentTypeChildNode::nextElementSibling">
      <webidl>  readonly attribute <ref>Element</ref>? nextElementSibling;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Implements name1="Element" name2="NonDocumentTypeChildNode">
    <webidl><ref>Element</ref> implements <ref>NonDocumentTypeChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="CharacterData" name2="NonDocumentTypeChildNode">
    <webidl><ref>CharacterData</ref> implements <ref>NonDocumentTypeChildNode</ref>;</webidl>
  </Implements>
  <Interface name="ChildNode" id="::ChildNode">
    <webidl>[NoInterfaceObject,
 Exposed=<ref>Window</ref>]
interface ChildNode {
  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);
  [Unscopeable] void remove();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="before" id="::ChildNode::before">
      <webidl>  [Unscopeable] void before((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="after" id="::ChildNode::after">
      <webidl>  [Unscopeable] void after((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceWith" id="::ChildNode::replaceWith">
      <webidl>  [Unscopeable] void replaceWith((<ref>Node</ref> or DOMString)... nodes);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="nodes">
          <Type type="union">
            <Type name="Node"/>
            <Type type="DOMString"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::ChildNode::remove">
      <webidl>  [Unscopeable] void remove();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unscopeable">
          <webidl>Unscopeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="DocumentType" name2="ChildNode">
    <webidl><ref>DocumentType</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="Element" name2="ChildNode">
    <webidl><ref>Element</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Implements name1="CharacterData" name2="ChildNode">
    <webidl><ref>CharacterData</ref> implements <ref>ChildNode</ref>;</webidl>
  </Implements>
  <Interface name="Elements" id="::Elements">
    <webidl>interface Elements : <ref>Array</ref> {
  <ref>Element</ref>? query(DOMString relativeSelectors);
  <ref>Elements</ref> queryAll(DOMString relativeSelectors);
};</webidl>
    <InterfaceInheritance>
      <Name name="Array"/>
    </InterfaceInheritance>
    <Operation name="query" id="::Elements::query">
      <webidl>  <ref>Element</ref>? query(DOMString relativeSelectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryAll" id="::Elements::queryAll">
      <webidl>  <ref>Elements</ref> queryAll(DOMString relativeSelectors);</webidl>
      <Type name="Elements"/>
      <ArgumentList>
        <Argument name="relativeSelectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NodeList" id="::NodeList">
    <webidl>[Exposed=<ref>Window</ref>]
interface NodeList {
  getter <ref>Node</ref>? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;<ref>Node</ref>>;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation getter="getter" name="item" id="::NodeList::item">
      <webidl>  getter <ref>Node</ref>? item(unsigned long index);</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="length" readonly="readonly" id="::NodeList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Iterable>
      <webidl>  iterable&lt;<ref>Node</ref>>;</webidl>
      <Value>
        <Type name="Node"/>
      </Value>
    </Iterable>
  </Interface>
  <Interface name="HTMLCollection" id="::HTMLCollection">
    <webidl>[Exposed=<ref>Window</ref>]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter <ref>Element</ref>? item(unsigned long index);
  getter <ref>Element</ref>? namedItem(DOMString name);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="length" readonly="readonly" id="::HTMLCollection::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::HTMLCollection::item">
      <webidl>  getter <ref>Element</ref>? item(unsigned long index);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="namedItem" id="::HTMLCollection::namedItem">
      <webidl>  getter <ref>Element</ref>? namedItem(DOMString name);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MutationObserver" id="::MutationObserver">
    <webidl>[Constructor(<ref>MutationCallback</ref> callback)]
interface MutationObserver {
  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);
  void disconnect();
  sequence&lt;<ref>MutationRecord</ref>> takeRecords();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(<ref>MutationCallback</ref> callback)</webidl>
        <ArgumentList>
          <Argument name="callback">
            <Type name="MutationCallback"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="observe" id="::MutationObserver::observe">
      <webidl>  void observe(<ref>Node</ref> target, <ref>MutationObserverInit</ref> options);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="target">
          <Type name="Node"/>
        </Argument>
        <Argument name="options">
          <Type name="MutationObserverInit"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="disconnect" id="::MutationObserver::disconnect">
      <webidl>  void disconnect();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="takeRecords" id="::MutationObserver::takeRecords">
      <webidl>  sequence&lt;<ref>MutationRecord</ref>> takeRecords();</webidl>
      <Type type="sequence">
        <Type name="MutationRecord"/>
      </Type>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Callback name="MutationCallback" id="::MutationCallback">
    <webidl>callback MutationCallback = void (sequence&lt;<ref>MutationRecord</ref>> mutations, <ref>MutationObserver</ref> observer);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="mutations">
        <Type type="sequence">
          <Type name="MutationRecord"/>
        </Type>
      </Argument>
      <Argument name="observer">
        <Type name="MutationObserver"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Dictionary name="MutationObserverInit" id="::MutationObserverInit">
    <webidl>dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};</webidl>
    <DictionaryMember name="childList" value="false" id="::MutationObserverInit::childList">
      <webidl>  boolean childList = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributes" id="::MutationObserverInit::attributes">
      <webidl>  boolean attributes;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="characterData" id="::MutationObserverInit::characterData">
      <webidl>  boolean characterData;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="subtree" value="false" id="::MutationObserverInit::subtree">
      <webidl>  boolean subtree = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributeOldValue" id="::MutationObserverInit::attributeOldValue">
      <webidl>  boolean attributeOldValue;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="characterDataOldValue" id="::MutationObserverInit::characterDataOldValue">
      <webidl>  boolean characterDataOldValue;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="attributeFilter" id="::MutationObserverInit::attributeFilter">
      <webidl>  sequence&lt;DOMString> attributeFilter;</webidl>
      <Type type="sequence">
        <Type type="DOMString"/>
      </Type>
    </DictionaryMember>
  </Dictionary>
  <Interface name="MutationRecord" id="::MutationRecord">
    <webidl>[Exposed=<ref>Window</ref>]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute <ref>Node</ref> target;
  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;
  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="type" readonly="readonly" id="::MutationRecord::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" readonly="readonly" id="::MutationRecord::target">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> target;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="addedNodes" readonly="readonly" id="::MutationRecord::addedNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> addedNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="removedNodes" readonly="readonly" id="::MutationRecord::removedNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> removedNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="previousSibling" readonly="readonly" id="::MutationRecord::previousSibling">
      <webidl>  readonly attribute <ref>Node</ref>? previousSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextSibling" readonly="readonly" id="::MutationRecord::nextSibling">
      <webidl>  readonly attribute <ref>Node</ref>? nextSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="attributeName" readonly="readonly" id="::MutationRecord::attributeName">
      <webidl>  readonly attribute DOMString? attributeName;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="attributeNamespace" readonly="readonly" id="::MutationRecord::attributeNamespace">
      <webidl>  readonly attribute DOMString? attributeNamespace;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="oldValue" readonly="readonly" id="::MutationRecord::oldValue">
      <webidl>  readonly attribute DOMString? oldValue;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Node" id="::Node">
    <webidl>[Exposed=<ref>Window</ref>]
interface Node : <ref>EventTarget</ref> {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; 
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; 
  const unsigned short ENTITY_REFERENCE_NODE = 5; 
  const unsigned short ENTITY_NODE = 6; 
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; 
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString baseURI;

  readonly attribute <ref>Document</ref>? ownerDocument;
  readonly attribute <ref>Node</ref>? parentNode;
  readonly attribute <ref>Element</ref>? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;
  readonly attribute <ref>Node</ref>? firstChild;
  readonly attribute <ref>Node</ref>? lastChild;
  readonly attribute <ref>Node</ref>? previousSibling;
  readonly attribute <ref>Node</ref>? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);
  boolean isEqualNode(<ref>Node</ref>? otherNode);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(<ref>Node</ref> other);
  boolean contains(<ref>Node</ref>? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);
  <ref>Node</ref> appendChild(<ref>Node</ref> node);
  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);
  <ref>Node</ref> removeChild(<ref>Node</ref> child);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Const name="ELEMENT_NODE" value="1" id="::Node::ELEMENT_NODE">
      <webidl>  const unsigned short ELEMENT_NODE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ATTRIBUTE_NODE" value="2" id="::Node::ATTRIBUTE_NODE">
      <webidl>  const unsigned short ATTRIBUTE_NODE = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="TEXT_NODE" value="3" id="::Node::TEXT_NODE">
      <webidl>  const unsigned short TEXT_NODE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CDATA_SECTION_NODE" value="4" id="::Node::CDATA_SECTION_NODE">
      <webidl>  const unsigned short CDATA_SECTION_NODE = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ENTITY_REFERENCE_NODE" value="5" id="::Node::ENTITY_REFERENCE_NODE">
      <webidl>  const unsigned short ENTITY_REFERENCE_NODE = 5;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ENTITY_NODE" value="6" id="::Node::ENTITY_NODE">
      <webidl>  const unsigned short ENTITY_NODE = 6;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="PROCESSING_INSTRUCTION_NODE" value="7" id="::Node::PROCESSING_INSTRUCTION_NODE">
      <webidl>  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="COMMENT_NODE" value="8" id="::Node::COMMENT_NODE">
      <webidl>  const unsigned short COMMENT_NODE = 8;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_NODE" value="9" id="::Node::DOCUMENT_NODE">
      <webidl>  const unsigned short DOCUMENT_NODE = 9;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_TYPE_NODE" value="10" id="::Node::DOCUMENT_TYPE_NODE">
      <webidl>  const unsigned short DOCUMENT_TYPE_NODE = 10;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_FRAGMENT_NODE" value="11" id="::Node::DOCUMENT_FRAGMENT_NODE">
      <webidl>  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NOTATION_NODE" value="12" id="::Node::NOTATION_NODE">
      <webidl>  const unsigned short NOTATION_NODE = 12;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute name="nodeType" readonly="readonly" id="::Node::nodeType">
      <webidl>  readonly attribute unsigned short nodeType;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="nodeName" readonly="readonly" id="::Node::nodeName">
      <webidl>  readonly attribute DOMString nodeName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="baseURI" readonly="readonly" id="::Node::baseURI">
      <webidl>  readonly attribute DOMString baseURI;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ownerDocument" readonly="readonly" id="::Node::ownerDocument">
      <webidl>  readonly attribute <ref>Document</ref>? ownerDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute name="parentNode" readonly="readonly" id="::Node::parentNode">
      <webidl>  readonly attribute <ref>Node</ref>? parentNode;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="parentElement" readonly="readonly" id="::Node::parentElement">
      <webidl>  readonly attribute <ref>Element</ref>? parentElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="hasChildNodes" id="::Node::hasChildNodes">
      <webidl>  boolean hasChildNodes();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="childNodes" readonly="readonly" id="::Node::childNodes">
      <webidl>  [SameObject] readonly attribute <ref>NodeList</ref> childNodes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeList"/>
    </Attribute>
    <Attribute name="firstChild" readonly="readonly" id="::Node::firstChild">
      <webidl>  readonly attribute <ref>Node</ref>? firstChild;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="lastChild" readonly="readonly" id="::Node::lastChild">
      <webidl>  readonly attribute <ref>Node</ref>? lastChild;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="previousSibling" readonly="readonly" id="::Node::previousSibling">
      <webidl>  readonly attribute <ref>Node</ref>? previousSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nextSibling" readonly="readonly" id="::Node::nextSibling">
      <webidl>  readonly attribute <ref>Node</ref>? nextSibling;</webidl>
      <Type name="Node" nullable="nullable"/>
    </Attribute>
    <Attribute name="nodeValue" id="::Node::nodeValue">
      <webidl>           attribute DOMString? nodeValue;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="textContent" id="::Node::textContent">
      <webidl>           attribute DOMString? textContent;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Operation name="normalize" id="::Node::normalize">
      <webidl>  void normalize();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="cloneNode" id="::Node::cloneNode">
      <webidl>  [NewObject] <ref>Node</ref> cloneNode(optional boolean deep = false);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
      <ArgumentList>
        <Argument optional="optional" name="deep" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isEqualNode" id="::Node::isEqualNode">
      <webidl>  boolean isEqualNode(<ref>Node</ref>? otherNode);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="otherNode">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="DOCUMENT_POSITION_DISCONNECTED" value="0x01" id="::Node::DOCUMENT_POSITION_DISCONNECTED">
      <webidl>  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_PRECEDING" value="0x02" id="::Node::DOCUMENT_POSITION_PRECEDING">
      <webidl>  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_FOLLOWING" value="0x04" id="::Node::DOCUMENT_POSITION_FOLLOWING">
      <webidl>  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_CONTAINS" value="0x08" id="::Node::DOCUMENT_POSITION_CONTAINS">
      <webidl>  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_CONTAINED_BY" value="0x10" id="::Node::DOCUMENT_POSITION_CONTAINED_BY">
      <webidl>  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" value="0x20" id="::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC">
      <webidl>  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Operation name="compareDocumentPosition" id="::Node::compareDocumentPosition">
      <webidl>  unsigned short compareDocumentPosition(<ref>Node</ref> other);</webidl>
      <Type type="unsigned short"/>
      <ArgumentList>
        <Argument name="other">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="contains" id="::Node::contains">
      <webidl>  boolean contains(<ref>Node</ref>? other);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="other">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="lookupPrefix" id="::Node::lookupPrefix">
      <webidl>  DOMString? lookupPrefix(DOMString? namespace);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="lookupNamespaceURI" id="::Node::lookupNamespaceURI">
      <webidl>  DOMString? lookupNamespaceURI(DOMString? prefix);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="prefix">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isDefaultNamespace" id="::Node::isDefaultNamespace">
      <webidl>  boolean isDefaultNamespace(DOMString? namespace);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="insertBefore" id="::Node::insertBefore">
      <webidl>  <ref>Node</ref> insertBefore(<ref>Node</ref> node, <ref>Node</ref>? child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="child">
          <Type name="Node" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="appendChild" id="::Node::appendChild">
      <webidl>  <ref>Node</ref> appendChild(<ref>Node</ref> node);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceChild" id="::Node::replaceChild">
      <webidl>  <ref>Node</ref> replaceChild(<ref>Node</ref> node, <ref>Node</ref> child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="child">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeChild" id="::Node::removeChild">
      <webidl>  <ref>Node</ref> removeChild(<ref>Node</ref> child);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="child">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Document" id="::Document">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface Document : <ref>Node</ref> {
  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; 
  readonly attribute DOMString inputEncoding; 
  readonly attribute DOMString contentType;

  readonly attribute <ref>DocumentType</ref>? doctype;
  readonly attribute <ref>Element</ref>? documentElement;
  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);

  [NewObject] <ref>Element</ref> createElement(DOMString localName);
  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();
  [NewObject] <ref>Text</ref> createTextNode(DOMString data);
  [NewObject] <ref>Comment</ref> createComment(DOMString data);
  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);
  <ref>Node</ref> adoptNode(<ref>Node</ref> node);

  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);
  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] <ref>Event</ref> createEvent(DOMString interface);

  [NewObject] <ref>Range</ref> createRange();

  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="implementation" readonly="readonly" id="::Document::implementation">
      <webidl>  [SameObject] readonly attribute <ref>DOMImplementation</ref> implementation;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMImplementation"/>
    </Attribute>
    <Attribute name="URL" readonly="readonly" id="::Document::URL">
      <webidl>  readonly attribute DOMString URL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="documentURI" readonly="readonly" id="::Document::documentURI">
      <webidl>  readonly attribute DOMString documentURI;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="origin" readonly="readonly" id="::Document::origin">
      <webidl>  readonly attribute DOMString origin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="compatMode" readonly="readonly" id="::Document::compatMode">
      <webidl>  readonly attribute DOMString compatMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="characterSet" readonly="readonly" id="::Document::characterSet">
      <webidl>  readonly attribute DOMString characterSet;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" readonly="readonly" id="::Document::charset">
      <webidl>  readonly attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="inputEncoding" readonly="readonly" id="::Document::inputEncoding">
      <webidl>  readonly attribute DOMString inputEncoding;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="contentType" readonly="readonly" id="::Document::contentType">
      <webidl>  readonly attribute DOMString contentType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="doctype" readonly="readonly" id="::Document::doctype">
      <webidl>  readonly attribute <ref>DocumentType</ref>? doctype;</webidl>
      <Type name="DocumentType" nullable="nullable"/>
    </Attribute>
    <Attribute name="documentElement" readonly="readonly" id="::Document::documentElement">
      <webidl>  readonly attribute <ref>Element</ref>? documentElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="getElementsByTagName" id="::Document::getElementsByTagName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagNameNS" id="::Document::getElementsByTagNameNS">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByClassName" id="::Document::getElementsByClassName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="classNames">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createElement" id="::Document::createElement">
      <webidl>  [NewObject] <ref>Element</ref> createElement(DOMString localName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createElementNS" id="::Document::createElementNS">
      <webidl>  [NewObject] <ref>Element</ref> createElementNS(DOMString? namespace, DOMString qualifiedName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createDocumentFragment" id="::Document::createDocumentFragment">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> createDocumentFragment();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="createTextNode" id="::Document::createTextNode">
      <webidl>  [NewObject] <ref>Text</ref> createTextNode(DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Text"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createComment" id="::Document::createComment">
      <webidl>  [NewObject] <ref>Comment</ref> createComment(DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Comment"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createProcessingInstruction" id="::Document::createProcessingInstruction">
      <webidl>  [NewObject] <ref>ProcessingInstruction</ref> createProcessingInstruction(DOMString target, DOMString data);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="ProcessingInstruction"/>
      <ArgumentList>
        <Argument name="target">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="importNode" id="::Document::importNode">
      <webidl>  [NewObject] <ref>Node</ref> importNode(<ref>Node</ref> node, optional boolean deep = false);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="deep" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="adoptNode" id="::Document::adoptNode">
      <webidl>  <ref>Node</ref> adoptNode(<ref>Node</ref> node);</webidl>
      <Type name="Node"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createAttribute" id="::Document::createAttribute">
      <webidl>  [NewObject] <ref>Attr</ref> createAttribute(DOMString localName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createAttributeNS" id="::Document::createAttributeNS">
      <webidl>  [NewObject] <ref>Attr</ref> createAttributeNS(DOMString? namespace, DOMString qualifiedName);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createEvent" id="::Document::createEvent">
      <webidl>  [NewObject] <ref>Event</ref> createEvent(DOMString interface);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Event"/>
      <ArgumentList>
        <Argument name="interface">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createRange" id="::Document::createRange">
      <webidl>  [NewObject] <ref>Range</ref> createRange();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Range"/>
      <ArgumentList/>
    </Operation>
    <Operation name="createNodeIterator" id="::Document::createNodeIterator">
      <webidl>  [NewObject] <ref>NodeIterator</ref> createNodeIterator(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NodeIterator"/>
      <ArgumentList>
        <Argument name="root">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="whatToShow" value="0xFFFFFFFF">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="filter" value="null">
          <Type name="NodeFilter" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createTreeWalker" id="::Document::createTreeWalker">
      <webidl>  [NewObject] <ref>TreeWalker</ref> createTreeWalker(<ref>Node</ref> root, optional unsigned long whatToShow = 0xFFFFFFFF, optional <ref>NodeFilter</ref>? filter = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="TreeWalker"/>
      <ArgumentList>
        <Argument name="root">
          <Type name="Node"/>
        </Argument>
        <Argument optional="optional" name="whatToShow" value="0xFFFFFFFF">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="filter" value="null">
          <Type name="NodeFilter" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="XMLDocument" id="::XMLDocument">
    <webidl>[Exposed=<ref>Window</ref>]
interface XMLDocument : <ref>Document</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Document"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="DOMImplementation" id="::DOMImplementation">
    <webidl>[Exposed=<ref>Window</ref>]
interface DOMImplementation {
  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);
  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);

  boolean hasFeature(); 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="createDocumentType" id="::DOMImplementation::createDocumentType">
      <webidl>  [NewObject] <ref>DocumentType</ref> createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentType"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="publicId">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="systemId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createDocument" id="::DOMImplementation::createDocument">
      <webidl>  [NewObject] <ref>XMLDocument</ref> createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional <ref>DocumentType</ref>? doctype = null);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="XMLDocument"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <ExtendedAttributeList>
            <ExtendedAttribute name="TreatNullAs" value="EmptyString">
              <webidl>TreatNullAs</webidl>
            </ExtendedAttribute>
          </ExtendedAttributeList>
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="doctype" value="null">
          <Type name="DocumentType" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createHTMLDocument" id="::DOMImplementation::createHTMLDocument">
      <webidl>  [NewObject] <ref>Document</ref> createHTMLDocument(optional DOMString title);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Document"/>
      <ArgumentList>
        <Argument optional="optional" name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasFeature" id="::DOMImplementation::hasFeature">
      <webidl>  boolean hasFeature();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="DocumentFragment" id="::DocumentFragment">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface DocumentFragment : <ref>Node</ref> {
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="DocumentType" id="::DocumentType">
    <webidl>[Exposed=<ref>Window</ref>]
interface DocumentType : <ref>Node</ref> {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="name" readonly="readonly" id="::DocumentType::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="publicId" readonly="readonly" id="::DocumentType::publicId">
      <webidl>  readonly attribute DOMString publicId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="systemId" readonly="readonly" id="::DocumentType::systemId">
      <webidl>  readonly attribute DOMString systemId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Element" id="::Element">
    <webidl>[Exposed=<ref>Window</ref>]
interface Element : <ref>Node</ref> {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;

  boolean hasAttributes();
  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;
  sequence&lt;DOMString> getAttributeNames();
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);
  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);

  <ref>Element</ref>? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); 

  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);
  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="namespaceURI" readonly="readonly" id="::Element::namespaceURI">
      <webidl>  readonly attribute DOMString? namespaceURI;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="prefix" readonly="readonly" id="::Element::prefix">
      <webidl>  readonly attribute DOMString? prefix;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="localName" readonly="readonly" id="::Element::localName">
      <webidl>  readonly attribute DOMString localName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="tagName" readonly="readonly" id="::Element::tagName">
      <webidl>  readonly attribute DOMString tagName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="id" id="::Element::id">
      <webidl>           attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="className" id="::Element::className">
      <webidl>           attribute DOMString className;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="classList" readonly="readonly" id="::Element::classList">
      <webidl>  [SameObject] readonly attribute <ref>DOMTokenList</ref> classList;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Operation name="hasAttributes" id="::Element::hasAttributes">
      <webidl>  boolean hasAttributes();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="attributes" readonly="readonly" id="::Element::attributes">
      <webidl>  [SameObject] readonly attribute <ref>NamedNodeMap</ref> attributes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="NamedNodeMap"/>
    </Attribute>
    <Operation name="getAttributeNames" id="::Element::getAttributeNames">
      <webidl>  sequence&lt;DOMString> getAttributeNames();</webidl>
      <Type type="sequence">
        <Type type="DOMString"/>
      </Type>
      <ArgumentList/>
    </Operation>
    <Operation name="getAttribute" id="::Element::getAttribute">
      <webidl>  DOMString? getAttribute(DOMString qualifiedName);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNS" id="::Element::getAttributeNS">
      <webidl>  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttribute" id="::Element::setAttribute">
      <webidl>  void setAttribute(DOMString qualifiedName, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNS" id="::Element::setAttributeNS">
      <webidl>  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttribute" id="::Element::removeAttribute">
      <webidl>  void removeAttribute(DOMString qualifiedName);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttributeNS" id="::Element::removeAttributeNS">
      <webidl>  void removeAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasAttribute" id="::Element::hasAttribute">
      <webidl>  boolean hasAttribute(DOMString qualifiedName);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="hasAttributeNS" id="::Element::hasAttributeNS">
      <webidl>  boolean hasAttributeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNode" id="::Element::getAttributeNode">
      <webidl>  <ref>Attr</ref>? getAttributeNode(DOMString qualifiedName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAttributeNodeNS" id="::Element::getAttributeNodeNS">
      <webidl>  <ref>Attr</ref>? getAttributeNodeNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNode" id="::Element::setAttributeNode">
      <webidl>  <ref>Attr</ref>? setAttributeNode(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setAttributeNodeNS" id="::Element::setAttributeNodeNS">
      <webidl>  <ref>Attr</ref>? setAttributeNodeNS(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAttributeNode" id="::Element::removeAttributeNode">
      <webidl>  <ref>Attr</ref> removeAttributeNode(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="closest" id="::Element::closest">
      <webidl>  <ref>Element</ref>? closest(DOMString selectors);</webidl>
      <Type name="Element" nullable="nullable"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="matches" id="::Element::matches">
      <webidl>  boolean matches(DOMString selectors);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="webkitMatchesSelector" id="::Element::webkitMatchesSelector">
      <webidl>  boolean webkitMatchesSelector(DOMString selectors);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="selectors">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagName" id="::Element::getElementsByTagName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagName(DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByTagNameNS" id="::Element::getElementsByTagNameNS">
      <webidl>  <ref>HTMLCollection</ref> getElementsByTagNameNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getElementsByClassName" id="::Element::getElementsByClassName">
      <webidl>  <ref>HTMLCollection</ref> getElementsByClassName(DOMString classNames);</webidl>
      <Type name="HTMLCollection"/>
      <ArgumentList>
        <Argument name="classNames">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NamedNodeMap" id="::NamedNodeMap">
    <webidl>[Exposed=<ref>Window</ref>]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter <ref>Attr</ref>? item(unsigned long index);
  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);
  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);
  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);
  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);
  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);
  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="length" readonly="readonly" id="::NamedNodeMap::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::NamedNodeMap::item">
      <webidl>  getter <ref>Attr</ref>? item(unsigned long index);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter" name="getNamedItem" id="::NamedNodeMap::getNamedItem">
      <webidl>  getter <ref>Attr</ref>? getNamedItem(DOMString qualifiedName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getNamedItemNS" id="::NamedNodeMap::getNamedItemNS">
      <webidl>  <ref>Attr</ref>? getNamedItemNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setNamedItem" id="::NamedNodeMap::setNamedItem">
      <webidl>  <ref>Attr</ref>? setNamedItem(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setNamedItemNS" id="::NamedNodeMap::setNamedItemNS">
      <webidl>  <ref>Attr</ref>? setNamedItemNS(<ref>Attr</ref> attr);</webidl>
      <Type name="Attr" nullable="nullable"/>
      <ArgumentList>
        <Argument name="attr">
          <Type name="Attr"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeNamedItem" id="::NamedNodeMap::removeNamedItem">
      <webidl>  <ref>Attr</ref> removeNamedItem(DOMString qualifiedName);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="qualifiedName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeNamedItemNS" id="::NamedNodeMap::removeNamedItemNS">
      <webidl>  <ref>Attr</ref> removeNamedItemNS(DOMString? namespace, DOMString localName);</webidl>
      <Type name="Attr"/>
      <ArgumentList>
        <Argument name="namespace">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="localName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Attr" id="::Attr">
    <webidl>[Exposed=<ref>Window</ref>]
interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
  [TreatNullAs=EmptyString] attribute DOMString nodeValue; 
  [TreatNullAs=EmptyString] attribute DOMString textContent; 

  readonly attribute <ref>Element</ref>? ownerElement;

  readonly attribute boolean specified; 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="namespaceURI" readonly="readonly" id="::Attr::namespaceURI">
      <webidl>  readonly attribute DOMString? namespaceURI;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="prefix" readonly="readonly" id="::Attr::prefix">
      <webidl>  readonly attribute DOMString? prefix;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="localName" readonly="readonly" id="::Attr::localName">
      <webidl>  readonly attribute DOMString localName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" readonly="readonly" id="::Attr::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::Attr::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="nodeValue" id="::Attr::nodeValue">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString nodeValue;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="textContent" id="::Attr::textContent">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString textContent;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ownerElement" readonly="readonly" id="::Attr::ownerElement">
      <webidl>  readonly attribute <ref>Element</ref>? ownerElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Attribute name="specified" readonly="readonly" id="::Attr::specified">
      <webidl>  readonly attribute boolean specified;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="CharacterData" id="::CharacterData">
    <webidl>[Exposed=<ref>Window</ref>]
interface CharacterData : <ref>Node</ref> {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Node"/>
    </InterfaceInheritance>
    <Attribute name="data" id="::CharacterData::data">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString data;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="length" readonly="readonly" id="::CharacterData::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="substringData" id="::CharacterData::substringData">
      <webidl>  DOMString substringData(unsigned long offset, unsigned long count);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="appendData" id="::CharacterData::appendData">
      <webidl>  void appendData(DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="insertData" id="::CharacterData::insertData">
      <webidl>  void insertData(unsigned long offset, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteData" id="::CharacterData::deleteData">
      <webidl>  void deleteData(unsigned long offset, unsigned long count);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceData" id="::CharacterData::replaceData">
      <webidl>  void replaceData(unsigned long offset, unsigned long count, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Text" id="::Text">
    <webidl>[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Text : <ref>CharacterData</ref> {
  [NewObject] <ref>Text</ref> splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional DOMString data = &quot;&quot;)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="data" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
    <Operation name="splitText" id="::Text::splitText">
      <webidl>  [NewObject] <ref>Text</ref> splitText(unsigned long offset);</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Text"/>
      <ArgumentList>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="wholeText" readonly="readonly" id="::Text::wholeText">
      <webidl>  readonly attribute DOMString wholeText;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="ProcessingInstruction" id="::ProcessingInstruction">
    <webidl>[Exposed=<ref>Window</ref>]
interface ProcessingInstruction : <ref>CharacterData</ref> {
  readonly attribute DOMString target;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
    <Attribute name="target" readonly="readonly" id="::ProcessingInstruction::target">
      <webidl>  readonly attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Comment" id="::Comment">
    <webidl>[Constructor(optional DOMString data = &quot;&quot;),
 Exposed=<ref>Window</ref>]
interface Comment : <ref>CharacterData</ref> {
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(optional DOMString data = &quot;&quot;)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="data" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="CharacterData"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="Range" id="::Range">
    <webidl>[Constructor,
 Exposed=<ref>Window</ref>]
interface Range {
  readonly attribute <ref>Node</ref> startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute <ref>Node</ref> endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute <ref>Node</ref> commonAncestorContainer;

  void setStart(<ref>Node</ref> node, unsigned long offset);
  void setEnd(<ref>Node</ref> node, unsigned long offset);
  void setStartBefore(<ref>Node</ref> node);
  void setStartAfter(<ref>Node</ref> node);
  void setEndBefore(<ref>Node</ref> node);
  void setEndAfter(<ref>Node</ref> node);
  void collapse(optional boolean toStart = false);
  void selectNode(<ref>Node</ref> node);
  void selectNodeContents(<ref>Node</ref> node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);

  void deleteContents();
  [NewObject] <ref>DocumentFragment</ref> extractContents();
  [NewObject] <ref>DocumentFragment</ref> cloneContents();
  void insertNode(<ref>Node</ref> node);
  void surroundContents(<ref>Node</ref> newParent);

  [NewObject] <ref>Range</ref> cloneRange();
  void detach();

  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);
  short comparePoint(<ref>Node</ref> node, unsigned long offset);

  boolean intersectsNode(<ref>Node</ref> node);

  stringifier;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Exposed">
        <webidl> Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="startContainer" readonly="readonly" id="::Range::startContainer">
      <webidl>  readonly attribute <ref>Node</ref> startContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="startOffset" readonly="readonly" id="::Range::startOffset">
      <webidl>  readonly attribute unsigned long startOffset;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="endContainer" readonly="readonly" id="::Range::endContainer">
      <webidl>  readonly attribute <ref>Node</ref> endContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="endOffset" readonly="readonly" id="::Range::endOffset">
      <webidl>  readonly attribute unsigned long endOffset;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="collapsed" readonly="readonly" id="::Range::collapsed">
      <webidl>  readonly attribute boolean collapsed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="commonAncestorContainer" readonly="readonly" id="::Range::commonAncestorContainer">
      <webidl>  readonly attribute <ref>Node</ref> commonAncestorContainer;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Operation name="setStart" id="::Range::setStart">
      <webidl>  void setStart(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEnd" id="::Range::setEnd">
      <webidl>  void setEnd(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setStartBefore" id="::Range::setStartBefore">
      <webidl>  void setStartBefore(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setStartAfter" id="::Range::setStartAfter">
      <webidl>  void setStartAfter(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEndBefore" id="::Range::setEndBefore">
      <webidl>  void setEndBefore(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setEndAfter" id="::Range::setEndAfter">
      <webidl>  void setEndAfter(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="collapse" id="::Range::collapse">
      <webidl>  void collapse(optional boolean toStart = false);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="toStart" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="selectNode" id="::Range::selectNode">
      <webidl>  void selectNode(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="selectNodeContents" id="::Range::selectNodeContents">
      <webidl>  void selectNodeContents(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="START_TO_START" value="0" id="::Range::START_TO_START">
      <webidl>  const unsigned short START_TO_START = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="START_TO_END" value="1" id="::Range::START_TO_END">
      <webidl>  const unsigned short START_TO_END = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="END_TO_END" value="2" id="::Range::END_TO_END">
      <webidl>  const unsigned short END_TO_END = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="END_TO_START" value="3" id="::Range::END_TO_START">
      <webidl>  const unsigned short END_TO_START = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Operation name="compareBoundaryPoints" id="::Range::compareBoundaryPoints">
      <webidl>  short compareBoundaryPoints(unsigned short how, <ref>Range</ref> sourceRange);</webidl>
      <Type type="short"/>
      <ArgumentList>
        <Argument name="how">
          <Type type="unsigned short"/>
        </Argument>
        <Argument name="sourceRange">
          <Type name="Range"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteContents" id="::Range::deleteContents">
      <webidl>  void deleteContents();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="extractContents" id="::Range::extractContents">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> extractContents();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="cloneContents" id="::Range::cloneContents">
      <webidl>  [NewObject] <ref>DocumentFragment</ref> cloneContents();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DocumentFragment"/>
      <ArgumentList/>
    </Operation>
    <Operation name="insertNode" id="::Range::insertNode">
      <webidl>  void insertNode(<ref>Node</ref> node);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="surroundContents" id="::Range::surroundContents">
      <webidl>  void surroundContents(<ref>Node</ref> newParent);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="newParent">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="cloneRange" id="::Range::cloneRange">
      <webidl>  [NewObject] <ref>Range</ref> cloneRange();</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NewObject">
          <webidl>NewObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Range"/>
      <ArgumentList/>
    </Operation>
    <Operation name="detach" id="::Range::detach">
      <webidl>  void detach();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="isPointInRange" id="::Range::isPointInRange">
      <webidl>  boolean isPointInRange(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="comparePoint" id="::Range::comparePoint">
      <webidl>  short comparePoint(<ref>Node</ref> node, unsigned long offset);</webidl>
      <Type type="short"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="intersectsNode" id="::Range::intersectsNode">
      <webidl>  boolean intersectsNode(<ref>Node</ref> node);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Stringifier>
      <webidl>  stringifier;</webidl>
    </Stringifier>
  </Interface>
  <Interface name="NodeIterator" id="::NodeIterator">
    <webidl>[Exposed=<ref>Window</ref>]
interface NodeIterator {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute <ref>Node</ref> referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;

  <ref>Node</ref>? nextNode();
  <ref>Node</ref>? previousNode();

  void detach();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="root" readonly="readonly" id="::NodeIterator::root">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> root;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="referenceNode" readonly="readonly" id="::NodeIterator::referenceNode">
      <webidl>  readonly attribute <ref>Node</ref> referenceNode;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="pointerBeforeReferenceNode" readonly="readonly" id="::NodeIterator::pointerBeforeReferenceNode">
      <webidl>  readonly attribute boolean pointerBeforeReferenceNode;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="whatToShow" readonly="readonly" id="::NodeIterator::whatToShow">
      <webidl>  readonly attribute unsigned long whatToShow;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="filter" readonly="readonly" id="::NodeIterator::filter">
      <webidl>  readonly attribute <ref>NodeFilter</ref>? filter;</webidl>
      <Type name="NodeFilter" nullable="nullable"/>
    </Attribute>
    <Operation name="nextNode" id="::NodeIterator::nextNode">
      <webidl>  <ref>Node</ref>? nextNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousNode" id="::NodeIterator::previousNode">
      <webidl>  <ref>Node</ref>? previousNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="detach" id="::NodeIterator::detach">
      <webidl>  void detach();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="TreeWalker" id="::TreeWalker">
    <webidl>[Exposed=<ref>Window</ref>]
interface TreeWalker {
  [SameObject] readonly attribute <ref>Node</ref> root;
  readonly attribute unsigned long whatToShow;
  readonly attribute <ref>NodeFilter</ref>? filter;
           attribute <ref>Node</ref> currentNode;

  <ref>Node</ref>? parentNode();
  <ref>Node</ref>? firstChild();
  <ref>Node</ref>? lastChild();
  <ref>Node</ref>? previousSibling();
  <ref>Node</ref>? nextSibling();
  <ref>Node</ref>? previousNode();
  <ref>Node</ref>? nextNode();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="root" readonly="readonly" id="::TreeWalker::root">
      <webidl>  [SameObject] readonly attribute <ref>Node</ref> root;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="SameObject">
          <webidl>SameObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Node"/>
    </Attribute>
    <Attribute name="whatToShow" readonly="readonly" id="::TreeWalker::whatToShow">
      <webidl>  readonly attribute unsigned long whatToShow;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="filter" readonly="readonly" id="::TreeWalker::filter">
      <webidl>  readonly attribute <ref>NodeFilter</ref>? filter;</webidl>
      <Type name="NodeFilter" nullable="nullable"/>
    </Attribute>
    <Attribute name="currentNode" id="::TreeWalker::currentNode">
      <webidl>           attribute <ref>Node</ref> currentNode;</webidl>
      <Type name="Node"/>
    </Attribute>
    <Operation name="parentNode" id="::TreeWalker::parentNode">
      <webidl>  <ref>Node</ref>? parentNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="firstChild" id="::TreeWalker::firstChild">
      <webidl>  <ref>Node</ref>? firstChild();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="lastChild" id="::TreeWalker::lastChild">
      <webidl>  <ref>Node</ref>? lastChild();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousSibling" id="::TreeWalker::previousSibling">
      <webidl>  <ref>Node</ref>? previousSibling();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="nextSibling" id="::TreeWalker::nextSibling">
      <webidl>  <ref>Node</ref>? nextSibling();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="previousNode" id="::TreeWalker::previousNode">
      <webidl>  <ref>Node</ref>? previousNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
    <Operation name="nextNode" id="::TreeWalker::nextNode">
      <webidl>  <ref>Node</ref>? nextNode();</webidl>
      <Type name="Node" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="NodeFilter" callback="callback" id="::NodeFilter">
    <webidl>[Exposed=<ref>Window</ref>]
callback interface NodeFilter {
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; 
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; 
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; 
  const unsigned long SHOW_ENTITY = 0x20; 
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; 

  unsigned short acceptNode(<ref>Node</ref> node);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Exposed">
        <webidl>Exposed=<ref>Window</ref>]</webidl>
        <TypeList>
          <Type name="Window"/>
        </TypeList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Const name="FILTER_ACCEPT" value="1" id="::NodeFilter::FILTER_ACCEPT">
      <webidl>  const unsigned short FILTER_ACCEPT = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="FILTER_REJECT" value="2" id="::NodeFilter::FILTER_REJECT">
      <webidl>  const unsigned short FILTER_REJECT = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="FILTER_SKIP" value="3" id="::NodeFilter::FILTER_SKIP">
      <webidl>  const unsigned short FILTER_SKIP = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="SHOW_ALL" value="0xFFFFFFFF" id="::NodeFilter::SHOW_ALL">
      <webidl>  const unsigned long SHOW_ALL = 0xFFFFFFFF;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ELEMENT" value="0x1" id="::NodeFilter::SHOW_ELEMENT">
      <webidl>  const unsigned long SHOW_ELEMENT = 0x1;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ATTRIBUTE" value="0x2" id="::NodeFilter::SHOW_ATTRIBUTE">
      <webidl>  const unsigned long SHOW_ATTRIBUTE = 0x2;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_TEXT" value="0x4" id="::NodeFilter::SHOW_TEXT">
      <webidl>  const unsigned long SHOW_TEXT = 0x4;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_CDATA_SECTION" value="0x8" id="::NodeFilter::SHOW_CDATA_SECTION">
      <webidl>  const unsigned long SHOW_CDATA_SECTION = 0x8;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ENTITY_REFERENCE" value="0x10" id="::NodeFilter::SHOW_ENTITY_REFERENCE">
      <webidl>  const unsigned long SHOW_ENTITY_REFERENCE = 0x10;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_ENTITY" value="0x20" id="::NodeFilter::SHOW_ENTITY">
      <webidl>  const unsigned long SHOW_ENTITY = 0x20;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_PROCESSING_INSTRUCTION" value="0x40" id="::NodeFilter::SHOW_PROCESSING_INSTRUCTION">
      <webidl>  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_COMMENT" value="0x80" id="::NodeFilter::SHOW_COMMENT">
      <webidl>  const unsigned long SHOW_COMMENT = 0x80;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT" value="0x100" id="::NodeFilter::SHOW_DOCUMENT">
      <webidl>  const unsigned long SHOW_DOCUMENT = 0x100;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT_TYPE" value="0x200" id="::NodeFilter::SHOW_DOCUMENT_TYPE">
      <webidl>  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_DOCUMENT_FRAGMENT" value="0x400" id="::NodeFilter::SHOW_DOCUMENT_FRAGMENT">
      <webidl>  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Const name="SHOW_NOTATION" value="0x800" id="::NodeFilter::SHOW_NOTATION">
      <webidl>  const unsigned long SHOW_NOTATION = 0x800;</webidl>
      <Type type="unsigned long"/>
    </Const>
    <Operation name="acceptNode" id="::NodeFilter::acceptNode">
      <webidl>  unsigned short acceptNode(<ref>Node</ref> node);</webidl>
      <Type type="unsigned short"/>
      <ArgumentList>
        <Argument name="node">
          <Type name="Node"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DOMTokenList" id="::DOMTokenList">
    <webidl>interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  void replace(DOMString token, DOMString newToken);
  boolean supports(DOMString token);
  stringifier;
  iterable&lt;DOMString>;
};</webidl>
    <Attribute name="length" readonly="readonly" id="::DOMTokenList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::DOMTokenList::item">
      <webidl>  getter DOMString? item(unsigned long index);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="contains" id="::DOMTokenList::contains">
      <webidl>  boolean contains(DOMString token);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::DOMTokenList::add">
      <webidl>  void add(DOMString... tokens);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="tokens">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::DOMTokenList::remove">
      <webidl>  void remove(DOMString... tokens);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="tokens">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toggle" id="::DOMTokenList::toggle">
      <webidl>  boolean toggle(DOMString token, optional boolean force);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="force">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replace" id="::DOMTokenList::replace">
      <webidl>  void replace(DOMString token, DOMString newToken);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="newToken">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="supports" id="::DOMTokenList::supports">
      <webidl>  boolean supports(DOMString token);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="token">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Stringifier>
      <webidl>  stringifier;</webidl>
    </Stringifier>
    <Iterable>
      <webidl>  iterable&lt;DOMString>;</webidl>
      <Value>
        <Type type="DOMString"/>
      </Value>
    </Iterable>
  </Interface>
  <Interface name="DOMSettableTokenList" id="::DOMSettableTokenList">
    <webidl>interface DOMSettableTokenList : <ref>DOMTokenList</ref> {
            attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="DOMTokenList"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::DOMSettableTokenList::value">
      <webidl>            attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
</Definitions>
